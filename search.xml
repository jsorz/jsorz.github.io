<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初识技术管理：信任、愿景与抓手]]></title>
    <url>%2Fblog%2F2024%2F02%2Fpast-three-years.html</url>
    <content type="text"><![CDATA[距离上一篇博客已经过去三年多了，并不是自己惰性，而是我几乎把所有精力投在了工作上的思考和总结。要说这三年干嘛去了，一句话说是做技术管理去了，值得为自己总结沉淀下。 如何 Landing作为之前的一线大头兵，只虚线带过2~3人，突然跳槽到新的环境，空降带团队，而且还是第一次实线带人，第一次负责 10+ 人的团队，第一次管理异地团队。这三个第一次无疑给我增加了更大的难度，提前有预期刚开始的几个月会面临很大压力。 在入职后的第二周，老大就让我出差去深圳认识团队。我的团队除了我，其他人都在深圳，10+人其实是两个小组分别支持两条不同的业务线，都属于业务前端开发。在一个周会的场合上，老大正式介绍了我，然后团队成员分别做自我介绍，团队就算正式交给我负责了。在轮流介绍的过程中，还有个小插曲，有两位同学都表达了前端没有技术含量的观点，还有位同学说了一些更直白的话。我只能以我过去的经验向他们表达了“做好前端不容易”的观点，说了两句后就 close 此话题，场面有一些尴尬。 1. 先了解业务无论何种岗位，我认为在新人 Landing 阶段都必须先了解公司业务，而了解公司业务最快的方式是看公司内部的培训课程。中大厂内部都有丰富的视频和课件学习资料，这些资料往往质量很高，可以快速让我了解公司的主要业务和所在行业的行业知识。 作为研发岗位，熟悉所负责项目的最快方式是查阅过往的产品需求文档。要先了解所负责项目/模块在全局业务中处于什么位置，然后再挑选重要的项目/模块逐个查阅产品需求文档，特别是从0到1的那种大需求文档。 最后，根据学习金字塔理论，将自己学习到的行业知识、业务知识、项目概况等分享给其他人，先整理下来，找机会讲给别人听。 2. 同时熟悉人我是一个 I 人，学生时代还很内向。对于我来说，熟悉人比熟悉项目难得多，但这两件事必须同时做，因为 Landing 时间有限。现在回想起来，我当时用了两个方法来熟悉人。 第一个方法是用奶茶、家乡特产来刷脸。记得刚接管团队的第一周，我就买了喜茶一杯杯送到每个人座位上，记得多买两杯带给合作的后端、客户端 leader 顺便刷个脸熟。第二次去深圳出差时，我带了好多特产的饼和糕点，给自己团队以及合作的后端、客户端团队每人都分了一点儿，给做 leader 的每人一小盒。其实都是10元左右的小特产，图个诚意，我是新来的前端 leader。 第二个方法是借助熟悉人来熟悉业务。因为其他人在公司的资历都比我深，对业务和项目的演变都比我了解更多。有了上面的刷脸后，我就“好意思”去请教别人了，比如 APP 里哪些页面是 native 哪些是 H5，怎么申请一个线上环境的测试账号，公司的研发流程中会涉及到哪些人等等。有问题就不只可以问自己团队的小伙伴，还可以问其他团队的小伙伴。我不认为问一些类似“项目怎么跑/测试环境怎么调试”这样的问题很低级，这反而是作为 leader 应该去了解的，并且让以后的新人不再有这类疑问。 最后，因为我们公司的组织架构关系是不公开的，无法看到其他团队的组织架构，所以日常中接触到的人只能自己记在心里或小本上，包括在一些群里看到的消息，他负责什么、他是不是 leader、什么样的问题可以找他。时间长了后，可能需要积累一年，工作中接触到的大部分同事我都大概了解他们的职责和上下级关系。 3. 了解诉求，解决问题上面提的“熟悉人”更多是对合作团队的，这里“了解诉求”主要是对自己团队。在刚接管团队时，就做了些功课，团队成员每个人的毕业时间、学历、司龄、以及前任 leader 对他们的评价。在接管后的两周里，陆续与他们每个人都做了一次 one one，询问他们目前的工作范围、有什么想吐槽的、以及有什么自己想做的事。有些同学说的都是很个例的事情，我只能给建议，有些能帮的我尽力解决问题，有3个例子很值得拿出来一说。 1) 有一个同学反馈电脑太卡影响工作，想换电脑，但流程卡在 IT 运维那边。我一顿询问后，问到了公司电脑换领的要求，电脑也确实符合要求，事实上从电脑生产日期起已超过三年、但从电脑开始使用起还未到三年，所以一开始卡了流程。最后 IT 同事也答应了可以换电脑。另一个同学反馈手机测试机申请了一年都没申请到，就这个事，我也向上反馈了后来碰巧跟上了申请窗口。 2) 还有个同学表达了自己想学习，但不知道怎么样学才能不脱离实际工作，希望 leader 能够以身示范。这位同学也是第一次见面时说前端没有技术含量的，我有去看过他的代码，相当一部分 Ctrl+C/V，我认为这是极不负责态度的眼高手低。我挑了比较常见的表格增删改查场景，封装了一个类似 ProTable 的组件，建了组件库的 npm 包，写了组件库的文档和规范。可见当时团队的前端技术有多落后，这么多 Ctrl+C/V 的代码，团队这么多人竟然没有人尝试改变现状。我做好示范后，再让这位同学在具体页面中迁移并给组件库做补充。 3) 还有一位同学，可能因为工作才半年，在做一个从0到1的项目中遇到了不少困难，上线面临风险。我得知后一起介入了这个项目，从需求文档看起，先帮着一起解决测试阶段的问题，保证需求能够交付。后来我也一起参与了线上问题的排查工作，梳理页面流程的关键逻辑以及收到线上反馈时的应急方法。而对于这位工作才半年的同学，我让他一起参与了团队公共函数库的梳理，夯实下基础，之后去做其他相对稳一点的项目。 我借用前同事的一个观点来总结，就是不能只想着高大上的工作，要能够把手伸进下水道里。了解团队内的诉求，从问题切入，尽力解决问题。这几位同学，可能是团队里最先开始对我产生信任的。 4. 执行团队规范，全员参与建设根据前面与团队每一个人的 one one，我有两个不同的业务小组，存在一些共性如下。 如图都是团队小伙伴向我表达的意思，基本确定了我接下来至少半年要重点推动的事情。 技术任务：在产品需求之外争取技术任务，逐步清理项目中的包袱，把项目标准化 组件积累：团队没有沉淀，先从组件库、函数库开始逐步积累，减少低级的 Ctrl+C/V 分享机制：能够“分享”是比较高效的学习方法，既利于自己提升，又利于活跃技术氛围 最后能不能落地，执行力怎么样不好说，因为团队才刚开始，我通过团队规范和制度来执行。规范主要是一些文档约定，例如：新人 Landing 流程，需求研发流程，代码分支规范，生产发布 SOP 等。 规范主要为了减少犯错，制度是执行力的关键。我刚开始定了这些规矩：周二周四晨会，周五周会，周会分享制度（每周2人轮流）。周会分享强制执行了3个月，轮了两圈，每人都参与了两次分享。关于上面说的技术任务，刚开始我也是强制指派的，每个人都会被分到一项需求以外的技术任务，一轮结束以后才变成认领制，让优秀的同学有机会发挥。 Landing 总结空降 Landing 的三个月，很累也很欣慰，我的团队跨出了第一步，先“有”：组件函数有地方积累，项目优化有文档输出，线上问题有日志可查。虽然这3条放在其他公司其他团队来看，都上不了台面，但是通过自己的努力一点点将团队带到这里，也让我对我的团队有了更大的信心。有了“有”，后面才会有“快”和“好”。 如果要一句话总结第一次做管理如何 Landing，就是坦诚相待，做 leader 不是当领导，帮助团队一起做好事情。 第一年：走出技术蛮荒，团队技术转型走出蛮荒：两大问题1) 开发体验差 正如前面 Landing 阶段提到的“技术任务”和“组件积累”，为什么要做这两件事呢，根本原因还是开发体验太差了。早期团队中的项目全靠 copy，一个项目 copy 另一个项目都不带删代码的，一个页面 copy 另一个也不带删变量的。这也造成了需求做不完，技术没成长，后期维护难的恶性循环。 当时公司的大前端部也刚成立不到半年，也在推进前端工程化，工程化的第一步是标准化。标准化不光是靠文档约定，而是要靠流程靠工具自动化来保证更高的执行度。我们也跟着部门的前端改革节奏，将项目逐个迁移到前端工程平台。同时通过定制一些 webpack plugin 来保留部分存量不规范的代码，保证增量页面增量代码是符合最佳实践的，这样我们的开发体验就会逐渐好转。 2) 排查问题难 我的团队所负责的业务前端有个特点，就是页面分散、访问量大、问题反馈也多，甚至有些 H5 页面在业务核心流程中。线上问题反馈通常只有一句话描述，好一点儿的带个截图，问题处理群大多会先拉客户端和前端同学。甚至不夸张的说，有些奇葩的问题需要加用户微信后单线联系用户协助排查。 我刚入职时，我的老大就安排我参与前端监控的建设，我主要负责写捕获日志的 SDK。正好排查问题是我们团队的刚需，就从这儿切入，把我们组所有 H5 项目都做了接入，也提炼出了一些监控上报的最佳实践。同时总结出一些常见的排障方法和经验，在组内做了一些培训，组内有位同学还写了一个快速查日志的工具命令，最终我的团队基本全员都具备了日志排查能力，部分同学能够结合前端和后端日志一起分析问题。 直面挑战：两个里程碑好景不长，我转正后没两个月，上面就传达了一个巨大任务，技术中心要做好一条全新业务线的产品 MVP，说是公司已经定好开城日期了，线下已经多少钱砸下去了。幸运的是我团队里有一位老员工被“钦点”为 C 端前端 owner，也因此有了更大的挑战，当前连产品需求文档都没有，距离老板定的开城日期只剩 45 天。 这种活儿肯定会越做越多，而且在开城日之前还会有一些模块需要提前上线预热。我当时做了个决定，把原本团队里小组1的6个人分出3个人去支持新业务，其中有一位就是 C 端前端 owner，要负责安卓端、iOS端和微信小程序三个端的用户核心流程，他再带个人跟着他一起干。最后再留一个人，我和他一起支持需要提前上线的功能和页面。 以下是我那一年在公司 gitlab 的记录，5月到7月是最令人崩溃的三个月，坦诚来说这是我工作至今压力最大的三个月。 同时期也是公司产研快速扩张的阶段，一方面新业务的研发资源很匮乏，基本每个周末都在加班，必须优先为新业务招人。另一方面原有业务也在提出新的项目，原来被我拆分的小组也需要继续补人。我曾经两个月面试了 62 个候选人，最多的一周 5 天面了 11 人。 这一轮爆肝后，完成了两个里程碑 新业务顺利开城，零延期，零故障，业务数据也远超预期。 在招人时我有意侧重 Vue、React 双技术栈的候选人，借助增量项目增量页面，团队完成技术转型。 第一年总结：建立信任第一年过得很快，总结下来就是四个字“建立信任”。从团队的问题出发，让大家相信并看到一点点的进步，逐步完成转型；把挑战视为锻炼团队的机会，和大家一起冲锋陷阵，克服挑战也是相互信任的结果。 第二年：务实结合务虚，打造团队房子争取前端话语权，提升团队 Owner 意识第一年接管团队刚开始从每个人的诉求出发，制定出了后来推进的事情。第二年我又回到了人身上，我们推行的事情最终不仅仅是完成事情，更重要的是通过事情让人的能力得到提升，这样说得功利一点才能够升职加薪。或者换种说法，人成就事情，事情成就人。 在公司大前端部成立之前，前端同学在技术方案上很少有话语权，基本就是产品说做成什么样就做成什么样，后端同学说接口怎么样就是怎么样。有了第一年的技术储备后，我们是时候去改变这个局面了。我在团队里提出了一个口号“做靠谱的工程师，与业务共同成长”。这里我在工程师前面刻意抹去了“前端”，意思是不要把自己局限在前端，要以工程师的角度去思考和解决问题。同时不要想着脱离业务的技术能够高大上，技术必须结合业务、服务于业务，人、技术、与业务共同成长。 这个口号的具体落地，就是让前端同学担任需求的技术 Owner，职责是开发前牵头整理需求的技术方案，开发中推进上下游问题的解决，开发后与各端研发拉齐发布方案。刚开始我们以为如果涉及后端、客户端工作量的需求，前端同学无法胜任技术 Owner，确实术业有专攻。但经过一年时间后，团队里有一半同学都有能力做好需求的技术 Owner，部分同学甚至对复杂需求也能游刃有余。当然，做这个角色要比普通参与需求交付花费更多的精力，我们也会挑选那些后端逻辑不是很重的需求来让前端作为技术 Owner，在涉及前端的产品需求中我们前端担任 Owner 的次数占比可达 15% ~ 20%。 这个事情除了数字上的体现，我认为更重要的意义是让大家明显感觉到了前端和以前不一样了，前端同学会对产品交互提出自己的观点，会关注需求在业务层面的逻辑，也会和后端同学 battle 某个接口设计是否合理。只要前端有一定工作量或有一定历史包袱，我们在开发动手前都会整理前端技术方案，无论前端是否作为 Owner。名义上的 Owner 变得不再重要，而是我们是否像 Owner 一样做事。 成果不够轮子来凑，既要又要还要这一年里我们团队技术产出最丰富的一年，当然就如前面所说，这些技术产出都是结合业务服务于业务的。 1) 提效工具 提效方面的小工具可能是大部分开发同学最喜欢造的轮子，我在团队内坚持了一个方向，小轮子可以造，但必须要收敛在一起。之前有同学尝试做了一个 Chrome 插件，用来开发联调阶段的账号登录，我们可以在此插件上继续丰富，涵盖开发、联调、测试、线上各阶段经常遇到的因为没有工具而显得低效的事情。 开发阶段：各项目入口；接口文档转 TypeScript 定义；产品埋点搜索（埋点代码 -&gt; 集中搜索 -&gt; 跳转埋点平台） 联调/测试：一键登录；过期 token 自动刷新；编译后 ESNext 提醒（项目用到的依赖里可能存在 esnext 代码，造成用户低端机上直接全屏 线上排障：case 反馈一键查询；前后端日志关联（从前端日志关联到后端日志，方便全链路排查） 以上这些小工具都不是同一个人做的，而是以功能为单元，谁想到了 idea 就由谁负责实现，由好几个小伙伴共同贡献的。 2) 体验优化 在体验优化方面也体现出了团队合力的作用。首先是对前端性能的度量，组里有同学对此很感兴趣，帮助我们调研并实现了 FCP / LCP 指标的采集，补全了前端监控 SDK 在性能方面的指标。接下来，基于页面渲染的指标，组内开展了各种项目性能优化，优化手段也多样化。 纯粹构建时的优化（分包、按需），能提升 FCP，但对 LCP 可能不敏感。 大图片优化（优先 webp），优化接口调用时机（减少阻塞），可以明显提升 LCP。 对于有固定入口的页面，可以上离线包，是提升 FCP 和 LCP 的必杀技。我们改造了多个项目后的经验数据为 FCP 平均提升 60%，LCP 平均提升 40%。 组内还有同学尝试了不一样的渲染方式，可以使用 SSG (Static Site Generation) 构建时渲染，虽然项目是 SPA 单页应用，但仍然可以在构建阶段将落地页的 DOM 内容直接输出到 HTML 中，特别适合于有落地页的场景。 从构建时渲染的思路继续延伸，对于动态内容的页面，我们可以使用骨架屏代替真正的 DOM 内容直接输出到 HTML 中，我理解骨架屏也是一种构建时渲染。如何生成一个页面的骨架屏，也有同学把它做到了上面提到的 Chrome 插件里。 3) 前端稳定性 我从入职到现在一直负责着前端监控 SDK 的维护工作，这一年更多结合实际业务场景做查漏补缺。 对于大范围问题：站在业务开发视角，对架构组输出的前端监控指标进行补充和共建，比如说指标里区分接口 host、区分来源页面，以及前端关键操作的成功率事件上报，这些都是在业务侧十分需要的监控指标。 对于个例问题：除了时间、地点、人的信息，还有其他信息也可以帮助我们排查业务反馈的 case，比如客户端信息、接口返回内容等，也把用于前后端日志关联的全链路 traceID 在我们组的前端项目中最先应用。 我们团队也是最先在前端项目中用上了告警能力，借助公司 CI (核心基础设施) 部门提供的监控平台能力，以及前端监控服务输出的前端指标，我们沉淀出了“前端告警 -&gt; 监控面板 -&gt; 查日志”的完整排障方法。 第二年总结：收获与遗憾至此，在团队小伙伴们的共同努力下，我们建成了团队的房子图，在做好业务的前提下追求体验和效率，而稳定性是公司技术的底线，九层之台，起于累土。 当然，这一年也有很多遗憾。比如上面图中关于效率有一条“关注联调时间”，是指我当时强调了“联调、debug 投入的时间占比”不超过 25%，事实证明没有任何作用，既浪费大家时间统计工时，又没有达成这个 25% 的指标，本身一个人一天的工作时间就不可能只做一件事。 还有，由于前一年公司产研扩张速度太快，这一年有不少人员流失，其中不免有可惜离职的同学。此外，我所提倡的“前端 Owner 意识”可能让部分同学感到太卷，最终在绩效考核时很难客观量化，造成部分同学过程很辛苦、但与结果略有落差。以上这些都是我管理上的失误，在下一年要特别注意。 第三年：充分授权，用数据抓过程设立实线小组，用数据来管理过程刚接管团队时有10+人，扩张后最多时有25+人（包括外包同学），经过一些缩减和人员流失后，我的老大把另一个5人小组合并到了我团队，保持了接近20人的团队规模。当然，合并了新的小组也意味着又多了一条业务要支持，目前我们团队共支持了三大不同的业务，对接来自4个二级部门的后端。因此，我也在团队内划分了4个小组，每个小组人数都差不多，并且让小组长都作为实线管理为小组成员的绩效负责。 这一年我主要跟进4位小组长，通过他们来推进各事项的落地。这一年我开始重视过程数据了，过程也要想办法量化，哪怕结果不如预期，通过过程数据也能做出客观评价，并从数据中发现新的问题。 典型例子是关于“开发质量”，由于前一年我过于关注“联调、debug 投入的时间占比”没有任何作用，我的出发点是提高开发效率，bug 越早发现，修复 bug 的代价则越小。因此我开始抓开发质量，用小组“人均 bug 数”的指标来衡量，目标是平均每个人每个月不超过4个 bug（测试阶段提的 bug）。乍一看这个指标很反人类，特别是与测试同学的部分指标完全反着来。 但事实上，我们基本做到了 bug 数收敛。特别是有一个5人小组，在上半年有人一个月能写出10多个甚至20来个 bug，下半年人均 bug 数减少了一半，小组整体也达成了我定的目标。我想表达的是，开发质量是一个过程指标，开发质量的提升反映出团队成员在需求理解、方案设计、沟通协作、自我要求各方面的综合提升，我们使用的办法只是提倡动手前先梳理技术方案、提测前先保证自测检查，这同样是“做靠谱的工程师”的延续。 重视问题复盘，用机制来保证执行这一年出过很多线上问题，也有影响面非常大的问题上升到了公司高层。痛定思痛，我必须重视每一次问题复盘，让团队在问题中得到成长。关于复盘，首先要定一个复盘文档的模板，如下。 12345678910111213141516171819202122232425262728293031321. 问题描述XXXXXXXXXXXXXXX影响范围- 影响时段- 收到反馈人数- 实际影响人数2. 处理过程- 时间线3. 事件原因- 直接原因- 根本原因（如有）4. 解决方案- 临时方案（如有）- 最终方案5. 问题关注点- 关注点1：为什么会发生 / 没发现 / 难复现- 关注点2：为什么很久才暴露问题- 关注点3：下次如果再发生，能更快处理吗6. 改进措施（切忌说空话，喊口号，无法保证执行的事项） 可以看到，我们对于前端引起的问题也严抓数据，影响面要能量化，这并不是对“出锅”同学的惩罚，而是让锻炼他分析问题影响面的能力，需要一定的日志排查和数据统计/估算，也让他更对线上问题更加敬畏。 其次，我们对问题原因有更多剖析，进而可以做出更加成熟的改进措施，改进措施也要具体、可执行、可验收。比如说“Code Review 要更仔细”就是一句空话，而“Code Review 中增加 XXX 检查点（甚至融入 git 工作流里）”则是具体的改进。 最后，对近期一段时间累计的线上问题做集中回顾，发现其中的共性，共性原因的改进措施能否融入每一个人的日常工作流里。我从组里十几例线上问题中发现有一半是因为需求理解不到位、改动范围未同步给测试同学，还有少部分是未做好兼容引起的问题。因此我推动了在前端技术方案模板中增加对常见兼容方案的 Checklist、以及对改动范围的明确列出（包括页面和公共组件），也在技术方案中提前考虑可能发生的线上问题和应急措施。 最近有发生一例问题早在一个多月前就有人反馈了，当时我们也安排了同学去排查，但因为只此一例没有足够重视，一个月后反馈突然增多。因此，我开始要求各小组长用在线表格记录日常收到的各类问题反馈，既可以追踪问题跟进人的排查进展，也可以对问题进行归类以发现潜在的优化空间，每周 review 表格避免问题扩大，这也是用机制来保证执行。 前端稳定性从规范化到精细化上面写的两条大多通过小组长来落地，这一年我剩余的个人精力主要在前端稳定性。一方面因为年初团队里出了很大的“锅”上升到了公司高层，另一方面我始终参与着架构组的前端监控建设，是时候站在大前端部门的角度来看稳定性这件事了。 1) 规范化：来源于业务，落地到业务 仍然从问题出发，究竟哪些前端页面出问题后会引发舆情和严重后果，按影响程度梳理出了部门所有前端项目中的 P0 和 P1 核心页面，并按业务线和页面维度将前端监控各指标汇总在一个监控面板中。基于前端核心页面，逐步建立起前端稳定性的流程规范。 发布前：前端研发全流程规范，其中前端技术方案模从我们组内推到了部门其他前端团队内。 发布中：前端生产变更规范，其中借助核心页面的稳定性保障，在部门内拉齐了H5页面灰度放量的操作 SOP。 发布后：对于监控工具更重要的是什么情况下应该用什么工具，针对大面积问题、个例反馈问题、非稳定复现问题这三类问题的排障思路。 除此之外，基于实际业务排查过程中的痛点，提炼与稳定性相关的辅助工具，比如灰度放量中的项目分版本监控、基于告警消息的异常日志统计面板。这些都是既来源于业务，又落地到业务。 2) 精细化：主链路监控，未雨绸缪 如今我们所做的产品越来越复杂，小程序已占据了C端的半壁江山，主链路监控不全是后端的事，前端也需要在主链路上做更精细的监控。 典型例子就是微信小程序中的“手机号授权”功能，从2023年9月开始按调用次数收费，同时2023年下半年微信平台也前所未有地加大了对小程序用户隐私和数据规范的执行和判罚力度。这也带来了新的稳定性风险，原本“白嫖”的“手机号授权”功能，现在既可能欠费，又可能被微信封禁。更要命的是，“手机号授权”功能一旦不可用，前端根本不会请求到业务后端，在微信授权阶段就直接返回失败了，这也体现前端监控的必要性了，是对全局服务监控的一种有效补充。在前端根据微信授权 API 的回调结果，上报成功率事件到我们的前端监控，可以获得比接口调用量更加精确的监控指标，并为之设置较为敏感的告警阈值，因为它会直接影响用户的登录和注册。 在过去的几个月里，我们多次通过前端告警发现了微信小程序“手机号授权”功能因业务场景违规被微信封禁的情况，并借此推动部门各小程序做好对微信登录违规的技术预案。对业务来说微信也属于第三方依赖，第三方依赖必须可监控、可降级。当我们组负责的小程序第二次被微信封禁“手机号授权”功能时，做到了5分钟内告警发现，10分钟内完成应急快恢！完全不亚于核心后端服务的应急响应能力，这是我在两年前根本不敢想象的。 第三年总结：开始真正管理回顾过去三年，第一年主要在建立信任，通过一同战斗、团队技术转型来建立起双向的信任。第二年先描绘团队愿景，把愿景具象为团队的房子和基石，并做出实打实的事情。那么第三年则是开始真正管理，通过组织架构上的管理授权，靠过程数据和流程机制来作为管理抓手。 第三年的团队产出并没有第二年那么丰富，但我认为这也是里程碑式的一年，我的团队做事风格从广度开始转向深度。程序员越往后发展是靠深度，也体会到管理越往后是靠流程。 我理解的技术管理：利他曾经的我喜欢看讲成功学的畅销书，但最后只有一本书的一句话深深留在我心里，它就是《稻盛和夫的人生哲学》里反复出现的一句话「作为人，何谓正确」。稻盛和夫这位经营之神，他是材料研发出身，后来创业自己经营，带出了两家世界级的企业，这句话是他早期指导自己做决策的理念。这句话让我很震撼，大道至简，哪怕没有任何经验，从人之本性出发，根据普世的价值观来做判断，也一样能带好团队。 我刚开始也是借用「作为人，何谓正确」，把自己带入事情的当事人，去想应该怎么做。我们公司内部也有很多管理培训的资源，建团队、定目标、追过程、拿结果每一块都能展开成一门课程，都有具体的做事方法。方法可能非常多，能掌握和用到的很有限，但我猜测所有方法的最顶层都是某一个或几个理念，理念的数量不会太多。就像管理大师德鲁克的名言「管理是激发人的善意」，背后也是利他精神。 虽然我作为实线管理团队有三年，但是在第三年才开始真正做管理的事情。我当前对技术管理工作的理解也是“利他”，这里的“他”泛指我的上级、下属、以及合作伙伴的团队。 对上级：要了解上级面临什么样的挑战，发生什么样的问题连我的上级也兜不住，我当前面对的事情如果站在我上级的视角他会怎么看。 对下属：了解下属对工作和生活上的期望，不要让无谓的“卷”成为主流，而是做真正对他职业发展有利的事情，哪怕不能升职加薪，跳槽也能有更强的竞争力。如果遇到只想躺平的下属，那就通过流程约束适当提高要求，只要保证不掉队，不被末位淘汰。 对合作伙伴：了解合作方的主要目标，对问题有同理心，在守住自己原则底线的前提下尽可能为他人想办法。当然这不是一味的舍己为人，而是有原则讲道理，维持互帮互助的关系。 最后，己所不欲勿施于人，想对他人提更高要求，首先自己要做到自律。Keep moving!]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的成长基石]]></title>
    <url>%2Fblog%2F2020%2F11%2Fmy-stepping-stones.html</url>
    <content type="text"><![CDATA[回顾自己四年多的工作经历，成长很多，真的问心无愧，不算白来。成长一定是痛苦的，必须要主动跳出舒适区，最后自己收获的就是所谓的基石。 去年在去年的述职答辩中，最后有一块个人展望，当时的我画了这样一幅图。 我的自我认知还算比较清晰，知道自己的长短。当时希望自己能够以固定产线为圆心，发展出产品认知、业务理解、数据意识，并提高沟通能力，这样围绕圆心就画出一个圆了。 在去年之前我一直属于单干型的，所以也希望自己能够从个人逐渐发展到团队，通过 2~3 人的小分队来锻炼自己的规划能力，个人和团队一起成长，最终能够在业务项目中发掘出技术的附加价值。 今日从去年的图到现在，快一年半了，那些希望达到的基本都达到了，除了顶部的“赋能”还谈不上真正的赋能，但也确实能用技术主动去做一些能解决业务问题的小事。 所以去年的金字塔有必要升级一下啦，给自己新阶段的新目标。 我把专业能力、做事能力、思考力作为我的成长三驾马车，而且我认为无论什么行业什么工种，这三种能力必备的职业素质。 专业是本，但我们目的是为了做事。事情能不能做成，技术固然重要，但更重要的是能不能用“心”，超越体力和脑力的是心力。 这三大能力将是我未来三年的目标，为了不忘初心，我又加了一条“态度决定能力”作为精神基石。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务前端为什么要理解业务]]></title>
    <url>%2Fblog%2F2020%2F10%2Fbusiness-understanding.html</url>
    <content type="text"><![CDATA[看了上一篇转载的「前端为什么要理解业务」后，结合自己所负责的业务线，越来越觉得业务理解的重要性，而且很多时候应该前置于技术。业务前端为什么要理解业务，我决定也写一点自己的看法。 1、业务现状：指标、数据是什么。 比如末端转单在蜂鸟、微信、支付宝各端的单量是个什么样的比例，这是我们需求撕B的基础，也决定技术改造的优先级。 2、业务方KPI：需要业务方同步 KPI 具体数字，以及对应的时间节点。 这是我之前一直忽略的，现在吃了亏。人都有私心，做的事情就是为了完成某个KPI，这是可以理解的。但我们研发侧也需要提前知道业务方的KPI，做好必要的技术准备。就怕业务KPI的时间点快到了，于是就倒排期施压产研，我们信息不对称，该准备的没提前准备，就很容易吃亏。 3、产品需求中的业务背景：业务背景必须要有说服力，该要有数字的就要他们给数字，背景OK后，再过产品方案。 这里容易忽略的就是业务预期，对产生的价值要能够量化，业务预期要给出具体数字。为了达到预期业务侧有没有什么配套的运营动作，上线后达不到预期就应该业务复盘。 4、前面说的都是“为什么要做”，接下来就是“为什么要现在做”。 这也是容易吃亏的地方，需求永远做不完，产品永远迭代不完，研发不是做这个就是做那个。但是，是不是必须要现在做，有没有更值得做的事，业务上到底有没有想清楚，有没有准备好，否则就是对产研的不负责。 最后，我们都说技术上避免重复造轮子，业务上也不应该重复造轮子，用灵魂拷问技术轮子一样去拷问业务轮子吧。更重要的一点是，技术人员理解业务可以让我们做事更有成就感，也更容易在业务中去发掘技术给业务创造出的附加价值。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(转载)前端为什么要理解业务]]></title>
    <url>%2Fblog%2F2020%2F10%2Fbeyond-frontend.html</url>
    <content type="text"><![CDATA[作为一个业务前端，完成业务需求的同时，还要处理各种线上问题，加班辛苦忙碌了一年，还要被老板说“思考是不够的”、“没有业务 sence”，出去面试，被问项目，也说不出什么有亮点或者有挑战的东西，想做点牛逼的东西，也没有发现什么有价值的方向，好不容易找到一些方向，还要被老板一顿质问，业务价值是什么？ROI 怎样？最终可能就只是做了一点性能优化工作，抽离了一些可复用的组件……不禁让人感叹，业务难、前端难、做业务的前端更难！ 如果你也有这样的感受和困境，我想告诉你，这真的是太正常了，在阿里内部的技术论坛就有多篇关于这个问题的思考，我根据根据自己理解和调研，同时参考了多位不同前端领域专家的总结，整理成这篇文章，希望能对大家有所帮助。 👇 本文为转载 作者：阿里巴巴淘系技术 原文链接：https://www.zhihu.com/question/309488771/answer/1312341416 业务前端的困境▐ 业务前端“好忙”业务前端，顾名思义，做业务的前端，直接与业务的 PD、运营接触，对产品的用户直接负责。在实际的工作中，业务前端经常忙于业务的各种会议、项目和答疑，即便一条业务线上有多个前端同学支持，面对成山的需求，可能依然感到吃力，这其中的原因可能有： 用户侧产品往往需要快速上线，大部分需求都需要倒排工期，开发时间尤其紧张 对业务不熟悉，在项目需求已确定的时候才去参加视觉评审，没有办法判断需求背后的业务逻辑跟业务大节奏是否匹配、需求本身是否能够达成业务目标、有没有更好的实现方式，只能接下需求，然后排期 维护成本高，每天还要忙于解决各种线上问题，比如这里样式有点问题，那里怎么没有显示……各种琐碎问题让你过的非常“充实” 需求响应速度较慢，比如业务的技术栈较老，或者定制逻辑过多，边写代码还要边查文档，查不到可能还要查源码，效率大幅降低。又或者跟别的业务技术体系不同，难以复用和沉淀，如果要用，可能还要重写一遍…… ▐ 业务前端是“资源”?前端岗位的特点就是有视觉稿就可以完成工作，不需要理解业务全貌，所以在繁忙期很容易让前端忽视了业务思考，加上之前描述的各种原因，业务前端经常沦落为“资源”，当你沦落为“资源”的时候，其实就已经失去了和业务平等对话的资格，他们只会把你当成莫得感情的开发机器，跟你输入需求，让你吐出页面，而你在这样的关系中，本来写着还算工整的代码，为了快速实现业务需求，也开始写起乱糟糟的代码，对于你所创造的产品也没有话语权，久而久之也失去了激情和耐心。 失去激情，写的不开心也就算了，因为你没有做出什么特别的东西，老板也不会特别认可你的辛苦，还会觉得你思考不够、没有业务 sence，对业务没有助力，没有让业务因为你的存在而有所不同…… ▐ 业务前端想突破好吧，那我决定做点什么改变一下，于是跟老板提出了一系列想法： 这里技术体系太老了，为了进一步提升开发效率，我们想要搞技术重构 前后端联调有点费劲，我们想搞个联调数据中台，提升联调效率 那里展现速度太慢了，我们要搞性能优化 …… 老板往往会来一系列灵魂提问： 为什么要做？（有什么业务价值？有什么技术价值？） 为什么是现在做？ 为什么是你做？ ROI（投入产出比）怎么样？ 还没有开始，躁动的心就被老板的一系列“质疑”浇了一盆冷水。 如果没有回答好这些问题、说服老板，自然也争取不到什么资源，只能一个人搞搞，一个人搞的往往质量不行、也没有人用，久而久之自己也不维护了，只能又开始埋头在需求中。 干的不开心，也没有成长，最后只能暗淡离职，但换了一个公司就会好吗，很可能又是类似的过程…… 这真的堪称是业务前端的“困境”，那么如何突破这种困境呢？首先我们就要摆正心态，从了解业务开始。 了解业务▐ 业务和需求在了解业务之前，首先我们要知道，业务跟需求是不一样的。理解需求并不等于理解业务，需求是业务经过产品消化后的产物，可能已经经过演绎或者拆解，因此需求并不是业务本身，当然了解的需求越多，对业务的全貌也会更加了解。 那么什么是业务呢？业界对”业务”有多种定义，但是其主要思想基本不变，业务就是一系列人通过一系列活动完成某一任务的过程，因此，业务可大可小，可以无限拆分。 我们本文涉及的业务泛指商业业务，就是与该 BU 或者公司商业模式直接关联的业务或其组成部分。 ▐ 前端为什么要学习业务前端即使不学习业务，其实也不影响做需求，毕竟你只要告诉我交互是什么样的，前端就可以帮你实现，而且已经有产品经理的角色了，大家各司其职不就好了，为什么一个做技术的，要狗拿耗子、或者是越俎代庖呢？这就要说到： 只有了解业务，才能从技术的角度想到业务方不曾想到的地方；不了解业务，你可能听不懂业务方要什么，甚至连需求的业务逻辑都搞不清，这种情况的合作模式只有一种，需求下来了，你接住，然后给排期。也许，这个需求的设计不合理，你不知道；这个需求有更好的实现方案，你不知道；这个需求可以通过现成的关联产品方案解决，省时省人力，你也不知道。 只有了解到业务背后的原因，才能从全局的视角去规划技术的未来。不了解业务，会让你离用户的真实需求很远，你越难发现其中的一些痛点和挑战，没法真正提出你的思考和解决方案，去解决用户的难题。 作为一名产品研发工程师，自然是希望亲手打磨一款解决用户问题、体验友好的产品，如果产品能得到用户认可，产生影响力、自然会特别有成就感。 阿里作为一家商业科技公司，对技术人的要求就是技术与业务相结合，在满足业务需求的基础上，成为技术与业务的桥梁，主动走进业务，思考如何通过技术手段帮助业务做赢、满足市场和用户需求，先一步技术规划、人才储备、技术架构和技术预研。 ▐ 你了解业务吗？那么目前你了解你对接的业务吗？不妨尝试回答下以下问题： 业务做的是什么？产品大图有吗？ 业务的核心指标是什么？KPI目标是什么，这些数字背后的含义是什么？要达成这些目标，业务策略是什么？ 业务的用户是谁？流量怎么分层？占比多少？分别在业务中是怎样的定位？ 业务的商业模式？靠什么吸引流量，盈利模式是怎样的？ 我们做的页面是什么东西？为业务带来什么价值？要创造更多的价值，我们可以做什么？ ▐ 如何学习业务?业务领域知识的阅读 找到该领域相关的评分较好的书籍集中阅读，快速形成知识框架。 了解业务背景和规划 刚刚接手新的业务，可以邀请业务方老板或者资深的运营/产品同学，给你讲讲这块业务的过去、现在、未来、愿景、财年规划，以及对技术同学的期望； 花时间读合作方（运营、产品、研发）的周报，了解现在在发生什么，是不是离目标越来越近了； 了解业务目标、落地策略、衡量目标的数据口径，关注数据，关注目前做的项目是否为了达成目标而战，如果不是，提出你的想法和建议； 多参会，建立产品 sense。收集信息最好的方式就是参加所处业务老大的 KO 会，各种 KO 会会把战略上的拆解和背后的思考整体梳理之后宣讲传达给 BU 或部门的同学， 多交流 与服务端同学聊天，与 PM 聊天，与用户聊天，多角度看业务，但要注意的是，针对专业型比较强的业务，需要先做功课，至少一些英文的缩写要清楚的明白意思。 谨记数字 如果前面还需要花比较长的时间，那这一个可以现在就做起来，那就是把业务相关的数字记得越精细约好，越具体越好，越全面越多越好。这样做有两个好处： 所记的数字指标本身，很大程度已经涵盖了这个业务价值方向，你便知道了这个业务重点关注的是哪个维度的东西 这些数字可以作为和业务方以及产品“平等对话”的源头，否则连最基本的对话基础都没有 从日常需求入手 对于项目中的需求，我们要尝试分析背后的目的和价值，做了之后有什么预期的收益，为什么这么做就可以达到这个收益，跟总体目标是否契合，还要判断业务方提到的点是不是有效的方案或者说成本太大的方案，看能不能给出替代方案，用现有的方案或者小成本的方式来满足业务方。 而在项目提测上线后，还要仔细分析以及多关注上线之后的业务数据和效果，会有如下好处： 提高自己对业务的理解能力，你在关注业务数据的同时，也就会更多的从业务的角度来看到这个功能所带来的价值是否符合预期，当出现不符合预期的时候，可以和业务方一起进行数据漏斗的分析从而找到问题所在，避免我们的劳动成果成为一次性的工作。 总结的同时可以帮助自己梳理这个项目中自己哪些地方做的不足，或者相关推进中存在什么问题，以及后面怎么改进，提高了下次项目中的迭代效率和质量。比如这个项目是否存在需求理解不到位存在返工，或者沟通 &amp; 联调低效，环境不稳定，自己设计的方案是否合理等问题，后续要怎么解决。 也可以从数据和总结中判断出什么样的需求是靠谱的 &amp; 什么的样业务方是靠谱的，频繁争取资源上线效果又不好的业务方，下次再有需求过来则需要多增加一个心眼和思考的过程。 坚持 业务思考力，没有个至少半年是不会见效的 助力业务▐ 思考尽管平时的业务很忙，但再忙，也要抽时间思考，那么思考哪些内容呢？以下举一些例子： 养成每天记工作内容的习惯，分析一下自己的时间到底耗在哪了 在业务开发中，有遇到让你特别想吐槽的点吗？想下问题背后的原因，有什么方法可以避免下次不犯，能不能提炼为更加通用的解决方案，其他同学怎么解决的，我可以怎么解决？ 不断地输入、观察，业务的真实需求是什么？站在业务方的角度思考，业务遇到的痛点、挑战在哪里？ ▐ 沟通和老板、团队同学、业务方对焦，确认“我想做的”是不是“大家想要的”？ 你可能会提出很多意见，但一般会遭到老板或者业务方无情的拒绝，而且问得你一脸懵逼，就比如： 当前业务背景下，为什么要做？（有什么业务价值？有什么技术价值？） 现在必须做么？ 为什么是你做？ 怎么做？（体系化、全链路、单点技术挑战） 有什么业务和技术结果？能否被复用？ 未来规划（能否跟BU或集团的方案联动、共建） 而这往往是因为你提出要做的事情，有价值但不是必须做的，没有结合目前业务需要什么。也就是说，你想做的技术是个人和纯技术角度思考的，没有基于业务的现状和痛点去考虑技术方案，不接地气，投入产出比不高。 所以给技术产出先找好业务的阵地，看看有没有可以借力的地方，不要重复造轮子。快速验证这个方向的正确性后，再逐渐多加投入、丰满技术设计。不要自己YY、默默地做完，这样做出来的东西没有业务场景埋单。 ▐ 技术规划业务赋能其实是需要我们紧贴业务规划，制定技术规划和方案。在了解业务方今年的 KPI 重点是什么，预计的拆解和实现路径是什么后，再结合自己的和团队情况，想想自己能做哪些事情来帮助业务实现其 KPI，这里有两点需要注意下： 抓住本质从点及面，通盘考虑: 很多时候，我们收到的痛点和业务需求都是单点的，这时我们不能着眼于眼前的单点问题，而需要通盘来考虑，比如SEO的页面对性能非常敏感，经常可能会收到一些业务方来反馈，说目前我们的SEO有这个地方，那个地方需要优化下，而单点解决这些问题可能对业务带来的收益并不大，对自己的技能也没有什么成长。这时候如果通盘考虑这个命题，其实会发现做SEO页面的优化，其实目的是为了提升SEO页面的收录和排名。而提升SEO页面的收录和排名其实不仅有前端性能优化这一个路径，而是还有一些其他的路径：比如优化关键词&amp;长尾词，采用Google的AMP技术改造SEO页面，优化爬虫爬取页面的耗时提升爬取率等等。这样就能吧点的问题转化为面的问题，才能制定更有效和全面的抓手来赋能业务。 既要解决眼前痛点，也要长远谋划: 很多时候我们不能仅满足于眼前的KPI，还需要了解业务方长远的想法和可以预见的规划。就比如试点的新业务，一层规划是保证业务项目的按时上线，考虑到未来，另一层规划可能就是如何做到技术方案的可以复制性。 ▐ 站在巨人的肩膀上当你需要制定一个产品化的方案或者工具和框架的时候，最好先放眼集团内部和行业进行一番调研，看看业界和其他同事是怎么解决这个问题的。尽量站在别人的肩膀上做出创新或者参与共建，避免小团队内造出重复和质量低的轮子 技术深度▐ 技术知识与技术能力“技术”不能是一个笼统的词汇，我想它至少可以分为“技术知识”和“技术能力”两大部分。 什么是“技术知识”？知识就是 I KNOW 《TypeScript 从入门到放弃》 《React 从入门到放弃》 《Webpack 从入门到放弃》 …… 什么是“技术能力”？能力就是 I CAN 我用 TypeScript 重构了一个大型系统，代码健壮性及研发效率大幅提升。 我用 React Hooks 给全栈同学进行前端培训，培训效果大幅提升。 我深入研究了 Webpack，优化配置，使得系统构建速度大幅提升。 ….. ▐ 培养技术视野 关注日常业界新技术。不一定要深入了解，但对新技术保持好奇心，大概了解它是做什么的，如果在工作中遇到匹配的落地环境，可以考虑写个 demo 看看是不是有价值 关注集团和业界的解决方案。在业务中发现问题，做解决方案的时候，我们很容易陷入自己的设计中，一脑子地想把所有东西都自己做出来，但投入会非常大，产出的价值是否一样大呢？不知道。大部分情况下，你想做的，在ATA能搜到，前人踩的坑，或者已有的成熟的解决方案，只要你去沟通去接触，就可以轻松地接进来，为什么要花大量的时间去造轮子呢？可以借力的地方，就去借力吧，把时间剩下来，做你的解决方案中更核心更有价值的事情。 ▐ 技术深度一聊到“技术深度”，可能很自然地会认为是在某项技术上挖得很深，或者解决了一个业界公认难度很高的技术难题，但这只是“技术深度”的其中一部分： 体系化 / 系统化体系化思维是认识事物的一种方式，在面对问题的时候，能够针对复杂的问题，列出关键的要素和解决方法，将散乱无序的问题，变得逻辑清晰，有章可循。在问题的定位和解决的体现，从表象到本质，拆解出造成问题背后的原因，针对性地去解决本质的原因，而非治标不治本，有解决方案有节奏地解决。 全链路除了前端的部分，向前向后的技术栈，还能挖多深。 单点技术挑战在某个技术挑战上，你的思考和解决方案是怎样的。 ▐ 技术与业务共赢真正有突破性的、带来重大价值的业务成果必然伴随着技术上的深入乃至创新，所以在做业务成果的时候，一定会有让我们增加技术深度的场景。 👇 本文为转载 作者：阿里巴巴淘系技术 原文链接：https://www.zhihu.com/question/309488771/answer/1312341416]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「雷军十周年演讲」摘录]]></title>
    <url>%2Fblog%2F2020%2F08%2Fleijun-ten-years-anniversary.html</url>
    <content type="text"><![CDATA[这周印象最深的是雷军十周年演讲，以前还吐槽小米搞F码饥饿营销，到后来自己用了小米卧槽真的好用。从学校宿舍到踏上工作，看着小米敲响了钟声。 以下是从演讲中摘取的一些点，觉得很有意义 先定一个目标，比如做最好的XXX，然后想怎么让它听起来不靠谱但可以试一试。寻找切入点，少即是多。 如果找不到人，是因为没有花足够的时间找人。 互联网方法中最最重要的：专注、极致、口碑、快。 珍惜种子用户，滚雪球最核心的力量。 所谓的成功背后，是一个个艰难的抉择，每一个选择背后，都是巨大的风险。 创新可以决定企业有多大的想象力，但是质量决定了你能不能活下去。 危机，是危也是机。 不懂没关系，先总结，然后再补课，再提高。 优秀的公司赚取利润，伟大的公司赢得人心。(和“不挣钱，交个朋友”差不多) 看过其他产品的成长之路，成功的方式总是惊人相似，而失败的原因却各有不同。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[后端 write once，前端 write anywhere]]></title>
    <url>%2Fblog%2F2020%2F07%2Fwrite-once-write-anywhere.html</url>
    <content type="text"><![CDATA[这个观点虽然有些极端，但我想表达为什么每个团队都缺前端，理想的前后端人员配比应该是多少？当然会看业务形态，但事实上有很多公司后端都在写页面，把前端资源集中到最需要他们的地方。 为什么我会觉得前端 write anywhere 呢？ 抛开多端投放的场景，一个接口的复用，比一个页面或组件的复用要容易得多。一个接口可能只要加几个字段，加一种鉴权方式，就能在多个场景中使用。而多个场景的前端交互往往不同，取决于用户的角色和 User Story。 前端复用大多停留在基础组件或补充的扩展组件上，而再往上一层的复用往往很难，更多不是因为抽象得不够好，更多考虑在风险上。多个场景共用同一份代码，复杂度并不会降低，复杂度只是被封到了一个地方，而一个地方挂了，多个场景都会出问题就很可怕了。所以场景类的复用还是源码或低代码的方式稳妥，这就注定了前端无法 write once。 另一方面，前端离用户最近，品牌感和交互效率是一个产品需要关心的，而这些升级和后端几乎没关系，接口设计合理、具备事务性，那同一份接口又可以应对前端的大改版。为什么要改版，最终还是为了业务目标的达成，人都喜欢长得漂亮的。 那后端会站出来说“我们需要花更多时间在性能和稳定性上”，那我站队下前端，我们也需要性能优化，也需要监控和稳定性，破车开不动时也需要换新车。这些事情前端不是不需要做，而是什么时候做，ROI、优先级的问题。 最后，本文仅代表个人不成熟的感想，没有要和后端分出伯仲的意思，做好一个产品离不开每一个人。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发迭代的 good practice]]></title>
    <url>%2Fblog%2F2020%2F06%2Fteam-practice.html</url>
    <content type="text"><![CDATA[在上家公司所在的团队是前端、后端、测试、app同学都在一起的业务团队，团队中大部分研发流程与我们都类似，有些不一样的实践对我们也有参考意义。 1、新人串讲新人加入项目后，需要做个 presentation，对项目整体做个介绍，听众就是项目组的其他同学。这个形式挺好，让新人上手项目更有目的性，对听众来说也是一种回顾，串讲完后会对新人提问和QA。 这个串讲形式不仅适用于新人，老人接手新项目时也一样会组织串讲。 2、详设评审前公司的研发流程一月一迭代，在上一迭代的最后1周评审，然后留出1周用来做详细设计，主要是技术上的设计，并且组织详设评审。这个好处不用多说，降低开发风险，测试时也有依据。 3、迭代 master刚说了一月一迭代，一个完整迭代流程为：需求评审 - 排期 - 详设 - 开发 - 测试 - 发布 - 总结。每个迭代都有一位 master，由项目组同学轮流，不分新人老人。master 要负责组织所有的会议，以及每天的晨会。 master 自己也一样要写代码，虽然这些琐事会占据不少时间，但一年只会轮到一两次，是个不错的培养 ownership 和沟通的机会。 4、迭代总结前公司里一个迭代里的所有需求都集中发布，这个不太好，但是会多一个迭代总结的环节，是迭代 master 组织的最后一次会。 会议分3部分：1）测试同学汇报 bug 度量数据，各需求 bug 分布，以及每个人的千行代码 bug 数。2）迭代最后的发布问题复盘。3）本次迭代做得好与不好的地方，每个人轮流发言。 参考意义现公司的前端组织架构上大多是职能团队，1个人要横跨多个业务团队，有些环节实践起来有所取舍，比如大需求也会有详设文档，默认后端充当 master，我们也有业务复盘。前公司在这方面做得还是很不错的，文档化与全员参与，所有的实践都是在强调这几个词：意识、表达、反思。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨BU申请流程的套路]]></title>
    <url>%2Fblog%2F2020%2F06%2Fnegotiate-practice.html</url>
    <content type="text"><![CDATA[这周终于把支付宝 OCR 的接口权限申请下来了，回顾这个过程，流程还挺重，跨度10多天，好在都搞定了，也发现一些套路。 1、集团侧的人，不管是研发还是PD，都特别喜欢问 why and why not，所以我们事先一定要能解释出产品背景与所申请内容的前因后果关系。 2、找到一个相关人后，就开始拉群聊，一个流程可能会涉及好几方的人，都在群里聊。聊不动就 Ding，也让我们这边相关的前后端和产品同学反复询问反复 push。 3、如果对方给了 Plan B，多从我们这边的角度考虑 A 与 B 的利弊，选最利于自己的方案。也向对方解释清楚诉求，表达我们是愿意接入 B 的，但由于目前啥啥啥情况，Plan A 更怎样怎样，看对方还有没有商量的空间。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术问题的思考方法]]></title>
    <url>%2Fblog%2F2020%2F06%2Fmy-actions-to-think.html</url>
    <content type="text"><![CDATA[这周对物料中心“主题编辑里怎么去编辑业务组件里的自定义变量”做了很多思考，想清楚了，而且也体会到了 fusion 主题包为什么要那样设计。这里只是借这个过程，和大家交流下我的思考方法，不是书上的方法，只是我自己的具体做法，确实能想清楚问题。 1、问题拆解式就是把一个大问题拆成若干个小问题，小问题里还能拆就继续拆。这个过程有点像语文作文里的「总-分-分-总」，怎么去拆解去思考呢，我觉得脑图是非常适合做这个过程的。 虽然上图画的不是问题拆解，但也类似的，最后对每个叶节点的问题去一一回答。 用这个图也为了表达，脑图也非常适合做不同方案之间的对比✅ 2、一问一答式就是自问自答，一问一答，继续问继续答。有点像做数学证明题，推理式「因为…所以…又…所以…」 如果问题回答不了，可以继续引出个子问题，先来回答。 3、连环拷问式和上面有点类似，但问题不急着回答，先假设问题都能回答，打破砂锅问到底。 好处是不用过早纠结实现细节，先把所有可能的问题都想到，看看问题大不大。其实也是拆解问题，不是并列的问题，是一环扣一环的问题。 我的方法思考过程因人而异，拆解问题，演绎或归纳。写这么多废话，想和大家分享可以帮助思考问题的具体做法，一个是脑图，另一个是“=&gt; =&gt; =&gt;”这种过程记录。我觉得是可以得出自己的答案的，而且以后忘了还可以翻记录。。。 书上写的看过邱昭良的《如何系统思考》，思考是为了能化繁为简，系统思考需要注重以下3点。 1、动态思考：从线性思考走向环形思考，就是要看到事物的因果关系链，还要看到时间轴的影响。 2、深入思考：不仅专注于个别事件，还要洞悉系统行为变化的动态，分析并认识到驱动系统行为变化的潜在结构。也是就是通过现象看本质。 3、全面思考：从本位思考到大局观，清楚全局的最终目标以及本位在全局中所处的位置。 总的来说，系统思考要看到时间和空间，时间上要有长期性，空间上要全面。 书上也推荐了一些其他工具来辅助我们思考，比如鱼骨图、思考罗盘、因果回路图。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[没有完美的架构]]></title>
    <url>%2Fblog%2F2020%2F05%2Fno-perfect-architecture.html</url>
    <content type="text"><![CDATA[赞同一个观点：没有完美的架构，只有平衡的架构，没有单点的完美，只有多点的平衡。 在做物料平台的过程中，开始感受到上面的观点了。 物料的最最最下游，就是组件。怎么开发一个组件，在 nodejs 兴起之前，早就有人在做了。nodejs 促进了前端工程化的兴起，到现在，开发一个组件的过程，都快赶上 Hello World 一样简单了。 从组件出发，往上游追溯，前端玩的花样很多了。这并不是一个严格的分层结构，铺开的话更像一个星状结构，内部紧密联系着，所以肯定有槽点吧。 再看到内部，每个模块都或多或少存在些问题和槽点，你不管是用 cli 还是用 def 这样的一体化平台，你总是会发现不爽之处的。所以就是，能用就行，我们追求的不是单点的完美，而是多点的平衡，让各块能够一起运作以完成一个更大的目标。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂度守恒]]></title>
    <url>%2Fblog%2F2020%2F05%2Fconservation-of-complexity.html</url>
    <content type="text"><![CDATA[一哥的分享里一直有提到“复杂度守恒”，这个观点离我们越来越近了。有时候我们总以为自己多么能撕，减少了多少工作量，其实复杂度未必减少，只是它们转移到别的地方去了。这就是复杂度守恒，给我们的启示是看问题看得链路更长一点，长到开发之外，到业务、到人。 既然复杂度转移了，那到底应该在哪里去处理它们呢？一哥给出的回答是，把复杂逻辑放在最适合的地方做，总成本才是最低的。很多时候由于进度和成本原因，我们以“能用就行”做了一些临时处理方案，我们会发现一年前自己在代码里顺手写的 TODO 依然在那里。一哥早年有篇文章叫「金山银山 绿水青山」，讲垃圾治理与代码治理，给我们的启示是看问题要看得更长远些，不能只用进度来衡量。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[交付时间≠开发时间]]></title>
    <url>%2Fblog%2F2020%2F05%2Fdelivery-time-not-worktime.html</url>
    <content type="text"><![CDATA[为什么人会觉得累，为什么别人总觉得缺前端？我逐渐感受到：我们排期给出的时间，就是承诺的交付时间，并不是开发需要的时间。因为你很可能估不出真正的开发时间。 原因在于几乎所有公司里前后端人数比肯定1比N，接手的需求数和产线数前后端是否平衡，这会影响到并行任务数。虽然我们在排期时需求看起来并没有并行，但实际操作中，联调、测试、验收等环节并不会因为前端开发完了就不会找你了。所以如果前端说排满了，那就已经有并行了，再加上月末多产线的评审，频繁切换思维空间，又给已有的并行任务再加一层。 所以我觉得在这种情况下，排期排不了开发时间，只在于承诺交付。有点理解为啥 aone 的任务，不关心开始时间，只在乎截止时间。 在上家公司里，是一个包含了产品、设计、前后端的业务团队，所有需求都会集中评完，上线也是月末一起上，对研发友好的是切换代价小。再往前回想在学校里做的创业项目，更简单粗暴，一个前端，一个后端，面对面坐着开发，只有活儿多，并没有切换和沟通代价，反而从早到晚也不会觉得累。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[做前端有点焦虑]]></title>
    <url>%2Fblog%2F2020%2F04%2Frecent-anxiety.html</url>
    <content type="text"><![CDATA[粽叔在大群里分享了他的成长路线，做前端 =&gt; 做技术 =&gt; 做事，再一次给我敲响了警钟。回想自己来饿了么面试时，粽叔问前端之外还想做点什么（大概这意思），当时懵逼了，表达自己在学校里做过一些爬虫和监控的项目。。。然而入坑以来，自己并没有未雨绸缪去储备过一些东西。 大学里的铁哥们，15年去的蚂蚁，前年和他碰面时得知已经 p7 了，据他说我们那届还有几个同学也是3年升7。今天无意搜了下他，嗯，现在是蚂蚁财富核心交易里的 TL 了。前后端的职级本来就不能一同比较，但可以分享下他的故事。 当时校招秋招他也没拿到蚂蚁 offer，先签了大众点评去实习了，到了第二年春，蚂蚁那边告诉他有空位，然后他毁了点评去蚂蚁了，也是起步价的 offer。他回到学校赶紧做完了毕设，提前两个月去蚂蚁实习了，我当时还笑他，不如等到毕业后以正式员工入职啊。 蚂蚁主张全栈，所以他什么都做，哪里缺人去哪里，第一年基本都在项目室小黑屋里度过。第二年蚂蚁又出了个全员 3.25 的事情，之后还有一年里他换了4个老板。他和我说过，有一年的国假基本都在加班，半夜手机一震动就起来就怕是报警。就是因为财富这个东西，里面都是真金白银，没人敢接，他们大老板接了下来。 后来，他也遇到过一些不平等待遇，忍了下来，现在恭喜他当上了 TL。 已经拖同学后腿了，之前也看过好多大佬都提到，工作的前5年非常重要。跟同学一比，值得好好规划自己了。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[需求撕X技巧]]></title>
    <url>%2Fblog%2F2020%2F02%2Fbargain-skills-on-prd.html</url>
    <content type="text"><![CDATA[这周撕了3个需求，分享下我的套路，总的来说「把大需求聊小，把小需求聊没」。 1、先做主要功能，次要功能拆到二期。 上线一周后，主动跟进 PV/UV 和接口请求量，没达到业务预期效果的话，让他们复盘，拒绝二期、三期。 案例：1月提了H5版的运单详情需求，先砍掉页面里“骑手轨迹”功能（开发复杂，但又不影响运单的主要信息）。 反击：上线一周，发现接口请求量只有 100 来次/天，顺理成章就砍掉了“骑手轨迹”。 2、需求上线后不久，又提出新概念。 新概念可能会增加理解负担或降低现有功能的使用率，要主动拒绝这类“拍脑袋”的需求。建议产品不要一直做加法，应该利用好现有的功能。 案例：在去年底做了运营规则台的大重构，年前才上线。一个月后，运营同学觉得不好用，产品又提出了“规则组”的概念。 反击：为什么重构的时候不想想清楚？识别需求方真正诉求的场景，原来他只是想创建规则时少填一些相同的字段。于是换一种简单实现，通过“复制规则”以及“批量创建”的功能去满足他。 3、提出的需求反复在解决相同的问题 先让需求方拿出数据，他说的“不好用”到底是技术原因还是没运营好？先让他们用非技术手段去尝试解决，拒绝“口说无凭”的需求。 案例：在去年11月做了天气审核权限的下放，并规划在了一个大项目里。现在提需求说要移动化办公，做到APP里。 反击：为什么一开始不做成移动版，为什么现有PC版使用率不高就能说明移动版使用率就高了？如果需求方觉得是因为“没电脑不方便”，那让他们先强推下“用手机访问网页”的方式去验证。利用现有能力让业务先行，把运营手段和流程完善后，再来提需求。 4、需求方案不佳，存在一定临时性。 同样让业务方同学先给数据，目前是什么情况，做这个方案后预计会怎样？竞品是怎么做的？是否可以什么都不做，通过现有/第三方工具同样实现业务诉求。 把大需求聊小，把小需求聊没，关键我们要给出建议，才能让他们妥协。在需求预评审时，把业务方同学叫上，挺有必要的。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务前端如何赋能业务]]></title>
    <url>%2Fblog%2F2020%2F02%2Fhow-to-empower-biz.html</url>
    <content type="text"><![CDATA[为什么后端接口可以按业务流程来组织，很容易实现业务上的复用，优先加字段加标识，不行再开新接口。而前端受制于宿主平台，PC &lt;=&gt; H5 光靠响应式布局可能无法满足（信息组织不可用），另外 App 上用 native 实现的页面也难以复用到 web（受制于技术栈的实现） 所以，前端在业务上怎么去复用呢？看上去似乎「搭建」是条路，但怎么保证不会陷入不停开发模块或堆砌字段呢？ 身为业务前端，却赋能不了业务，是否感到有点慌？ 1、对现有能力的信息掌握 2、对业务关键指标的知晓 3、抛开技术层面去理解目标 4、为手头的活儿赋予重大意义]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中后台背景下的前端出路]]></title>
    <url>%2Fblog%2F2020%2F01%2Ffrontend-for-middle.html</url>
    <content type="text"><![CDATA[看到一个「中台」的定义，偏向服务，但有3个值得关注的点：封装，面向业务场景，快速。 结合前端领域我们遇到的问题，分别谈一谈。 封装 要解决标准化的问题，这是做封装的前置条件，不可能今后无止尽得满足各方需求，必须先在某个层次达成标准化的共识。面对今后的“众口难调”，在不同业务侧二次包装，尽量用「组合」而非「继承」。 面向业务场景 中后台领域的前端也应该是面向业务场景的，比如工单的提交，订单的处理进度，骑手配送的轨迹，应该是能够给别人接入的。再比如运单详情，不同角色的人可能关注不同的信息，所以像运单详情应该是可以支持子模块的组装的。 在这方面，我们目前都是按业务前端的方式，可以考虑转换到中后台的视角。 快速 「需求多、业务快」这是我们行业的标配，那对于中后台的前端，我觉得关注点在于效率和一致性。 效率：包括交互的效率，开发的效率，于是会考虑借助搭建平台的能力，而搭建的前置条件仍然是封装和标准化。 一致性：不能让用户感觉身处不同的系统，这是交互的诉求。也就要求我们既要有标准化，还要有换皮肤的能力，同一个系统里保持一致性，不同系统保留皮肤的差异。 如果借助搭建的话，为了效率和一致性，我们「封装」和「面向业务场景」的产物，既要能以普通源码方式使用，又要能适配接入到搭建平台。 最后回头再看一眼前面中台的定义，“xxxxx 的平台”，同样前端也要背靠平台作为后盾，选择靠谱的平台十分重要，前面的这些模块产物也需要有平台收口管理。 综上出现最多的词是“标准化”。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019给我的3个认知]]></title>
    <url>%2Fblog%2F2019%2F12%2Fthe-end-of-2019.html</url>
    <content type="text"><![CDATA[2019可以说是给我成长最多的一年，挑选印象最深的3点认知说一下。 1、尊重他人立场，不轻易放弃自己立场 工作和生活中不免与很多人打交道，每个人都有自己的立场，每个人的立场都是站在对自己有利的一面。当然也有些立场是共赢的，让别人爽了后也会慢慢对自己有利。尊重别人立场的同时也多存疑下，不是纯粹挑战别人，而是为了彼此的信息对称，确保他人是深思熟虑后的立场，不要轻易放弃自己的立场。 2、家庭的力量比任何团队都强大 家就像一个创业团队，白手起家，不断迭代「生活」这个产品。所谓中年危机就是面临工作和生活无法平衡，工作和家庭之间的矛盾，“上有老、下有小”更会突出这种矛盾。但不可小视家庭的力量，我认为它比任何团队都强大，分工明确、互相信任、及时补位、拥抱变化，克服“创业”之路上的种种困难。2019让我明白了：Family First 3、全情付出，愿等花开 这8个字摘自玉伯的分享，不管是学习/工作/生活，做事时全情付出总没有错，不要太纠结利益，愿等花开，不同于“坐等花开”。 最后引用乔帮主的名言 You can’t connect the dots looking forward, you can only connect them looking backwards. Believing that the dots will connet down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path, and that will make all the difference. 2020 一切会更好！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要折腾技术栈]]></title>
    <url>%2Fblog%2F2019%2F12%2Fwhy-to-try-differents.html</url>
    <content type="text"><![CDATA[在刚入职那会儿，这边都是 Angular 1.x 和 Vue 1.x，然后全部迁移到 Vue 2.x，再然后 Element 1.x 到 2.x，再到 React First，除了技术本身的新旧更替外，我觉得还有以下3个价值。 1、从个人角度，多尝试点技术栈 可以体会到不同技术的特点，感受到技术的进步以及它所解决的问题。技术本身没有好坏，现在外面小公司还有很多 jQuery 一把梭的，不同技术间的比较是为了找到最适合当前问题的技术。 可以减少工作的无聊，用 Vue 做增删改查已经写了2年了，再写下去经常就是 Ctrl+C+V 的操作，套接口、对字段，可以说是原地踏步。 提升个人能力，了解不同技术栈有助于今后造轮子时产生更多想法，设计能力更强。当然以后工作机会也更多。 2、从团队角度 技术储备，可以应对今后跨部门项目或项目交接时的技术风险。 提前布局，在“政治正确”的方向上应对未来的风险，避免类似后端 python / go 转 java 的被动。 鼓励探索，想法碰撞，激发潜能，有助于提升团队整体实力。 3、从公司角度 如果要鼓励探索，那必先经历技术栈和轮子的百花齐放。一段时间后，优胜劣汰，为了降低成本，又会开始技术收敛和统一。 「分久必合、合久必分」同样映射到大厂的技术圈，技术收敛后一段时间内是统一的，但会随着业务或技术本身的迭代渐渐又出现分歧，此时原本收敛的技术会进一步抽象，把其核心底层能力给抽出去，基于这个可复用的能力来做分歧。 总的来说，公司对技术的期望是：1）快速支持业务，拿下业务价值；2）降低研发成本，包括不限于人力和硬件。 折腾的过程肯定不会一马平川，原本已经熟悉到不需要看文档就能盲打了，又得重新拾起文档一个个坑踩过来。但我听说过，集团中后台给运营小二使用的页面，绝不会投入专业前端同学，前端是稀有资源，那他们是怎么做到的呢？这里面肯定有我们不知道的玩法。 举个 uform 的例子，这类表单的轮子在集团能找出十几二十个，但我惊奇的是 uform 经历了3年且活了下来，还作为了集团前端“开箱即用”方向的表单标准（基于 uform 的底层来实现一套统一的 schema）。而我有幸参与的 tapas 项目，撑了1年半，感觉快死了，这里面就能看出 uform 有很多值得我们学习的地方。 所以说，虽然目前 fusion、uform、iceworks 会有一些坑，但我觉得有理由相信它们会越来越好！]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[天猫回忆录]]></title>
    <url>%2Fblog%2F2019%2F11%2Finternship-recollection.html</url>
    <content type="text"><![CDATA[看到篇文章「从P4到P9，在马云家写代码到双11前端PM」，是舒文自己写的十年阿里经历，让我想起了在天猫实习的日子，记忆深刻，不自觉地就写成了下面的回忆录。 我有幸在2015年有一段短暂的天猫实习经历，在那时知道了@舒文，对他有两个印象：1是开敞篷跑车的骚年，2是斑马系统负责人。那一年的斑马初出茅庐，第一次在618年中大促中较大规模使用，而我当时所在的天猫超市业务，也是斑马的第一批忠实用户。 业务背景介绍下当时的背景，天猫超市有十几个品类（休闲零食 、酒水饮料都算不同品类），并且天猫超市在全国有5个站（华东、华南、华北、华中、西南），每个站的促销商品是不一样的。业务每个月都要搞促销活动，每次会涉及几个品类，并且还要和站点挂钩，2个品类5个站点的话算下来就要10个活动页面。 技术背景在斑马之前，这类活动页面要么找外包开发，但质量堪忧，尤其是移动端的适配做的很差。另一条路是用淘系的TMS系统来搭建，前端同学开发TMS页面Solution和区块，区块中预留好由运营填写的数据坑位，最后前端开发完的代码必须跟着后端项目一起发布，这套流程中前后端还没分离。TMS是古董级的系统，但也帮助运营和前端完成了活动页面的快速开发。 2015年舒文开始推动天猫各垂直业务线用斑马来建设营销活动，并且舒文团队提供基础通用模块的开发。当时天猫UI已经 Mobile First 了，每个斑马模块要求提供 Mobile 和 PC 两个版本，而在斑马的搭建界面上，运营只需要搭建一次就可同时生成 PC 和 H5 两个页面。 我觉得斑马模块设计的最精巧的是：一个模块（也可以叫组件），既能用于搭建，又能用于普通项目中；在普通源码中使用时，既能用于同步渲染（由 node server 直出），又能异步渲染（在 js 中作为函数调用生成DOM）。现在看来可能觉得没什么，但那时模块和大部分项目都用 Kissy 开发的（和 jQuery 差不多），模板解析的库是自研的，服务端渲染引擎也是自研。那时 npm 还没有 package-lock 文件，天猫的同学就自研了 seed 文件记录每个依赖的版本，并开发了本地开发的 CLI 工具。直到现在，斑马文档中还能看到 wormhole、tap server、xtemplate 这些名字。 团队背景我实习是在天猫垂直行业的前端团队，里面分为很多小组去支持不同业务线，天猫国际、电器城、汽车、母婴等。当时天猫超市的前端，只有2个正式员工，加我1个实习生，我5月入职正好赶上618大促。需求方面，除了营销活动外，还有超市主站的一些功能迭代。 618 推斑马就是这样的背景下，mentor 带着我们上战场，为了推斑马，他让运营活动的需求不经过产品直接提给他，这样能联合斑马团队有更多发挥空间。618主会场和通用的头尾组件都是由斑马团队开发的，而天猫超市特有的玩法和商品坑位由我们开发。 印象最深的一个例子，斑马团队开发了图片热区模块，允许运营上传个性化的页面图片，在斑马上把图切分成各个区域配上不同的跳转链接。而 mentor 引导我基于此，开发了一个允许直接加购物车的超市版图片热区。运营直接把购物车按钮做在图片里，在斑马上配下对应的商品ID即可，这样很多十分个性化的活动页面都可以用图片来做了。 运营侧的操作是，由运营同学负责定商品定价格玩法，而斑马上的活动页面都由外包来配置，最后再由运营审核。618预热、大促、返场活动，总共有几百个页面。有一阵子 mentor 带着我坐到了运营边上办公，能快速响应他们的问题。事后超市那年的业务KPI超额完成了，业务方发邮件表扬了我们和斑马，舒文还请我们吃了饭。 后来的斑马由于集团政策和个人原因，短暂实习后我就返校了，没有经历那年双11。看到舒文的文章里写到，斑马于2015年初才立项，经历618的小考后，又参加了双11大考，取得了全面成功，节省了巨额外包预算。再后来，舒文团队从斑马里抽象出了天马，提供搭建的底层能力，又基于天马做了方舟系统，面向营销链路的会场解决方案。 今年看了集团前端大会的直播，舒文仍然负责搭建方向，看到有人评论说舒文这两年白头发又多了。 最后，感谢舒文让我知道了斑马，感谢 mentor 由校的耐心指导，感谢 leader 铁军的心路引导，祝他们越来越好🙏]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书「小狗钱钱」]]></title>
    <url>%2Fblog%2F2019%2F10%2Fa-dog-named-money.html</url>
    <content type="text"><![CDATA[这是本教儿童理财思想的启蒙书，作为成人也很有借鉴意义。摘录了书中一些值得反思的句子。 1、机会到处都是，但是只有在你寻找它的时候，你才能看见它。 2、当你朝着积极的目标去思考的时候，就不会心生畏惧。 3、越是把注意力放在疼痛上，就越会觉得疼。 4、为别人解决一个难题，那么你就能赚到许多钱。 5、你干的活最多只值报酬的一半，另一半报酬源于你的想法和实施这个想法的勇气。 6、如果说运气是充分准备加上努力工作的结果，那我准备得越充分，工作得越努力，运气也就越好。 7、一个人挣钱的多少是和他的自信心联系在一起的。另外，他的精力是集中在自己的能力范围之内，还是放到了他力所不能及的事情上？ 8、最珍贵的礼物是我们自己争取来的。生命中出现了最美好的东西，是因为我做了原本不敢做的事。 9、决定一件东西价值多少的唯一因素就是，你愿意为它支付多少钱。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书「向上管理」]]></title>
    <url>%2Fblog%2F2019%2F10%2Fbottom-up-management.html</url>
    <content type="text"><![CDATA[汇报工作只占了一个员工全部工作的20%，但却决定了他80%的工作效率和工作成果。以前对这类人情世故不以为意，认为都是溜须拍马，看了「向上管理：如何正确汇报工作」后，收获颇丰。在工作中遇到的问题，往往在技术层面都有办法，难就难在人上。第一次阅读这类职场书，摘录了书中的目录和要点。 正确认识上下级关系认识你的公司一、明确企业的组织架构 了解一家企业的组织架构，可以让你了解这家企业运营的核心，这个核心同时也是你工作的核心和指向。 清楚企业组织能力的来源、模仿组织能力的行为、加强组织能力的训练，成为造就组织能力的一部分。 二、认识企业的团队组成 团队是由少数技能互补，愿意为了共同的目的、业绩目标和工作方法而相互承担责任的人组成的群体。 人：团队中的人是团队的核心要素。 技能互补：团队需要你成为什么样的人，你就应该成为什么样的人。 共同的目标：目标的存在能够为团队成员导航，解决“我们要去哪里”的问题。 协同工作：应该团队要通过成员的分工和协作来工作。 承担责任：承担责任是对团队内部成员的要求。 一个高效的团队具备以下特征：诚信透明，积极主动，互相帮助，善于自省，彼此尊重，互相分享，持之以恒，彼此倾听。 三、洞察企业的故事和文化 融入一家公司最快速的方式不是融入工作，而是了解这家公司的故事、融入它的文化。 多看，观察企业的行为模式；多听，倾听其他人说话的方式；多做事，少说话。 最好不要抱怨，有话最好咽下去；说话之前先想一想，说者无意、听者有心。 四、了解企业最终是为了正确的自我定位 自我定位决定你未来的成长和成功 能力弱用态度补，态度弱用能力补，性格差用态度补 认识你的上司一、上司不是你选的，而是组织选的 上司强，你就跟着干 上司弱，你就当“枪手” 主动和上司性格互补 二、了解上司的处境 了解上司的难题 帮助上司解决他的难题 三、是你适应上司，不是上司适应你 适应上司的沟通方式：沟通方式，沟通频率、沟通时间 适应上司的工作风格 不要低估你的上司 永远不要让上司感到意外，除非意外惊喜 当工作事态显示出不好的趋势时，首先要汇报给上司，千万不要压着。 四、解析上司的人格特型 (D) Dominance 支配型：行动力强，以结果为导向 你需要：服从和尊重，直截了当，随时让他掌握状况，拿出结果，能够处理他照顾不到的细节，通过时间获取信任 多谈谈 What (I) Influence 影响型：性格温和乐观，以人为主 你需要：尊重和认同，能够充分思考，把工作计划贯彻到底，能够自我管理 多谈谈 Who (S) Steadiness 稳健型：以程序为主，做事严谨精细 你需要：有勇气改变现状，灵活的工作方式，愿意替他冲锋陷阵 多谈谈 How (C) Compliance 支持型：以服从规则为主，乐于支持他人 你需要：能够团队协作，给出明确的规则，给出数据供决策 多谈谈 Why 五、认识上司的5种角色 上级领导 管理者是战术的实施者，给出的是方法 领导者是战略的制定者，给出的是方向 下属的人生导师 教你做事的上司 教你做人的上司 组织资源的支配者 物质资源：物质、人力、嘉奖、晋升 精神资源：信任。组织中最难获得的资源就是信任 权利的使用者 弄清权利在谁的手中，责任在谁身上，利益由谁获得 你未来的资源和朋友 六、了解上次对你的真正期望 在达到上司对你期望的同时稍稍超出他的期望 观察并询问上司的工作标准，以及对你的工作标准 建立和谐的上下级关系###与上司合作共赢的五大原则 一、敬业原则：你是否还能做得更好 如何你很敬业，那就请建立起个人口碑，口碑就是你的招牌。 二、服从原则：上司的信任从你服从的那一刻开始 执行第一，聪明第二；服从第一，承受第二 三、请示原则：任何时候都不要剥夺上司决策的权力 请求上级给予工作上的指示；请求批准方案的请示；请求批转对接的请示 千万不要帮上司做决定 四、互赖原则：优势互补实现 1+1&gt;2 职场成长3个阶段：依赖；独立；互赖 互赖阶段最容易犯的错误就是自以为翅膀硬了可以丢开上司了 互赖最终走向的是团结，互相信任 五、功劳原则：认识职场中的功劳 你的功劳就是上司的功劳 上司的功劳永远是上司的功劳 得到上司的肯定就是自己的功劳 能得到组织的肯定是上司的功劳 先把功劳让给上司，得到上司的肯定，然后上司开始把功劳归于你 总结：把上司当成你最重要的大客户 做好自己的工作：工作五位法一、定位：定位就是找到你在组织中的位置；定位是你对自己的评估和了解；定位告诉你该做什么、不该做什么。 二、到位：把工作做到上司满意或者超出他的预期；“到位”就是管理上司对你的预期，从细节开始管理上司对你的期望。 三、补位：哪里需要你，你就在哪里，学会在团队中做“补位者”。 四、站位：你站在一个位置上，就要做好那个岗位的事情，就要做好领导派给你的工作。 五、换位：学会站在他人的角度思考问题，换位思考非常重要。 总结：本质是让上司放心，放心之后才能有之后的信任，有了信任才能交心。 获得上司信任的五个关键一、“恭”无不克：用汇报的方式尊重上司 二、“能”者多劳：永远比别人“多”一点 三、术有专攻：把你的专业发挥出来，去引导上级 四、忠贞不二：忠诚就是你的个人标签 五、沟通第一：用沟通认识上司，了解他 总结：坚守原则和底线，获取信任 如何正确汇报工作你应该如何汇报工作一、建立机制：形成有效的工作汇报机制，把汇报工作变成条件反色，一定要养成的工作习惯。 二、理清思路：理清汇报思路 一次汇报的重点应该只有一个，并且应该能用一两句话来表达清楚 三、突出重点：分清轻重缓急再汇报，重点事情持续汇报。 强调紧急的 强调重要的 强调和上司利益关系密切的 强调上司关心的 四、简明扼要：学会用三句话总结你要说的内容，语言简洁，说到重点，语句条理清晰。 三点逻辑 精髓在于总结与归类：三种方法、三个方面、三个时间 学会用“一、二、三点”来说话、汇报和思考 要汇报好处、收益、价值，不要汇报无关紧要的细节 要汇报结果，不要刻意汇报过程 按时间逻辑迅速整理思路：过去、现在、未来，按这3个时间来汇报工作 五、数字说话：数字比简单陈述概况更有说服力，用数据说话，让汇报更理性。 六、洗耳恭听：倾听是技术也是艺术，听清楚上级对本次汇报的总结和指示。 我们打断别人的话，通常有3种原因 我们认为自己了解对方要说的要点了 我们认为对方说得不对，急于反驳对方说的话 我们认同对方说的话，但是我们急于发表自己的意见 不管哪种原因，都应该先听对方说完，再做出反应 七：复述要点：对领导的汇报反馈中的难点、重点、疑问，复述确认后再回复。 检查双方的理解是否有偏差 补充遗漏的地方 沟通技巧 学会重复和总结，用“一、二、三”总结对方说的话 当对方表达自己的一个感觉时，你可以补充一个相关的事实。当对方陈述自己经历过的一个事实时，你可以将自己对这件事的感觉补充进去。 总结：把每一次汇报当成展示自己的机会 上司希望你如何汇报工作一、主动汇报：不要等他问了你才说 汇报工作不是工作的形式，汇报本身就是工作，是你职责的一部分。 二、准备充分：准备充分的材料、数据和备选方案 三、效率第一：用最短的时间说出重点内容 四、结论先行：先说出结论，再阐述内容；上级再追问，那再继续汇报。 五、中途汇报：重要的工作，中途持续不间断地汇报。 六、把握轻重：有异常的信息应该第一时间汇报，不能事后再汇报。 隐瞒不报坏消息的6个心理陷阱 这件事以前发生过，很好解决 上司说了没有重要事情不要麻烦他 我知道所有的事情 这件事我应该能解决 上司应该知道这件事情 我不用完整汇报。理解偏差：上司以为你汇报的是另一件事，你又以为上司已经知道了。 七、掌握分寸：不能自作主张，以为是一件合理的事情，而做决定，需要上级同意。 八、不要越权：汇报工作不能越过上级，上级的上级问后，汇报后也要告诉现任上级。 越级汇报是职场大忌 不该你去汇报，你主动出头了，为了向高层展示自己，期望得到赏识。这种想法本身就是错误的。应该通过自己的直属上司去汇报。 本身不想越级汇报，只是想紧急解决问题。 越级汇报的方式 可以汇报的内容，简单汇报 不确定是否可汇报的内容，请示完自己的上司后再汇报 越级汇报后要把汇报的情况再汇报给自己的上司 总结：带着方案来而不是带着问题来，且有备选答案。有了答案后再来请教上司对你答案的意见。 不知道选什么，往往只是因为不知道哪个更好 不知道哪个更好，往往是因为掌握的信息不够多 汇报中如何实现有效沟通一、完整的沟通包含3个内容：发送、接收和反馈 二、建立“沟通 - 反馈”的良性循环 三、支撑起沟通的5个支点 关系：有了关系，别人才愿意听你说话 多关心别人 不要过多要求别人 人事：把人和事分开，才能针对事件本身来沟通 可以有自己的想法，但不要过分主观化 拒绝要直截了当，并说明原因 情绪：梳理情绪，沟通才能顺畅进行 先解决情绪，再解决问题 不要跟情绪不好的人讲道理 认知：建立认知，从强化表达开始 多使用类比和事例 利益：有了利益，沟通才能达成共识 围绕价值进行沟通，从对方的角度来看价值 四、如何选择沟通的恰当时机 汇报要选择上司心情好的时候 申请决策要选择上司不忙的时候 不同沟通内容都有各自的最佳时机 道歉一定要在事发当天 履行承诺要早于承诺的最后期限 五、如何高效地做出工作总结 KPI：以业绩指标的方式进行业绩回顾 综合绩效：衡量业绩以外的其他贡献 为公司贡献了什么 为客户做了些什么 自己提升了多少？学习了什么？教给其他人什么？ 为改进公司的管理和流程上做了什么？ PDCA：做出明确的未来计划（用于做计划） (P) 目标：工作目标是什么？打算做成什么样？ (D) 执行：准备如何执行 (C) 检查：如何保证自己能够正确执行？如何保证执行力度？ (A) 改善：如果目标和执行之间出现偏差，该如何回到正确轨道？ 总结：把沟通当做促进了解的契机 是否了解上司的工作、目标、价值标准 是否了解上司对你的期望 是否了解上司的工作能力，长处和短板 是否了解上司目前工作的难题 是否了解上司对你的评价 如何通过汇报工作，实现真正的向上管理一、改变观点：管理不只是自上而下的 二、主导沟通：向上管理就是和上司最完美沟通 积极主动地沟通 沟通期望，分享彼此的期望 沟通风格，找出最适合双方合作的风格 沟通信赖，建立信任和依赖 沟通压力，了解彼此的处境 三、主动出牌：不要总等着你的上司先出牌 转换思维，开始用上司和组织的思维去做事 在需要上司采取措施的时候，提出明确要求 主动提供上司更多资讯 成为解决问题的那个人 追踪结果并进行汇报 提供反馈，并要求别人做出反馈 四、获得认同：让上司认同你设想的影响力法则 避免冲突，迂回地达成目的 说出你的想法和方案的价值所在 管理上司对你的印象 为上司创造有利的价值 五、协助提升：向上管理的最高境界是实现你和上司的共同提升 总结：你让上司卓有成就，他也会回报你成效 总结20%的事情决定了你向上管理80%的效果，20%的向上管理决定了80%的工作。 所有汇报工作，都要通过良好沟通去完成，没有良好表达能力与上级汇报，也会出现信息歪曲。本书中沟通强调5个支点：关系、人事、情绪、认知、利益。 每个管理者都应该把数据、事实、知识、判断、对策、指挥、直觉或经验，贡献给自己的上司。这种“向上的贡献意识”，可以使上司做出正确的决策，使上司的决策能够有效地支持自己的工作，至少不会给自己添麻烦。—— 《卓有成效的管理者》]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然学习方法]]></title>
    <url>%2Fblog%2F2019%2F10%2Fhow-to-learning.html</url>
    <content type="text"><![CDATA[自从用了微信读书后，就喜欢上了看书，利用通勤时间，多学习点知识。 其实知识的了解只是学习的一小步，转化为能力才是关键的一大步。如何才能让学习更有效果，真正做到能力的转化呢？ 什么是学习循环模型 这个学习循环模型源自教学设计理论「自然学习设计」，它非常符合成人学习的特点。自然学习设计理论认为，成人学习包含两个维度：感知信息和加工信息。感知信息则分为直接体验和抽象概念，加工信息则分为反思学习和行动学习两种。两个维度的两个方面相互结合就形成了一个上图中的2×2矩阵。 这个矩阵也正好诠释了成人学习的四个阶段：直接体验、反思、抽象概念和行动。这个循环被称为学习循环圈，从体验到反思阶段就要回答“Why”的问题，从反思到抽象概念就要回答“What”的问题，从抽象概念到行动之间就要回答“How”的问题，从行动再到体验就要回答“If”还有哪些拓展应用的问题。 一个完整的成人学习过程都要经过这样一个循环，所以只了解知识并不一定能变成能力，因为没有形成一个学习的闭环。 如何运用学习循环模型这个基于成人学习特点的循环模型，可以成为非常实用的结构化学习工具。 接触任何一个思考结构的时候，可以先从 Why，开始反思这一知识或思考结构对我来说是有价值的（发现意义） 接着通过 What，了解专家权威是如何看待这一知识的（形成概念） 然后再通过 How，明确我在生活中如何运用这一知识（解决问题） 最后通过 If，回答我如何依据新的情况调整所学知识（灵活转换） 这样完成的一个学习循环，不但掌握了知识、学会了应用，而且让知识变得融会贯通，真正达到学习的目的。 在其他场景下套用模型比如学习一个框架，上来先看 Tutorial 看到 Demo 直接体验，看值不值得学习。然后看具体的文档介绍，再考虑如何运用到自己的项目里，最后看一些建议需要注意哪些前提。 需求评审时也可以套用这个循环，先问需求背景 (Why)，再看具体需求细节 (What)，然后再考虑能否实现 (How)，最后再问下是不是非得这么做 (If)，做多少的问题。 参考资料 http://www.doc88.com/p-4582192510349.html https://www.001lunwen.com/kaoshiyushiti/168402.html]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书「结构思考力」]]></title>
    <url>%2Fblog%2F2019%2F10%2Fstructural-thinking.html</url>
    <content type="text"><![CDATA[「结构思考力」是本很棒的书，比「金字塔原理」精简，书中的案例更符合国内环境，可以学到做报告和沟通技巧。这里摘录了书中的目录和要点。 何为结构思考力结构思考力的作用一、个人必备的核心技能 开展工作的基础 专业岗位的要求 管理者必备的管理技能 助力职业发展 二、提升整个组织的效率 统一思考和表达的标准 提升组织的管理效率 三、提升全民素质 对传统应试教育的补充 什么是结构思考力一、强调“先总后分”的思考过程 二、金字塔结构是训练工具 三、横向与纵向相结合的立体化思维 明确理念打基础结构思考力的四个基本特点一、论：结论先行 国人拐弯抹角的说话方式 结论先行是自上而下的表达方式 二、证：以上统下 以上统下能保证表达的效果 有理由支撑的结论才有说服力 以上统下的特点符合实践要求 三、类：归类分组 分类使沟通更有效率（关于这个问题我有3点建议） 分类使思考更有效率（这个事情可以从以下几个方面考虑） 四、比：逻辑递进 结构化接收信息的三个步骤 识别信息中的事实、理由及结论 寻找哪些是观点 确认哪个观点是结论 找出支持结论的理由 中立地来看哪些是事实 找出对应关系画出结构图 一句话概括主题句 基于目标定主题确定目标 - 让表达有的放矢一、设定场景：提前设定表达场景 确认目标前先设定好场景 场景越具体，内容才能更准确 二、确定目标：目标是希望对方有哪些行为 设定主题 - 让表达观点明确一、确定结论：一个为目标服务的结论 二、包装主题：一个打动人心的主题 包装主题有三个基本原则：简单、准确、利益（从对方角度出发的利益） 借助选题矩阵选出最优主题 设计序言 - 让表达更吸引人一、初步设计：完善序言的基本要素 (S) 情景：要让对方产生共鸣 (C) 冲突：打破开场时给对方的安全感，确认面临的问题 (Q) 疑问：从对方角度会关心的问题 (A) 回答：基于这个问题给出的答案（解决方案） 二、优选完善：根据需求选择不同模式 标准式：情景 - 冲突 - 解决方案 开门见山：解决方案 - 情景 - 冲突 突出忧虑：冲突 - 情景 - 解决方案 突出信心：疑问 - 情景 - 冲突 - 解决方案 纵向结构分层次自上而下 - 疑问回答做分解一、疑问回答做分解的步骤 站在对方角度来看对方会关心什么。问题的答案就是你表达的一级标题，这些标题同样也要求是有中心思想的主题句，这样就会引发听众听到一级标题后的疑问，接下来再回答这些疑问构建二级标题。以此类推，直到你觉得已经解决对方所有的疑问。 二、设想问题，从对方角度出发的新模式 转变为以对方需求为中心的思维模式 通过 5W2H 确保问题被全面覆盖 5W：What、Why、Who、When、Where 2H：How、How much 掌握 2W1H 的简便方法 What、Why、How 三、回答问题，提前想好答案事半功倍 你的回答必须是结论 每个层级都需要是结论 回答时要根据客户关心的内容去组织 自下而上 - 概括总结做聚合一、自下而上的三个步骤 收集信息：将能够收集到的信息全部罗列出来。 分类：归类分组，确保同一组的思想属于同一个范畴。 概括总结：通过各个要点的观点，将每个分类概括出一个结论。以此类推，继续往上概括，直到金字塔结构的顶端为止，得出最终结论。 二、概括总结：杜绝没有中心思想的主题句 方法1：寻找共性，通过共同点概括结论 方法2：情景想象，面对面时你会跟对方说什么 方法3：善用修饰，提出抗议感动人心的结论 没有目标的报告就无从给出结论，因为没有目标，所以没有任何立场，没有立场的报告只能被称为数据统计报告。 上下结合 - 两种方式不可分首先，用自上而下疑问回答做分解的方式撘框架 设想问题，回答问题 其次，用自下而上概括总结做聚合的方式完善框架 信息收集，分类，总结概括 总的来说，我们思考任何问题都会经历这3个步骤 1、确定主题 2、基于主题进行发散，尽可能多的去想 3、把想过的东西聚合浓缩为一个有用的结果 横向结构选顺序演绎 - 让说服更有力一、标准式演绎：大前提，小前提，结论 二、常见式演绎：现象 (What)，原因 (Why)，解决方案 (How) 适用于问题解决、专项汇报、方案推荐等 注意区分现象和原因 现象、原因、解决方案要一一对应 归纳 - 让要点更清晰一、在三种子顺序中选择一种分类方式 归纳分类可以将隐性经验变为可复制、可传承的显性智慧 归纳中的三种分类方式 时间顺序：逐一进行 结构顺序：化整为零 重要性顺序：水平比较 每组思想选择一种分类方式 二、运用MECE来分类 养成MECE的习惯 MECE是结构思考力中的黄金法则 MECE让我们看待问题更加清晰全面 MECE原则可以让我们把握问题的关键 确认每组中的思想是否符合MECE原则 创建MECE的简便方法：2x2矩阵 任何事情和问题一定可以找出2个最核心的要素，每个要素又可以找出对应的两难困境 《困境中的决策力》一书中将这种两难困境归纳为8种类型 内与外 理智与情感 成本与收益 产品与市场 变化与稳定 了解与不了解 竞争的优先次序 内容与流程 把两个要素的两难困境相互结合，就可以画出分析问题的 2x2 矩阵，产生一个让我们全面审视问题的4个象限 运用现有结构进行思考分析 越是词汇丰富的人，越擅长用简单易懂的方式表达自己的感受 结构思考力越强的人，越能够在短时间内做出恰当的判断 事物的结构为我们的思考提供了捷径 考虑市场战略时的3C：Company、Customer、Competitor 市场决策方面的4P：Price、Product、Place (渠道)、Promotion (营销推广) 因需而动 - 演绎归纳选其一演绎：适用于需要说服对方时 归纳：适用于对方关注解决方案时 形象表达做演示卖点包装 - 让观点容易记一、类比 运用形象或行为类比的方式进行包装 比如：将产品售卖的三个方法，比喻为广撒网、钓大鱼、吃大餐 二、引用 引用广告、歌曲或名言的方式进行包装 三、整合 通过对色彩、词语、数字的整合进行包装 比如：快人1步，2个变化，3个特点 形象表达 - 让演示更有效一、构思时远离电脑 二、将完整的金字塔结构放到PPT中 三、每一页PPT都是一个金字塔结构 复合结构思考力的四个基本特点 论 - 结论先行：每一页PPT只表达一个观点 每页PPT的标题都需要是具有中心思想的主题句 简化你的文字内容，做到重点突出 证 - 以上统下：每页PPT的主题，都需要是下面要点的概括。 类 - 归类分组：每页PPT中的要点，要相互独立、完全穷尽。 比 - 逻辑递进：每页PPT中的要点必须按照一定的逻辑顺序进行组织。 运用图像进行形象好演示 可量化的数字可以转化为数据图表 不可量化的信息可以用概念图，比如相互关系、流程等 运用概念图让你的表述更直观 总结 本书从选目标定主题、纵向结构、横向结构，3个重点讲解了结构化的思考方法，并且这些方法也是通用能力，同样适用于处理日常工作和生活中的问题。总的来说，教会我们思考，理解他人更快更准，遇到问题学会分析，公开表达清晰有力。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间都去哪儿了]]></title>
    <url>%2Fblog%2F2019%2F09%2Fwhere-has-time-gone.html</url>
    <content type="text"><![CDATA[最近一个月感觉很明显，需求迭代明明都排足了时间来开发，然而最后都是赶工完成。原因是经常被一些事情打断，一天到了傍晚时候才开始真正做当天的需求。 分类 排期之外的琐事 排障类 1、产品/运营同学报的前端BUG2、接口报错，但要前端排查调了哪个接口 答疑类 3、后端问前端调了哪个接口，或前端校验逻辑4、回答框架使用问题 支持类 5、技术对接与文档约定6、配合联调（未识别到前端工作量的需求）7、框架维护，可能会在需求方提测前支持 feature 或 bugfix8、有些小CR需求没排期，看前端改动量很小，就友情支持给做了 沟通类 9、需求讨论（非评审，可能在评审前，也有在开发阶段讨论）10、接口定义不清，前后端二次沟通 对于这些事情，我似乎没什么原则，非要给优先级的话，肯定排障类是第一。其他事情基本都会及时处理，导致正常的需求开发被打断或推迟。我是这样想的，如果是我在找别人，我肯定希望对方尽快回复尽快处理。 上回看到有人提到了 MECE 原则 (相互独立，完全穷尽)，2x2矩阵(四象限)是其常用的分类方法，我把处理工作分为两个维度。横轴表示做事的紧急度，纵轴表示做到什么程度，试着将上述琐事对号入座。 然后将其所属分类对应到四象限中，得到更 general 的分类。 以上自己不成熟的思考，未经过时间考验，不一定正确。今后遇到事情还得具体来看，但总比没有原则好。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[来自实习生的提问]]></title>
    <url>%2Fblog%2F2019%2F09%2Fwhat-about-fe.html</url>
    <content type="text"><![CDATA[Q: 感觉我们前端能做的事情很少，前端真正的技术难点是在哪里？ 前端技术难点1、如何提效降本？ 代码写的更快/更少？排查问题更快？占用机器资源更少？投入的人手更少？ 2、极致体验 最早是淘宝天猫提出的，针对C端/H5的体验。更有价值的是，体验的优化能带来订单量的增长，这就需要跳出前端来考虑，有个「黑客增长」的概念 3、赋能阶段 让别人也拥有专业前端的能力，一般2个思路：让后端来写前端；让非技术同学来搭建页面 中后台场景典型的中后台页面，调研过以下3种思路。 基于代码区块开发页面时先用一条命令生成好大体的代码模板，比如表格、表单这种。 优势是可逐渐沉淀，提高复用率 缺点是区块需要抽象，要搞搞定上下游的人员 参考飞猪的中后台前端实践 基于页面可视化搭建使用拖拽的方式直接生成最终的页面。 优势是可全部甩给后端或外包人员去做，减少前端同学的投入 缺点是一眼看不到页面源码，以后页面迭代时可能会有一定门槛，特别是换其他同学去维护。 优秀的搭建工具有 面向中后台页面：金蝉 面向C端活动页：斑马 个人感觉C端页面更适合用搭建 基于JSON来配置页面介于上面2个方案之间（一个完全看到源码，一个完全无源码），这种方案下的源码就是 JSON。 优势是对于开发人员，写JSON比可视化拖拽更便捷，前端和后端同学都会写JSON 缺点是JSON的描述能力毕竟有限，JSON中的配置项增加了记忆负担，只适于简单的增删改查页面 Tapas 还不是很成熟的方案，但目前也能cover一些实际需求]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[演讲过程回顾]]></title>
    <url>%2Fblog%2F2019%2F07%2Fmy-talking-review.html</url>
    <content type="text"><![CDATA[今年做过3次比较重要的演讲，最近正在看关于演讲的书，借此机会对自己的演讲做一次复盘。 1. 部门分享第一次做45分钟的分享，第一次做完整的技术分享，第一次写演讲稿。 演讲稿45分钟的演讲，得有30页PPT才能支撑，讲稿至少要有4 5千字才不至于在演讲过程中显得尴尬。这是粽叔叔一开始给我的建议。 我确实写下了这么多字，但发现很难记忆，只能一边打开PPT，一边对着稿子讲。如果现场投影设备不支持演讲者视图，那将是一件多么尴尬的事。 随着慢慢练习，我觉得只要背出每张PPT中承上启下的那些文字就行了，中间的主体内容看着PPT讲就好，实在容易忘记的要点可以用关键词写在PPT中。 主线与主题最后我确实能脱稿讲40分钟了，那些承上启下的话语也牢记在心了。但分享完后发现效果没有达到预期，根本原因就是内容主线的问题。 我想给大家介绍自己做的一个技术工具，我的目的是什么，想让观众做什么？想清楚，演讲就是给观众送礼，所以我的目的是让他们来尝试用我的工具，所有介绍工具的背景、技术原理等等，都是为了让观众顺畅的理解后愿意使用我的工具。 那么怎样才能吸引观众来使用一种新工具呢？我犯了一个大错误，一开始花了很多篇幅来介绍工具产生的背景，而且没有提前做好对工具的铺垫，观众就会失去兴趣。后来开始正式介绍工具的时候，只是稍稍提了下工具的使用方式，接着又花大力气讲解它的原理和我在其中遇到的问题。观众连怎么使用都没看懂的话，根本不会去理解实现上的原理和问题，或者说无法感同身受。 所以我应该在简单介绍完背景后，先来一段演示，告诉观众原先是怎样的，用了工具后是怎样的，先有个直观的认识。然后演示如何使用工具来达到这一效果，以简单为主，否则观众会觉得这工具也太难用了吧。有了这些基础后，再去讲工具背后的原理和问题时，可以举刚才演示中的例子，解释为什么能实现，有哪些坑要小心。这样，观众对工具的认识是由浅入深，层层推进的。 2. 述职报告第一次做正式的述职，第一次排练试讲，第一次严格控制时间。 控制时间述职要严格控制时间，15分钟。仍然要从演讲稿入手，包含开头的自我介绍，写完所有稿子后读一遍，看看你需要多少时间。读的时候要有节奏的变化，像真的在述职那样，解释名词的时候要放慢，揭示结论的时候稍停顿，而介绍背景或承上启下的话语可以稍快。用这种方式把稿子读下来，就知道需要多少时间了。 第一版稿子写下来快3500字，放弃吧，我不可能在15分钟里读完这么多字，如果真做到了，那也会听起来像个录音机。仍然从稿子上做优化，精简文字，解释之类的话语能否更简练，承上启下的文字也简单些。这样改了两遍稿子，省去了300字，还剩3200字。 中文的正常语速是每分钟150到180字，只有新闻播音员可以达到每分钟300字。这么一估算，我的稿子还得再缩短。从主线上入手，它好比一棵树的主干，上面有很多分支，删去1个不影响主题的分支。于是我又省去了200多字，现在3000字，15分钟，还是可以拼一拼的。 有效的练习现在我需要练到每分钟说200字，必须很流利，否则很容易超时。把稿子读熟，是要像在「讲」一样的读，练到可以15分钟内读完。 然后要不要背诵？最好不要一个字一个字背，PPT就是讲稿中的提纲要点，每页的主体内容可以看着PPT来讲出来，差不多就好。 哪些句子需要背？ 每页PPT的承上启下的那些文字，必须很流利说出来，否则每次翻页就会卡顿，十几页PPT下来很可能会浪费半分钟以上。 那些解释复杂概念或现象，稿子中已经是你精炼过的文字，也最好能背出来，并且何时停顿何时强调，能够记住这种节奏。 演讲的开头，打招呼、自我介绍和PPT目录，这其实是在给观众（评委）的第一印象，文字可以很简洁，但不能上来就卡顿，所以开头也要背出来。 最后就是一遍遍地对着PPT练习，调到全屏模式，无任何备注参考，就凭记忆来讲。再找一位家人或朋友，对着他们讲，让他们帮忙计时，以及PPT中每个章节的计时。你就知道自己超时超在哪儿，自己在试讲时也可以在旁边用手机计时，讲到某个地方后瞄几眼计时，适当调整后面讲的节奏。前提是你要知道PPT中几个标志性的地方，正常讲完时的时间点。 问题准备述职报告必然会受到评委的提问，甚至灵魂拷问。不打无准备之杖，自己先在PPT中挑刺，提出一些问题，或者是PPT中没有提到，但有可能关联的疑问。用头脑风暴，列出一堆问题后，然后一一写下自己该怎么回答。 如果PPT中有一些图表或数据统计，要格外留心，评委可能会 challenge 你的图表，数据是怎么统计的，为什么能够从数据里得出你的结论，每条曲线背后的原因都要很清楚。这点与论文答辩很像，评委都对数据图表感兴趣。 3. 校园分享有幸被公司选去参加校园宣讲会，作为师兄做一个简短的分享。 建立联系这种分享场合，台下都是充满活力即将毕业的大学生。演讲的开头要与他们建立起紧密的联系，我以「师姐夫」的身份一上来就拉近了关系，随后逐步介绍自己的学习和工作经历，主要以「展示」的方式告诉他们今后可能会同样发生在他们身上的故事。 所有人都喜欢听叙事，叙事的结尾处再点出一两句要点，比如「我导师经常对我们说，你可以选择做任何事情，但永远不要低估一颗拥有梦想的心」，这比直接讲述「如何选择」要有趣的多。 控制紧张这次我也认真写了讲稿，也用了之前两次演讲的方法练习过。由于不只代表个人，在候场的时候我比以往更紧张。我记住了稿子中的开场部分和一些承上启下的文字，但仍然担心自己会忘词，怕场面尴尬。 最后索性不看稿子了，就像考试时你带着书进考场，指望临考前还能看几分钟，基本没什么用，最多起到心理安慰。最应该做的是闭目养神，以最好的精神状态走进考场。 自我感觉讲稿最多只能发挥到 90%，保证能说出这么多话来，剩下 10% 要靠临场发挥。有时可以向观众提问，或者听到台下的声音，就可以顺势聊几句，拉近与观众的距离，又能放自己放松。 复盘录像幸运的是 HR 小姐姐把每个人的分享都录像了，录像是个好东西，看自己的录像能发现一些自己都不知道的问题。 我发现了自己身体姿态上的两个问题 脖子前倾，驼背，要改！ 两腿晃动，是病，得治！ 我讲的时候喜欢走到投影前对着PPT比划，时而又走到电脑前去翻页。而一旦在讲台中间站定时，我的两腿就不自觉的晃动，导致上身也会跟着有点摇摆。可能是平时喜欢「抖腿」的缘故，我当时没有感觉到紧张，但在录像里看起来很可笑。 还有个问题就是在停顿时，其实我在想接下来要讲什么，但我嘴里习惯发出「ennn…」的声音，可能是在假装自己还没讲完吧。。。要避免这种口头禅！停顿就是停顿，无声胜有声。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书「演讲的力量」]]></title>
    <url>%2Fblog%2F2019%2F07%2Ftalking-skills.html</url>
    <content type="text"><![CDATA[最近看了「演讲的力量」，是一本专门介绍演讲技术的书，摘录了一些笔记，对自己很受用。 基础演讲本质有效沟通：指让对方轻松理解原本他不明白的东西。 为了达成有效沟通，要善用类比。为了让对方明白他现在不明白的X，找一个他原本就熟悉的A；然后告诉他在某方面来看，X就约等于A；再把A与X相像的地方讲清楚；最后X的那一方面就不言自明了……往往，在告诉对方X在哪方面很像A的那一瞬间，由于A确实是对方真正了解的东西，于是对方一下子就反应过来了，啊，原来是这样的啊！ 演讲就是给听众送礼物，用听众角度出发，逐步推进，带领听众开启一段旅程。用语言的魔力，植入思想，让听众有一种探索后豁然开朗的感觉。 【演讲风格】 给予而非索取 启示性，拒绝漫谈 专注本质，抛开公司和组织，用给予的方式说 启迪性的表演，拒绝只有形式没有内容 主线与主题主线，用主线来开场，主线不超过15词，主线不同于主题。从听众受众出发确定主线，内容庞杂=阐释不足，主线上的主题少即是多。 更有趣的叙述会让观众感觉时间过的很快，1-2分钟的自我介绍也可以有一条主线，选择足够有力的主题进行深挖。 从主线到结构，写作结构「什么-怎么样-怎么办」。基于问题的演讲以道德为前提，而基于思想的演讲以求知欲为前提。 技巧1. 联系要与观众建立联系 眼神交流，保持微笑 说故事，展示自己的脆弱 幽默感，让观众发出笑声 放下自我，不要傲慢 2. 叙述讲故事 故事要有一个引起听众共鸣的主人公。 激发兴趣、制造悬念。 适当提供细节。 要有令人满意的结局，或有趣、或感人、或给人以启迪。 3. 解释解释，是有意识地向人们的认知模式增加一种新的元素，或者以一种更好的方式对现有元素进行重新排序。 解释晦涩难懂的知识，先要从观众已知的概念开始，层层递进，应用比喻和举例让观众理解。 设计演讲的重点就是，恰当地平衡你所解释的概念与用以理解概念的例子和比喻之间的关系。 你认为观众知道什么？你的相关主题是什么？你用来辅助解释的必要概念是什么？你会使用什么样的比喻和例子来阐释概念？也可以从反面来解释，什么样的不是，不能怎样怎样。 解释尤其要考虑观众的不同领域背景。好的解释者点到为止，让人们感觉他们是自己发现了这个概念。他们的策略是引入新概念，描述其特征，让观众心里有所准备并自行理解它。这对你来说可以节省时间，观众也会感到满意。到演讲结束时，观众会沐浴在他们自己聪明才智的光辉里。 4. 说服说服是用一种更好的思想改变人们的世界观。其核心是具有长久影响力的推理的力量。推理最好辅以直觉输导、侦探故事、视觉资料或铺陈策略等。 在推理论述中，如果最初的假设是对的，那么有效推导出的结论也一定是对的，而且能被知道是对的。 归谬法：首先抛出与你的主张相反的观点，然后揭示出其中的矛盾之处。如果那个相反的观点不成立，那么你的观点就得以彰显（甚至被证明，如果没有其他可能的观点的话） 削弱相反观点的可信度是另一种有力的策略，但需要谨慎使用，最好是针对问题本身，而不是直接针对对方。 5. 演示根据演讲的不同主题采用不同的演示手段，是纯粹的科普或欣赏，还是产品或发明的演示，亦或是描绘未来和愿景。 艺术欣赏你要创造一种神奇的感受或审美上的愉悦，借鉴电影中的手法。 产品演示你可能要努力让观众为之惊异，创造一种新的可能性。 它是一项有趣的发明或设计吗？如果是，那么有无数种方式可以展示它，而你不应该做的就是，花费一半的时间讲解这项技术复杂的背景，因为观众还没有看到它的实际运行，所以可能会失去兴趣。一开始就要给观众一些暗示，让观众兴奋，期待即将看到的神奇演示。 可以用以下的顺序来组织内容： 以好奇心开场，告诉观众将会看到不可思议的一幕 必要的背景、语境或发明缘由 演示本身（越直观、越戏剧性越好，只要不弄虚作假） 讲解其背后技术的意义 未来愿景你要使其生动异常并令人震惊，以使观众为其折服，心向往之。 有效分享梦想的两个关键： 大胆地描绘一幅你所渴望的另一种未来的图景 你的做法要让其他人也渴望看到那样的未来 准备明确演讲主线后，善用以上 5 种技巧，然后就是演讲的准备过程。主要涉及以下几点 1. 视频资料Q: PPT中是否包括视频资料，如果包括，是什么材料？ 三句话说不清的，就要用图片表示，三张图说不清的，最好用一段小视频表示。 每张幻灯片只限于揭示一个核心思想！ 2. 演讲稿Q: 是草拟并背诵演讲稿，还是打算即兴演讲？ 一种方式是完整写下演讲稿，另一种方式是写出所有要点，对着要点展开。完全的即兴演讲很容易变成漫谈，而无法把控时间和重点。 Q: 背诵还是不背？ 不要机械地背诵，而要娓娓道来。如果你无法保证做到这一点，那就不要背诵。 Q: 能不能对着PPT备注朗读？ 只有当你要展示精美的图片或视频时，可以朗读讲稿，因为观众的注意力在屏幕上。其他情况，不能读，要讲出来，这是与观众的联系，就像看实况直播而不是回放。 3. 串词与排练Q: 如何进行计时练习？ 要准备在9/10的规定时间内完成演讲，不断精简语言或删减内容，直到完成。 Q: 「背诵」与「即兴」的区别？ 排练缩小了两种方式的距离，就会看到背诵演讲和即兴演讲之间的距离开始变小。在最好的背诵演讲中，演讲者对演讲内容的理解透彻熟练，能对所讲内容全情投入。最好的即兴演讲是演讲者进行过无数次的排练，能确切地知道演讲该如何推进，而且对那些有力的语言表达了然于胸。 Q: 什么是合适的方式？ 有许多种方式可以用来准备并发表演讲，重要的是要找到适合你的那种方法，要感到舒适和自信。因为当演讲正式开始的时候，即使你做了精心的准备，还有许多地方或许会出错。 4. 开场与结尾Q: 如何开场与收尾从而产生巨大的影响力？ 激发兴趣是吸引观众的最简单有效的工具。怎样才能激发兴趣？最简单的方式就是提问，但不是随便提问，而是问有趣的问题。 开场1分钟，要留有悬念，不要和盘托出。 最后，强烈建议你写出并且背诵开场和结尾部分，这有助于你缓解紧张、增强信心，而且能使演讲更加有力。 临场克服紧张正式上台演讲时，难免会遇到紧张，最好提前预演这种尴尬的场面。有几种办法 上台就先告诉大家「我不经常演讲，有点紧张，中途可能会看几眼小抄哦」，只要不过度依赖小抄，不影响自己与观众之间的眼神交流，就没有人会在意你的小抄。 想一个关于自己的小故事，展现自己的脆弱面，比如曾经因为紧张错失了向女神表白的机会。让观众放松，会更关注于聆听演讲。 对着某个观众讲，想象他就是你的朋友，或者碰巧台下有你认识的人，可以让自己快速恢复到平常心态。 紧张的结果就是忘词，场面会变得尴尬。通常办法无非就是「作弊」办法：小抄，小卡片，或是PPT备注。与其偷偷摸摸的作弊，不如大大方方的去看，比如去讲台喝口水顺便看一下。前提是准备充分，不能过于依赖作弊，小抄放在讲台上或捏在手里，是为了给你安全感。 声音技巧技巧：音量、音高、节奏、音色、语调以及所谓的“韵律”。 讲稿标注：在每个句子中找到两三个最重要的词语，对其下画线；然后在每段中找到那个尤其重要的词，再画两道下画线；找到整篇讲稿中声调最轻的那个句子，在下面用铅笔轻轻画一条波浪线；找到每一个问号并用黄色荧光笔将其突出；找到演讲中最令人惊讶的地方，在它之前添加一个巨大的黑点；如果某个地方有个有趣的小故事，就在上面画个粉色的小圆点。 朗读技巧：在每个标记处变换语调。例如，当看到粉色小点时要微笑，在大黑点处要停顿，在铅笔波浪线处语速略快，同时声音要更加柔和。记住与演讲中的每一段相关的情感。 演讲节奏：根据演讲内容变换语速是非常重要的。在介绍重要概念或解释复杂理论的时候，要放慢速度，不要害怕停顿。在趣闻逸事或比较轻松的地方，可以加快速度。但总的来说，你必须用自然的、口语化的节奏来讲。 身体控制发表有力的演讲最简单的方法就是站直，重心平均分配在双脚上，双脚自然地分开几英寸的距离，用双手和胳膊的自然摆动强调你要说的话。如果观众席是围绕舞台弧形设置，你可以通过转动腰部看向不同区域的观众，完全不必四处走动。 误区1：双腿来回晃动 双腿交替移动能缓解演讲者的不适感。但在观众看来，这实际上强化了这种不适感。也许你没觉得自己紧张，但观众觉得你紧张、不自信。 误区2：台上不停走动 如果习惯于在台上走动，那么当讲到需要强调的地方或者要做某种解释时，你最好在某个地方停住脚步。持续的走动看上去会很令人疲惫，来回走动时偶尔止步会更加有力。 最后，做自己~ 感想小时候十分害怕跟别人说话，只有少数几个同学朋友除外。班级聚会面对一桌人时要起个头说点话也无所适从，面对老师和长辈时就更无话可说了。 可能情商低，高中语文成绩一直上不去，到了高三那年我不得不决定把更多的时间投在语文上，而其他科目用细心求稳的方式。最后证明语文这种原本捉摸不透的东西也能通过技巧加以训练，那年我把语文成绩硬生生提高了20分。 说话，演讲，底层就是语文。「演讲的力量」这本书给了我全新的认知，演讲中的各种技巧也能用在日常的交流对话中，并且技巧都是可以通过努力来练习的。相比即兴的说话，演讲可能更容易练习，因为可以提前准备，就像你在做自己的语文试题，你说的话表达了什么样的中心思想，表达了什么样的情感。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思考一则]]></title>
    <url>%2Fblog%2F2019%2F07%2Fwhy-how-what-do.html</url>
    <content type="text"><![CDATA[最近知乎一直看到「为什么强如“死月”在阿里也只有 p6?」问题链接戳 https://www.zhihu.com/question/326940670 让我陷入沉思和不安的是玉伯的回答 一个考量维度是一个人的思维模式。具体到技术岗，很重要的一点，是去看一个同学会不会去思考事情背后的 WHY，会不会去深入了解 WHY 所处的大环境，会不会在想清楚 WHY 后，去分析思考解决路径，在有多条路可选的时候，敢不敢去做取舍权衡，能不能去找到最佳路径和实现策略。WHY - HOW - WHAT - DO 的思维框架下，DO 是最后一步，很关键，但前面三步如果思考不清，光有 DO 是很难拿到优秀结果的。—— 玉伯 似乎我做事的思路一直是 WHAT - WHY - DO - HOW，总是先会想能不能做一些事情，然后看看这事靠不靠谱，靠谱的话就开始做起来了，等遇到问题的时候才会考虑 HOW 的问题。 确实，如此容易走弯路，出发点是做些什么，第一想到的是自己的 KPI，总得做点什么吧。而不是从源头去想问题，为什么要做这个事情，目前有什么问题，它的源头是什么问题，为什么会有这个问题。 按照 WHAT - WHY - DO - HOW 做下来，会把问题看的很局限，走一步看一步，怎么去丰富自己的 KPI 同时又解决了一些问题，这注定走不远，因为一开始就没有看到问题的 scope，更不会去从问题的全链路上去想解决办法。 自己这一年与 leader 也讨论过很多，都是以 WHAT 出发的，单纯从组内向上沟通的角度看，似乎也没有什么问题。但几次跟着 leader 去和兄弟团队的 leader 去讨论一些事情的时候，明显感觉到自己的格局不够。 leader 们都会首先关注问题的 scope，到底是不是问题，是个多大的问题，涉及到哪些人员方，为什么会有这个问题。然后怎么在链路上解决问题呢，并不是一定要用技术手段，有没有办法通过流程和规范解决问题。如果用技术手段，可以在链路的哪几个节点上来做些事情，问题的源头问题是什么，在哪个节点上可以彻底解决问题，再考虑下 ROI 怎么样，换个节点怎么样，需要哪几方配合…… 按照这个思路想下去，我们就把 WHY 和 HOW 的事情想清楚了。 剩下就是 WHAT &amp; DO 了，更多是去设计实现方案，要更多考虑不同方案的 ROI。沟通能力也很重要，如何让链路上的其他人员方加入进来，如何让他们达成共赢，一起把事情做了，这是一门博弈学问。多和 leader 交流，多一点 ownership，从他们身上学到很多。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一段难忘的H5经历]]></title>
    <url>%2Fblog%2F2019%2F06%2Ftough-experience.html</url>
    <content type="text"><![CDATA[最近做了一个C端H5项目，嵌在一个App里，上线前都测得好好的，上线后就暴露出各种问题。于是记录这些经验，希望以后启动新项目时能够顺利一些。 启动阶段【技术选型】 选择你熟悉的框架/方案 选择团队成员都熟悉的框架 【SPA路由模式】 一开始就要考虑好 hash mode or history mode 浏览器的 http referer 中不会记录 url 中的 hash 提前调查第三方监控 / 统计工具能否支持 hash 路由模式一定要提前想清楚，后期再改可能要牵动各依赖方 上线要求【数据埋点】 新项目第一版上线时一定要做好埋点统计，否则后期迭代优化时没有指标对比 综合考虑第三方统计产品，必要时特殊业务场景需要单独开发埋点落库的接口 埋点功能分类 页面统计：PV，UV，停留时长，用户留存 按钮统计：某个按钮的点击次数 / 点击率 页面内区块的统计：如某对话框展示了多久才被用户关闭 转化统计：一个流程中各步骤的 PV 漏斗 / 转化率 【前端监控】 接口监控：接口成功率，接口状态码 js 监控：exception 信息，是否支持 js map 性能监控：domReady 与 onload 时间 排错技巧【console工具】 留好 vconsole / eruda 之类的开关 测试环境可默认加载 console 工具脚本 生产环境可通过 url 末尾加 debug 参数作为后门 脚本越早加载越好，最好在项目入口文件执行之前 在项目 js 逻辑的关键节点打出一些必要的 log 比如鉴权失败，没有获取到 token 需要调用 hybrid 的地方可打出返回值 保证在 js bridge 脚本注入且执行完成后，才调用 hybrid 方法 【抓包工具】 anyproxy / charles：提前装好工具 https 抓包：提前装好证书 【真机调试】 安卓手机开启「开发者选项 - USB 调试」，使用 chrome://inspect 苹果手机使用 xcode simulator，在 safari 中开启「偏好 - 高级 - 显示“开发”菜单」 面对时好时坏的功能 接口侧：多机房发布是否有遗漏，负载均衡是否正常 前端侧 先确定是否跟机型有关，如果是兼容性问题配合前端监控来看 跟机型无关，再排查出错的随机性，是否与脚本并行加载的执行顺序有关 是否依赖外部，如 hybrid 方法，外部是否稳定，配合 console log 来看 【参考资料】 Charles 高级玩法]]></content>
      <categories>
        <category>吹水</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React文档备忘]]></title>
    <url>%2Fblog%2F2019%2F04%2Freact-notes.html</url>
    <content type="text"><![CDATA[React 文档陆陆续续看了两三遍，但一直没有真正做过业务，每次都只记住个大概。这回跳出舒适区，主动在业务里用 React，记录一些文档中的关键点。 基础React Class React.Component 默认的 shouldComponentUpdate 全是 deep compare，性能开销大 可自行重写 shouldComponentUpdate()，作为一种优化手段 React.PureComponent 不建议重写 shouldComponentUpdate() 默认的 shouldComponentUpdate 中通过浅层比较 props 与 state 适用于简单数据模型，无嵌套结构 子组件树的 props 更新可能不会触发重新渲染 最好没有子组件，有的话最好也是纯组件 https://lucybain.com/blog/2018/react-js-pure-component/ React.Fragment 在不额外创建 DOM 元素的情况下，在 render() 中返回多个元素 简写为 &lt;&gt;&lt;/&gt; 生命周期 constructor(props) render() UNSAFE_componentWillMount componentDidMount() UNSAFE_componentWillReceiveProps shouldComponentUpdate() UNSAFE_componentWillUpdate componentDidUpdate() componentWillUnmount() 注：UNSAFE 开头的函数为已过时的生命周期钩子，详见官网博客。 高级玩法用于状态维护 Hook：用于状态逻辑的复用 可写出更简洁的代码，减少相同逻辑分散多处 Context：用于跨层元素传递 props 会降低组件的复用性，使用前想想清楚 考虑直接传递组件，或者传递 render props 用于提高复用 (关注点分离) Render Prop HOC 高阶组件 Mixins Considered Harmful HOC 是纯函数，没有副作用 高阶组件要透传所有 props 如何从 Class 迁移到 Hook 控制DOM Refs 转发：比 Vue 的能力强 个人感觉不利于组件内聚性 适用于HOC高阶组件中 设计模式 优先组合，而非继承 2019 ReactJS Best Practices 2019 Using Redux and Redux-Thunk 坑点this binding背景：在 ES6 class 写法中，绑定的自定义事件函数执行时会遇到 this 作用域问题 原因：React 对待生命周期的钩子函数时，会主动绑定 this，而对待 JSX 中的回调函数则不会？? 解决办法 extra bind in constructor 代码累赘 bind in render function 每次重新渲染都绑了一个新函数 use class property and arrow function babel: class-properties or preset-react render HOC不要在 render 方法中使用 HOC 1234567render() &#123; // 每次调用 render 函数都会创建一个新的 EnhancedComponent // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！ return &lt;EnhancedComponent /&gt;;&#125; React 的 diff 算法（reconciliation）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端为什么要会正则表达式]]></title>
    <url>%2Fblog%2F2019%2F02%2Fregexp-in-frontend.html</url>
    <content type="text"><![CDATA[在笔者学生时代，一直单纯地认为正则都是后端老哥的事儿，前端只要 split 一把梭就够了。万不得已的时候就网上搜几段正则代码，copy 一下也能用。 这是维基百科上正则表达式的词条，截图只截了一屏，事实上这张正则表达式的表格两个屏幕都装不下。。。我第一次查的时候立马就弃了，于是很长一段时间里都在原地踏步，只会用用 ^ $ . * 最初见到正则表达式是在表单验证里，多少会用些 validate 的库，基本的电话 / 邮箱之类的校验都有现成的，真正自己写正则去校验输入格式的机会并不多。后来渐渐发觉正则表达式的魔力，它可以是前端工程师的一把利器。 日常琐事1、老项目迁移，所有的 T.dom.getElementById(&#39;abc&#39;) 代码都要改成新的写法 $(&#39;#abc&#39;) 2、组件库升级，所有的 &lt;el-dialog v-model=&quot;a&quot; 必须改成 &lt;el-dialog :visible.sync=&quot;a&quot; 都是真实工作中的脏活累活，故事 1 中的项目有近 100 个页面，由于 T 库弃用了，不仅 T.dom.getElementById 还有 getElementByClass 等等调用都要改成 jquery 的写法。如果完全靠人肉，那是多么的苦力。 故事 2 中的组件库其实就是我们的 Element，我们原先很多项目都是 Element 1.x，要升级到 2.x，这个对话框的 breaking change 影响还挺大的，在 2.x 中通过 v-model 是无法唤起对话框的。因此要确保每个 el-dialog 都检查一遍，而模板代码里 el-dialog 的 v-model 可能不在第一个，属性多的时候还会换行，都需要火眼金睛。 聪明的读者肯定知道，靠人肉是个没有办法的办法，而且看多了也会眼花，最好还要 double check。虽然写正则表达式去找，也不能保证 100% 都覆盖，毕竟老项目里各种迷之代码都有，但正则能帮我们找出大部分，并且 replace 的时候也能避免输入错误，这样可以把精力放在 double check 上。 正则起源正则表达式源于形式语言与自动机理论，关于形式化的内容不是本文的重点，感兴趣的朋友可以去 wiki 上查。 正则引擎的基础就是状态机，在编译原理中你一定会听说 NFA (非确定有限状态自动机) 与 DFA (确定有限状态自动机)，关于 NFA / DFA 通俗的解释可以参考这篇文章。 正则表达式最早在 Unix 中的 sed 和 grep 命令中开始普及。如果你用过 sed &quot;s/aaa/bbb/&quot; 的话，其实可以写正则表达式来做更复杂的文本处理。 而在编程语言中，Perl 是第一个实现正则表达式引擎的语言。目前大部分语言都使用基于 NFA 的正则引擎。 怎么学正则笔者走了一些弯路，先在实战中写正则，不会写就查正则的语法表，渐渐地大部分语法也就都记住了，需要查表的也越来越少了。其实我觉得正确的学习方式应该先完整地看一本入门书籍，对整体有宏观把控后，再在实战中反复练习和查表，回头再重看书，这样的记忆应该最深。 如果你还在为正则表达式的语法而健忘的话，推荐一本《正则表达式必知必会》，这本书只有 100 页，一个周末就能看完。以后再查语法表的时候，就会越来越有规律可循。 正则表达式的语法可分为这几大类 匹配字符 匹配位置 重复与贪婪 分组与捕获 前后断言 本文并不介绍正则表达式语法，只通过实际工作的例子来说明正则的用途。可以先根据以上几个分类，在正则表达式的语法表里再过一遍。 1、URL里的暗号在公司的开发环境中，一般都会有两套以上的测试环境，如 alpha 和 beta 环境。而在前端页面，我们通常使用不同的 URL 来区分，例如 jack.alpha.domain.com 与 jack.beta.domain.com 分别对应 alpha 和 beta 环境，而 jack.domain.com 则是生产环境。问题来了，前端代码是同一份，它需要根据当前 hostname 所属的环境来调用不同环境的接口。 当然这个问题也是 split 一把梭就能解决的，但这并不优雅。回到正则表达式上，我们先分析需求，假设公司一级域名只有 domain.com 的，那么这个问题就是提取 appid (例子中的 jack) 与 .domain.com 中间的部分。 123var reg = /\w+\.(\w+\.)?domain.com/;var match = 'jack.alpha.domain.com'.match(reg);console.log(match[1]); // alpha. 如上代码的正则表达式中，关键是 (\w+\.)? 这段，它表示匹配零次或一次，并且小括号是分组，可在 match 的结果中直接捕获到分组里的值。 补充1：分组里拿到的结果是 alpha.，多了个 . 不走心，怎么把它去掉呢？可以改成 ((\w+)\.)? 这样 alpha 就要在第 2 组捕获里拿到了，因为第 1 组仍是 alpha. 补充2：试试 (?:(\w+)\.)? 这里 (?:) 表示不产生分组号，于是仍可在第 1 组捕获中拿到 alpha 补充3：\w 匹配字母数字和下划线，如果你的 hostname 中包含其他字符，比如扩充成 [\w-] 就可以包含中划线 - 补充4：加入公司的一级域名有多个，那也可以对 domain.com 再进行扩充。 12345var reg = /\w+\.(?:(\w+)\.)?(domain|abc|xyz).com/;var match = 'jack.alpha.domain.com'.match(reg);console.log(match[1]); // alphamatch = 'jack.domain.com'.match(reg)console.log(match[1]); // undefined (分组捕获不到则表示生产环境) 正则表达式的书写是逐步细化的，还是要先分析好需求，写的不多余。 2、引号替换在一些老项目里 JavaScript 代码经常存在单引号双引号混用，很不规范，让以后的维护者看着很累。虽然现在我们都会使用 ESLint 来自动修复，还是想举这个例子来作为正则表达式的一个 case 123456789&#123; "a": &#123; "a1": "a1", "a2": &#123; "b1": 'b1' &#125; &#125;, 'b': "b"&#125; 现在希望把这段 JSON 对象改成 key 不带引号，value 都为单引号。观察下这份数据，key 和 value 都有单引号和双引号，于是我的想法是先把所有双引号改成单引号，然后再把 key 的单引号去掉。 双引号 → 单引号，我第一次写出来是这样的： 1replace(/"(.*)"/g, '$1') 大部分 IDE 的 find-replace 功能都支持写正则，不妨可以试试看，上面这段正则有什么问题。 .* 也匹配了双引号，上面 &quot;a1&quot;:&quot;a1&quot; 被 &quot;.*&quot; 匹配了，这是典型的过度匹配。解决办法是使用 [^&quot;]* 或者使用 .*? 以表示尽可能少的重复。这就说到了正则表达式中的贪婪与惰性。 贪婪与惰性 图片示例来自《JavaScript 正则表达式迷你书》 上面这张图解释了正则引擎的匹配过程，正则表达式是 &quot;.*&quot;，待匹配的字符串是 &quot;abc&quot;de 第 1 步，初始化，当前状态指向正则中的第1个 &quot;，并且开始读取待匹配字符串。 第 2 步，发现正则中的第1个 &quot; 正好能匹配字符串。 第 3 步，当前状态指向正则中的 .*，并且读取字符串的指针也向前移动，巧了，a 也被匹配上了。 第 4 ~ 8 步，真香真香，.* 一直匹配到字符串末尾了！坑了，我这正则 .* 后面还有个 &quot; 要怎么办？ 第 9 步，读取字符串的指针回退一格。这就是正则匹配中的回溯。 第 10 步，回退完发现正则最后的 &quot; 还是没法匹配 e，于是继续回退。 第 11 步，回退完还是不能匹配，再回退。 第 12 步，现在读取字符串的指针在 &quot; 上，不容易，终于匹配上了！ 上述过程中，.* 是贪婪的，一开始会把字符串里的 abc&quot;de 都匹配进去，然后正则发现这是条死路，再一步步回退，直到正则能够继续匹配下去。这个过程就是 NFA 中的回溯法。 而当使用了惰性模式后，如将 .* 改成 .*?，它会尽可能少地匹配。不妨试下以下两个例子，观察两个分组里捕获到的内容。 12'12345'.match(/(\d&#123;1,3&#125;)(\d&#123;2&#125;)/)'12345'.match(/(\d&#123;1,3&#125;?)(\d&#123;2&#125;)/) 回溯的深渊然而正则中的贪婪和回溯也有个天坑，那就是 ReDos，即正则表达式里的 Deny of Service。可以试试如下代码： 12'aaaaaaaaaaaaaaaaaaaaaaaaaaaab'.match(/^(a+)+$/)'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'.match(/^(a+)+$/) 当正则表达式中出现有歧义的片段时，如 /(a+)+/，字符串里的 a 既可以被 a+ 匹配，又可以被 (a+)+ 匹配，这就容易产生问题。按照上面回溯法的原理，a+ 会先一路把 a 都匹配完，然后发现糟了，正则表达式最后还有个 +，于是一个个字符回退，直到发现 (a+)+ 能匹配时又会一路把 a 都匹配完，然后发现行尾符匹配不了，会再次回溯尝试。随着字符串长度的增加，回溯次数会呈指数级增长，终将导致 Deny of Service。 ReDos 的内容更多在安全领域，笔者只粗略了解下。平时书写正则表达式的时候尤其要留意嵌套的 * 和 +。 3、字符串去重你可能在算法题里也见过字符串去重，去掉字符串中重复的字符。本文这里不讨论算法，想说明通过正则表达式也能判断用户的输入里有无重复字符。这里需要先学习正则里的几个武器。 反向引用 (back reference)简单说就是在一个正则表达式中引用一个分组的子表达式。举个 HTML 标签的例子，如果要匹配 &lt;h1&gt;&lt;/h1&gt; 标签，可以这么写 /&lt;(h[1-6])&gt;[\s\S]*&lt;\/\1&gt;/ 这个正则可以匹配任意合法的 h 标签，其中 \1 就代表第 1 个分组的反向引用，否则就得为 h1 ~ h6 各写一个表达式就很累赘。反向引用的关键在于前面要先有分组，否则 \1 是无效的。 先行断言 (look ahead) / 后行断言 (look behind)先行断言的语法形式为 /c(?=a)/，表示匹配 a 左边的 c。为了避免与断言中的「前」和 「后」混淆，这里就用「a 左边的 c」来表达。 先行断言有些地方也叫「前瞻断言」或「前向查找」，想象你自己就是一个指针，扫描字符串的过程就像指针在向前移动。 先行断言也有其否定形式，叫做先行否定断言，如 /c(?!a)/，即匹配「非a」左边的 c，其实这与 /c(?=[^a])/ 效果相同，感兴趣的朋友可以自己试试。 所有的正则引擎都支持先行断言和先行否定断言。到了 ES2018 才支持后行断言，细节可参考 ECMAScript 6 入门的正则章节。 尤其需要提一点的是，断言中的文本不会包含在最终的匹配结果里，怎么理解呢？/c(?=a)/ 只会匹配 c，(?=a) 既不会产生分组，也不会出现在 match 函数的结果中，可以试下 &#39;cat&#39;.match(/c(?=a)/)。容易犯的错误是不小心写成了 /c(?=a)t/ 那就 GG 了，这是个永远不可能匹配的正则表达式。 现在我们回到字符串去重的问题上，用上面的武器很容易想到，用先行断言配合反向引用。直观上的理解就是自己作为一个扫描指针，先往前面看，在远处能不能找到和当前脚下相同的字符。 1'abcdaccd'.replace(/(.)(?=.*?\1)/g, '') // bacd 上面的字符串用正则替换后为什么是 bacd，不应该是 abcd 么？因为 /(.)(?=.*?\1)/ 匹配的是第1个 .，断言并不会出现在匹配结果里，所以理解起来就是扫描指针在当前位置时，先往前面看，如果有看到相同的字符，就把当前脚下的字符替换成空。 如果想让替换后的结果是 abcd 该怎么写正则呢？显然要用后行断言，就是扫描指针在当前位置时，往身后看，如果有看到相同的字符，就把当前脚下的字符替换成空。 1'abcdaccd'.replace(/(.)(?&lt;=\1.*?\1)/g, '') // abcd 看到这个正则可能又困惑了，后行断言难道不都是 /(?&lt;=y)x/ 这么写的么？这就是黑科技了，因为用到反向引用，就得保证正则表达式中要先出现分组，所以 /(?&lt;=\1.*?\1)(.)/ 这种表达式里的 \1 是无效的。 注：此法来自正则实现数组滤重 4、定制 .vue 单文件模板最近在做微信小程序，每个页面都必须写 wxml / wxss / js / json 这 4 个文件，当项目里页面多的时候文件就巨多无比。假如没有用任何开发框架，可以自己定制一个单文件模板，有点类似 .vue 文件。 1234567891011121314151617181920&lt;template&gt; &lt;view&gt;&lt;/view&gt;&lt;/template&gt;&lt;script type="json"&gt;&#123; usingComponents: &#123; &#125;&#125;&lt;/script&gt;&lt;script&gt;Page(&#123; // ...&#125;);&lt;/script&gt;&lt;style lang="stylus"&gt;&lt;/style&gt; 现在我们的目标是把这个文件拆成模板、样式、js 和 json 配置对应的 4 个文件，抛弃原来的 split 大法或者逐行读文件，正则表达式可以帮我们优雅地解决问题。 修饰符在前面的正则表达式中见到了 /.*/g，其中的最后那个 g 就是正则表达式的修饰符。 常用的修饰符有 i ：ignore case m ：multiline g ：global 很好记，合起来 img，ES6 中又新增了几种修饰符，细节可参考 ECMAScript 6 入门的正则章节。 多行模式 (multiline)上面这个问题需要用到正则表达式中的多行模式，因为要在代码文件中做匹配，肯定涉及到换行。 当使用了 m 修饰符后，多行模式下会更改 ^ 和 $ 的含义，使它们分别在任意一行的行首和行尾匹配，而不是整个字符串的开头和结尾。 回到刚才的问题，如何提取 &lt;template&gt;&lt;/template&gt; 标签之间的内容，首先会想到 /&lt;template&gt;(.*)&lt;\/template&gt;/m，然而可以试试发现不行。这是因为 . 匹配的是除 \r \n 之外的任何单个字符，并不是所有任意字符。所以正则表达式需要改成 /&lt;template&gt;([\s\S]*)&lt;\/template&gt;/m，分组中捕获的就是标签之间的内容。 同理，匹配 &lt;style&gt; 标签里的样式，可以写出 /&lt;style(?:\s+lang=&quot;(\w+)&quot;)?&gt;([\s\S]*?)&lt;\/style&gt;/mg 其中 &lt;style(?:\s+lang=&quot;(\w+)&quot;)?&gt; 可以同时匹配 &lt;style&gt; 与 &lt;style lang=&quot;stylus&quot;&gt;，并且可以从分组捕获中拿到 lang 属性的值。另外要提的是，.vue 文件里可能会写多个 &lt;style&gt;，所以这个正则表达式中要使用 m 和 g 两个修饰符，并且在标签内容的里要使用 [\s\S]*? 以表示惰性（尽可能少的匹配）。 最后就是区分 &lt;script&gt; 标签了，在我们定制的模板中，存在着 &lt;script type=&quot;json&quot;&gt; 这是我们自己约定的写 JSON 配置的地方，而普通的 &lt;script&gt; 或 &lt;script type=&quot;text/javascript&quot;&gt; 则是写 JavaScript 代码。用先行否定断言，可以写出 /&lt;script(?!\s+type=&quot;json&quot;).*?&gt;([\s\S]*?)&lt;\/script&gt;/m 来提取 JavaScript 代码。这里可以体会下，如果前面半段写成 /&lt;script(?!\s+type=&quot;json&quot;)&gt;/ 的话，就无法匹配到 &lt;script type=&quot;text/javascript&quot;&gt; 了。 JavaScript 中的正则如果读者看到这儿，说明对正则没有失去信心。🌝 JavaScript 中正则相关的函数有 replace / test / match / exec，上文示例代码中也用过一些了。这里强烈推荐下 exec 函数，当使用了 g 修饰符时，如果字符串中有多处匹配，match 函数无法拿到每处匹配中的分组信息，这就需要用 exec 来处理了。 12345678var reg = /￥(\d+)/g;console.log('￥1 ￥23 ￥33'.match(reg)); // 无法拿到分组捕获var res;while (res = reg.exec('￥1 ￥23 ￥33')) &#123; console.log(res, res &amp;&amp; res[1]); // 可以拿到第1个分组 console.log('reg lastIndex', reg.lastIndex);&#125; RegExp 对象里的 exec 函数可以被多次调用，每次只返回一处匹配的详细信息（包括分组捕获），并且把当前处理到的字符串下标存在 RegExp 的 lastIndex 中，这样就可以在 g 全局模式下得到每处匹配的分组信息。 ES6 后的新增特性ES6 之后对正则表达式的新增了不少特性，主要在对 Unicode 的支持上。如果你去网上搜那些正则表达式大全，很有可能会搜到用 /[\u4e00-\u9fa5]/ 来识别汉字，这是很久以前的做法。现在的字符集更多了，不妨试试 𠮷 の 或者 😂 呢？先来看个例子： 12console.log('😂'.length); // 2console.log('\uD83D\uDE02'); 可以看到 😂 由 2 个双字节码组成 (UTF-16)，可以在 codepoints 上查到它的所有编码格式，显然它已经超出了 /[\u4e00-\u9fa5]/ 的范围。你可能会说，它又不是汉字，当然不能用上面那个正则，那不妨再查下 𠮷 的编码。 ES6 对正则表达式有个 u 修饰符，表示 Unicode 模式。在这个模式下，正则中的 . 可以匹配换行符以外的任意单个字符（包括 Unicode 字符）。 12345678/./.test('😂'); // true 因为 😂 被认为是2个字符，相当于 '\uD83D\uDE02'/.&#123;2&#125;/.test('😂'); // true 原因同上/\S&#123;2&#125;/.test('😂'); // true 原因同上/^.$/.test('😂'); // false 正则限制了开头和结尾，2个字符当然匹配不上咯/^.$/u.test('😂'); // true Unicode 模式下，认为 😂 是1个字符/.&#123;2&#125;/u.test('😂'); // false 原因同上/\S&#123;2&#125;/u.test('😂'); // false 原因同上/\u&#123;1F602&#125;/u.test('😂');// true Unicode 模式下还可以用 \u{unicode值} 来表示码点大于 0xFFFF 的 Unicode 字符。 此外，ES2018 还引入了 Unicode 属性转义，比如可以用 /\p{Unified_Ideograph}/u 来匹配所有汉字。其中 Unified_Ideograph 是一个 Unicode property 表示汉字字符集，可在 tc39 中查到所有属性转义。 当然，ES6 和 ES2018 还增加了另外2个修饰符，以及后行断言和具名分组，出于篇幅原因这里就不多介绍了，有兴趣的可以参考 ECMAScript 6 入门的正则章节。 总结正则表达式是前端工程师的一把利器，也是值得每个程序员掌握的。本文抛砖引玉，主要想说明正则表达式在前端中有着很多应用场景，而不仅仅是纯粹的表单验证。 正则表达式的语法看着多而复杂，但只要从语法的功能分类入手，平时多写多运用，就能很快克服语法的记忆负担。书写正则表达式的过程也体现着思考的过程，正则的细化也就是需求的细化。 最后再次推荐入门书籍《正则表达式必知必会》，以及正则表达式的可视化工具 regulex。 参考资料 《JavaScript 正则表达式迷你书》 ECMAScript 6 入门的正则章节 正则实现数组滤重 浅析ReDoS的原理与实践 一个由正则表达式引发的血案（解决版） 一次性搞懂JavaScript正则表达式之引擎]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“滑稽”的事件循环]]></title>
    <url>%2Fblog%2F2018%2F12%2Finteresting-event-loop.html</url>
    <content type="text"><![CDATA[最近在写 Vue 时遇到了一个问题，大体场景是：有一个组件 A 用于对话框中，也可用在对话框之外。A 初始化后会请求数据，当它用于对话框中时，可能会接收外部传入的参数，需要根据这些参数去请求数据。 我们知道大部分 Dialog 组件在实现时，只有当对话框首次被打开时才会去渲染其内部的 content 部分。于是问题是：当组件 A 处于对话框中，并且首次打开对话框时，A 先被初始化，然后对话框向 A 透传外部传入的参数，由 A 发起数据请求。 事故现场123456789101112131415export const A = &#123; methods: &#123; reload() &#123; // 省略...请求数据 &#125;, receiveContext(&#123; params, data &#125; = &#123;&#125;) &#123; // 省略... this.reload(); &#125;, &#125;, mounted() &#123; // this.reload(); nextTick(() =&gt; this.reload(), 0); &#125;&#125;; A 的 mounted 先被触发，调用 reload 函数；接着外部开始调用 receiveContext，再次调用 reload，也就出现了在对话框首次打开时会重复请求。 P.S. 别问我为什么不用 props 透传，因为我用 dispatch action 触发 receiveContext。 无论我在哪儿怎么加 nextTick，都避免不了在第一次渲染时重复请求的问题。于是发现自己对 nextTick 的本质还没搞透。 修复后先直接给出修复后的代码，再慢慢探究原因。 1234567891011121314151617181920export const A = &#123; methods: &#123; reload() &#123; // NOTE: 防止初次渲染 receiveContext 后触发 2次 reload if (this._macroTimer) &#123; clearTimeout(this._macroTimer); this._macroTimer = null; &#125; // 省略...请求数据 &#125;, receiveContext(&#123; params, data &#125; = &#123;&#125;) &#123; // 省略... this.reload(); &#125;, &#125;, mounted() &#123; // NOTE: setTimeout 为 macrotask, 可以保证在 nextTick (microtask) 之后执行 this._macroTimer = setTimeout(() =&gt; this.reload(), 0); &#125;&#125;; Event Loop都知道 js 是单线程的，为什么要设计成单线程，读者不妨可以思考一下🤔 同时 js 又是非阻塞的，这就是 Event Loop 的功劳了。 主线程运行的时候会生成堆（heap）和栈（stack）； js 从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中； 当程序调用外部的API时，比如 ajax、setTimeout 等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中； 主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。 主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的，就叫做 Event Loop 事件循环。 macro task + micro task在 Event Loop 为了区分异步任务的执行优先级，js 设计出了 macro task (宏任务) 与 micro task (微任务) 这两个概念。 常见的 task 有 macro task: setTimeout，setInterval，setImmediate，I/O (磁盘读写或网络通信)，UI 交互事件 micro task: process.nextTick，Promise.then 事件循环会将遇到的异步任务排列到对应的 macro task 及 micro task 队列中： 当执行栈中的任务清空，主线程会先检查 micro task 队列中是否有任务，如果有，就将 micro task 队列中的任务依次执行，直到队列为空； 然后再检查 macro task 队列中是否有任务，如果有，则每次取出【第一个】macro task 加入到执行栈中； 再次清空执行栈，重新检查微任务（重复第一步） 测试代码test 1 12345678910111213141516console.log(1);setTimeout(() =&gt; &#123; console.log(6);&#125;, 0);new Promise(resolve =&gt; &#123; console.log(2); resolve();&#125;).then(() =&gt; &#123; console.log(4);&#125;).then(() =&gt; &#123; console.log(5);&#125;);console.log(3); test 2 12345678910111213141516console.log(1);setTimeout(() =&gt; &#123; console.log(5);&#125;, 0);new Promise(resolve =&gt; &#123; console.log(2); resolve();&#125;).then(() =&gt; &#123; setTimeout(() =&gt; console.log(6), 0);&#125;).then(() =&gt; &#123; console.log(4);&#125;);console.log(3); test 3 12345678910111213141516console.log(1);setTimeout(() =&gt; &#123; Promise.resolve().then(() =&gt; console.log(5));&#125;, 0);new Promise(resolve =&gt; &#123; console.log(2); resolve();&#125;).then(() =&gt; &#123; setTimeout(() =&gt; console.log(6), 0);&#125;).then(() =&gt; &#123; console.log(4);&#125;);console.log(3); test 4 12345678910111213141516console.log(1);setTimeout(() =&gt; &#123; Promise.resolve().then(() =&gt; console.log(6));&#125;, 0);new Promise(resolve =&gt; &#123; console.log(2); resolve();&#125;).then(() =&gt; &#123; Promise.resolve().then(() =&gt; console.log(4), 0);&#125;).then(() =&gt; &#123; console.log(5);&#125;);console.log(3); 以上所有示例都按 1 2 3 4 5 6 的顺序输出。 最后一例中，关于 4 和 5 的输出顺序，还是有点“滑稽”。 Vue nextTickv2.4.412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Defer a task to execute it asynchronously. */export const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // "force" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; // fallback to setTimeout /* istanbul ignore next */ timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) &#125; &#125; return function queueNextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve = resolve &#125;) &#125; &#125;&#125;)() 可以看到，Vue 优先使用 Promise.resolve() 来实现 nextTick，对于不支持 Promise 的设备则使用 MutationObserver，再次之则降级为 setTimeout。 v2.5.17123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const callbacks = []let pending = falsefunction flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;// Here we have async deferring wrappers using both microtasks and (macro) tasks.// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where// microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690) or even between bubbling of the same// event (#6566). However, using (macro) tasks everywhere also has subtle problems// when state is changed right before repaint (e.g. #6813, out-in transitions).// Here we use microtask by default, but expose a way to force (macro) task when// needed (e.g. in event handlers attached by v-on).let microTimerFunclet macroTimerFunclet useMacroTask = false// Determine (macro) task defer implementation.// Technically setImmediate should be the ideal choice, but it's only available// in IE. The only polyfill that consistently queues the callback after all DOM// events triggered in the same loop is by using MessageChannel./* istanbul ignore if */if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if (typeof MessageChannel !== 'undefined' &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]')) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; /* istanbul ignore next */ macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;// Determine microtask defer implementation./* istanbul ignore next, $flow-disable-line */if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() microTimerFunc = () =&gt; &#123; p.then(flushCallbacks) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // "force" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125;&#125; else &#123; // fallback to macro microTimerFunc = macroTimerFunc&#125;/** * Wrap a function so that if any code inside triggers state change, * the changes are queued using a (macro) task instead of a microtask. */export function withMacroTask (fn: Function): Function &#123; return fn._withTask || (fn._withTask = function () &#123; useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res &#125;)&#125;export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true if (useMacroTask) &#123; macroTimerFunc() &#125; else &#123; microTimerFunc() &#125; &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 【参考资料】 http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html#nexttick-的实现 https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再也不想写表单了]]></title>
    <url>%2Fblog%2F2018%2F10%2Fno-form-any-more.html</url>
    <content type="text"><![CDATA[一 产品：小哥哥在么？我想临时加个小小小小的需求~~ 小明：不在。 产品：很简单的哈，就在原来的页面上加个小功能…… 产品：帮帮忙，求你了哥哥，我请你吃星爸爸~ 小明：先说吧。。要是改动大的话，请海底捞都没用。。 产品：不会的！就是在我们的活动后台页面上，想加个活动预告的功能，大概这个样子…… 产品：是不是很简单哈~ 小明：哦。还行吧 于是小明打开了项目，找到了相应的页面，Oh shit！ 以前的代码谁写的，写完就跑路了么！还好现在加的“活动预告”功能跟其他部分不相干，可以单独抽离出去。小明感觉机智如我，很快就写好了，简直是空手薅羊毛。 小明：加好了（来杯抹茶拿铁） 二 产品：小哥哥在么？昨天加的小需求后来业务说需要有个“立即生效”的按钮。。。 产品：实在对对对对对不起 &gt;_&lt; 我在原来的图上稍微加了点，求哥哥帮忙改一下下 产品：是这样的，“立即生效”选“是”时，选日期的就不要了，选“否”时才有“生效日期” …… 产品：哥 你看到了吗？ 小明：你说完了吗？全都说完我再一起改 产品：说完了！谢谢 O(∩_∩)O 由于小明先见之明，一开始就把“活动预告”部分抽离出去了，所以根本不用 care 其他代码，也很快就改好了。 三 产品：小哥哥……我已经跪下了 产品：又跟业务聊了，他们自己一开始都没理清，现在捋清楚了 产品：1. 类型为”拉新“与”冲单“时，活动还支持按条件的生效方式，条件支持”活动人数“、”活动天数“、”峰值“（三者为且的关系） 产品：2. 类型为”回馈“时，活动只支持立即生效和按时间生效两种方式 产品：不会再改了！不然我就请吃海底捞 小明：再见。 日常在日常工作中，经常出现上面故事中的影子，公司的业务不会停下，需求必然要跟着业务而不断演化，一个看似简单的页面表单也会变得越来越臃肿。 项目交接了N手，各人都按各自的风格写代码；产品也交接了好几手，各按各的套路提需求。根本原因是代码的维护成本与业务不断变化之间的矛盾。 正如上面故事中的例子，再往后发展，有可能“活跃人数”的条件需要支持多个区间，甚至出现“生效条件”与表单中的其他项发生耦合，需求千变万化，怎么预知得了。 究其原因，就是当表单中出现联动的需求，或者跨行之间发生制约关系时，表单代码的复杂度就会上升，随着业务需求的演变，如果代码处理的不好，会变得越来越难维护。 配置型表单表单本质上是什么？表单用来承载业务需求的交互逻辑，表单的最终目的是提交一些特定格式的数据。那么从其目的出发，从数据的角度，表单就是一堆 key 与 value 的映射，key 就是接口调用时的参数，value 就是 key 所对应的表单控件的用户输入值。 理想状态下，可以用如下的 JSON 结构来定义一个表单。 数组中的每项都对应表单中的一项，type 即表单控件的类型，key 即表单提交时的数据参数。如上图，表单提交时会发送以下数据 12345&#123; act_type: '', instant: '', range: []&#125; 一个 key 到底会输出什么类型的数据，取决于它对应的表单控件是什么。 应对联动需求上面说到表单中的联动是罪恶的根源，在 JSON 配置中能否处理好这个关系呢？我们先翻下业务项目中的代码，是否经常出现这样随意的代码。 以 Vue 为例，v-if 条件渲染确实是处理联动的办法，但满屏的 v-if 以及枚举值的 magic number，动不动就几百行的表单，模板中又耦合着逻辑，维护起来真是个又脏又累的活儿。 根据实际需求，整理了下常见联动的套路 第1类：A 为特定值时，B 不显示；或 A 为特定值时，B 才显示 第2类：A 为特定值时，B 只能为特定范围内的值（或不能为某些值） 第3类：A 为特定值时，B 也只能为特定值 借鉴 v-if 的思想，在配置型表单的 JSON 中也可以尝试条件渲染。 1234567891011121314151617181920[ &#123; title: '活动类型', key: 'act_type', type: 'radio' &#125;, &#123; title: '立即生效', key: 'instant', type: 'radio' &#125;, &#123; title: '生效日期', key: 'range', type: 'dates', ifRender(form) &#123; return form.instant == false; &#125; &#125;] 配置中的 ifRender 是一个函数，入参即当前表单的数据状态，可以在函数中判断渲染的条件，以达到与 v-if 等价的效果。通过这种方式，就可以实现第1类联动。 应对动态取值范围在上面的 JSON 配置中，其实省略了一点，就是单选控件的选项，它属于控件内部的属性，因此可以统一定义一个 props 字段来表示组件内部的属性。下面完整定义了产品最初需求中的“活动类型”这一行。 12345678910[ &#123; title: '活动类型', key: 'act_type', type: 'radio', props: &#123; options: &#123; 1: '拉新', 2: '冲单', 3: '回馈' &#125; &#125; &#125;,] 有了这个基础后，对于第2类联动，A 为特定值时，B 只能为特定范围内的值（或不能为某些值），就迎刃而解了。很容易想到，让 props 支持函数，入参同样是当前表单的数据状态。 对于需求3中，类型为”回馈“时，活动只支持立即生效和按时间生效两种方式，就可以通过以下 JSON 配置来定义清楚。 123456789101112131415161718192021[ &#123; title: '活动类型', key: 'act_type', type: 'radio', props: &#123; options: &#123; 1: '拉新', 2: '冲单', 3: '回馈' &#125; &#125;, &#123; title: '生效方式', key: 'effect_type', type: 'radio', props(form) &#123; const map = &#123; 1: '立即', 2: '按时间', 3: '按条件' &#125;; if (form.act_type === 3) &#123; delete map[3]; &#125; return &#123; options: map &#125;; &#125; &#125;] 当然你可能会嫌弃 magic number，那就定义个枚举常量好了。总的来说这样定义的表单联动逻辑，集中又清晰。 应对限制特定值细心的你可以会注意到，第3类联动还没法实现，A 为特定值时，B 也只能为特定值。 这种情况，我们先来看看原先业务代码中会怎么写。一般两种套路：1是 watch 表单状态中的 A 字段，当它为特定值时，将 B 字段也赋成特定值；2是监听 A 字段所对应表单控件的 change 事件，当它 change 成特定值时，将 B 字段也赋成特定值。可以想象，这两种代码给 B 赋值时与 B 的声明处都隔的比较远，而且每个人都有自己的习惯，有的人喜欢写在模板里，有的人喜欢写在逻辑里，有的人可能喜欢单独抽个函数。 在上面的配置型表单中，同样可以做这个事情，可以通过给 props 增加个 value 字段用来特指该表单控件的数据。 1234567891011121314151617181920212223242526[ &#123; title: '活动类型', key: 'act_type', type: 'radio', props: &#123; options: &#123; 1: '拉新', 2: '冲单', 3: '回馈' &#125; &#125; &#125;, &#123; title: '生效方式', key: 'effect_type', type: 'radio', props(form) &#123; const value; const map = &#123; 1: '立即', 2: '按时间', 3: '按条件' &#125;; if (form.act_type === 3) &#123; value = 1; &#125; return &#123; value: value, options: map &#125;; &#125; &#125;] 当然，除了通过 props 来限制特定值外，也可以设计个 watch 观察者回调函数来对表单数据状态中的某个字段来赋值，取决于这套 JSON 表单配置怎么设计。 小结通过 JSON 配置来定义一个表单是可行的，相较于以往的业务代码，省去了模板，不会出现模板与逻辑混在一起的情况。对于表单中令人讨厌的联动需求，列举了3类常见的联动套路，并且尝试了通过 JSON 配置来满足联动需求的可行性。 实现原理既然说配置型表单省去了模板，模板其实被屏蔽了，配置中的每个表单控件的 title 和 type 足以表达模板了。title 即表单一行中的 label，而 type 则映射到具体的组件，是 checkbox 还是 select。 使用姿势上面啰嗦了这么多配置型表单的 JSON 示例，我们希望封装一个表单，只需传入 JSON 配置。以 Vue 为例，希望可以这样指定表单。 1&lt;json-form v-model="formModel" :config="formItems"/&gt; 其中 formItems 就是上文介绍的 JSON 配置，是一个数组，数组中的每项代表一个表单控件。 映射到组件从表单配置中的 type 映射到一个真正的组件，是这套表单方案的核心。 为了降低基础组件的开发成本，我们可以先选择一套成熟的组件库，比如 Element，通过简单的 type 与组件 tag 的映射，就能实现组件映射。 123456789101112export default &#123; // 默认输入类型 text: &#123; // 对应到 Element 中的组件 tag component: 'el-input', // 传递给 Element 组件的默认 props props: &#123; clearable: true &#125; &#125;, // 省略...&#125; 如上，我们定义了一个映射表，key 即表单配置中的 type，例如 type: &#39;text&#39; 则会映射到 Element 中的 el-input 组件，并且这里给出的 props 会作为默认属性传递给 Element 中的相应组件。这样，就以一种低成本的方式实现了从表单配置 type 到真正的表单组件之间的映射。 Form 封装只有上面的映射表，还不够组成完整的表单，因为一个表单会包含多个组件，并且在上文介绍的几类联动也需要在表单层来实现。 好在 Vue 中有个神奇的动态组件，可以很方便的帮助我们生成映射后的组件。 1234567891011121314151617&lt;el-form :model="formModel"&gt; &lt;el-form-item v-for="(input, i) in formItems" v-if="input._ifRender" :key="input.key + '_' + i" :rules="input.rules" :prop="input.key || null" :label="input.title" &gt; &lt;component ref="component" :is="input.tag" v-model="form[input.key]" v-bind="input.props || &#123;&#125;" /&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; 如上代码所示，formInputs 是从表单接收到的 JSON config 转化而来，它会根据组件映射表得到了相应的组件 tag 和 props，并且处理条件渲染的配置 ifRender 函数。 1this.formInputs = (this.config || []).map(item =&gt; computeFormItem(item, this.formModel)) 可以看到核心就是这个 computeFormItem 函数，它将表单配置进行转换，并且以当前的表单数据 model 作为入参。 1234567891011121314151617181920212223242526272829function computeFormItem(&#123; config, form &#125;) &#123; // 返回结构体 const item = &#123; ...config &#125;; // 表单控件的类型 let type = item.type || 'text'; // 对应到组件映射表 let def = ElementMapping[type]; item.tag = def.component; item.props = merge(&#123;&#125;, def.props, item.props); // 获取动态 props if (isFunction(item.getProps)) &#123; item.props = Object.assign(&#123;&#125;, item.props, item.getProps(form)); &#125; // 条件渲染 item._ifRender = isFunction(item.ifRender) ? !!item.ifRender(form) : true; // 防止表单提交时存在多余 key if (!item._ifRender) &#123; delete form[item.key]; &#125; // form-item 配置 return item;&#125;; 它首先根据配置类型，读取组件映射表，得到真正的组件 tag，并合并配置中的 props、映射表中组件的默认 props，以及依赖表单 model 的动态 props（用于实现上文中第2类联动）。最后处理条件渲染，执行配置中的 ifRender 函数，得到一个布尔值，用以表单模板中 v-if 判断。 告别表单上文说配置型表单省去了模板，因为模板已经被标准化，并且被封装在了 Form 中，即下面的 &lt;json-form&gt; 1&lt;json-form v-model="formModel" :config="formItems"/&gt; 对使用者来说只需要写好 JSON 配置就可以了。由此带来的好处显而易见，那就是表单需求中的业务逻辑只需要关注数据层面，即某个表单控件对应的数据 key 是什么，以及它对应的组件类型。并且当处理表单联动需求时，只需在配置中写上一些函数，这样逻辑更集中，因为你不需要在原先的页面模板以及代码逻辑中寻找有哪些耦合了。 更远地来说，配置型表单可以轻松应对底层的变化。比如现在 Element 组件库需要升级大版本了，必然有不兼容的坑，你就不必在所有页面中翻来覆去地寻找到底哪些属性要改。只需要搞定封装后的 Form，在不兼容的 props 之间做一层映射，业务代码部分是无需改动的。 读到这里，是不是以为会有广告？是为了安利某个轮子😇 总结然而并没有…… 本文从实际的需求出发，讨论了配置型表单的可行性，并整理了常见的表单联动场景。通过配置型的表单可以降低业务代码的开发和维护成本。 已经在公司的后台业务中尝试了数十个页面，还有很多配置项及实现细节没有列出，比如扩展自定义组件、渲染自定义模板、表单生命周期以及表单 API 的设计等。 结合真实的业务场景，使用配置来组织表单甚至组织整个页面，是一条路子。它降低了代码的复杂度，却无形中提高了理解配置的复杂度。因为业务场景千变万化，众口难调，你必须在其中抽离出相似的东西，将其设计成配置。配置项既要通用，又不能限太死，必要时要能提供可自定义和扩展的方式。 配置的设计是最难的，也最容易纠结，真正去实现这么一套表单配置也是挺有意思的呢！]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toFixed 之坑]]></title>
    <url>%2Fblog%2F2018%2F09%2Fsafe-to-fixed.html</url>
    <content type="text"><![CDATA[保留几位小数，这在前端来 format 是很常见的。但直接之用 JavaScript 里数值的 toFixed 函数是有坑的。甩两个 bad case 看看： (1.005).toFixed(2) 为 “1.00”，应该是 “1.01” (4.05).toFixed(1) 为 “4.0”，应该是 “4.1” 结论就是：前端对敏感型数字的四舍五入展示，如价格、收入、跟金额有关的，千万不要直接 toFixed，以免被客户追究。 原理JS 语言诟病，浮点数本身存在精度问题，举个例子：0.1 + 0.2 !== 0.3 那问题来了，保留2位小数，能否先乘 100，然后四舍五入取整后再除 100 呢？ 不妨试下 Math.round(1.005 * 100) / 100 结果也不对，因为 1.005 * 100 的结果是 100.49999999999999。而 0.1 + 0.2 的结果是 0.30000000000000004 ，这就很迷了，什么时候会比正确值略大，什么时候又会略小，看不到规律。 其实这要跟浮点数的二进制存储有关了，计算机是无法精确地表示任意浮点数的。有的数能用 (1/2)^n 的相加表示的话，那这个浮点数就是精确的，比如 0.5, 0.75, 0.875。否则由于浮点数存储有位数限制，肯定是不精确的。 JS 里的 number 类型只有 16 位精度，所以浮点数运算捉襟见肘。 另一方面，JS 对超长的整数也表示不了，比如很多系统里的订单号，在后端会用 Long 来表示，数字超过 16 位时在 JS 里就没法精确表示了。30001519369635544130 这个大数字末几位就会被抹成零，就会导致前端看到的订单号与后端实际单号不一致。所以超过 16 位的大数字，一定要求后端以 String 来给到前端。 实现思路是，如果保留2位小数，那先乘 100 后四舍五入取整，然后把小数点加在倒数第 2 位之前。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import * as MAX_SAFE_INTEGER from 'core-js/library/fn/number/max-safe-integer';import * as MIN_SAFE_INTEGER from 'core-js/library/fn/number/min-safe-integer';const NUM_REG = /^-?\d+(\.\d+)?$/;export function isSafeNumber ( val: string | number): boolean =&gt; &#123; const num = Number(val); return NUM_REG.test(String(val)) &amp;&amp; num &lt;= MAX_SAFE_INTEGER &amp;&amp; num &gt;= MIN_SAFE_INTEGER;&#125;;/** * 安全的 toFixed 函数，解决浮点数 toFixed 的潜在问题 * * 例如 (1.005).toFixed(2) 为 "1.00" (应该是 "1.01") * * Inspired by https://github.com/camsong/blog/issues/9 */export function toFixed (num: number | string, digits?: number): string =&gt; &#123; if (!isSafeNumber(num)) &#123; return 'NaN'; &#125; digits = digits || 0; // 转为整数后再处理 只需取整后再补个小数点位置 let scale: number = Number(num) * Math.pow(10, digits); // 为什么是16位? Number.MAX_SAFE_INTEGER 只有16位 // (整数部分 + 小数部分) &lt;= 16 位时，可解决小数尾部 00001 和 99999 精度问题 scale = Math.round(parseFloat(scale.toPrecision(16))); // 从右向左的 bit 数组 const bits: string[] = String(scale).split('').reverse(); // 小数点的位置，并用 0 补齐 if (bits.length &lt;= digits) &#123; // 构造 (digits - bits.length) 个 0 的数组 const patches: string[] = new Array(digits - bits.length + 1).join('0').split(''); bits.splice(bits.length, 0, ...patches, '.', '0'); &#125; else if (digits &gt; 0) &#123; bits.splice(digits, 0, '.'); &#125; return bits.reverse().join('');&#125;; 测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import test from 'ava';test('should toFixed non-number', t =&gt; &#123; t.is(toFixed(null), 'NaN'); t.is(toFixed(''), 'NaN'); t.is(toFixed('1'), '1'); t.is(toFixed('1', 1), '1.0'); t.is(toFixed('-1.1', 2), '-1.10');&#125;);test('should toFixed normal number', t =&gt; &#123; t.is(toFixed(1), '1'); t.is(toFixed(1, 1), '1.0'); t.is(toFixed(1.1, 1), '1.1'); t.is(toFixed(1.1, 2), '1.10'); t.is(toFixed(1.12, 1), '1.1'); t.is(toFixed(1.15, 1), '1.2'); t.is(toFixed(0.101, 2), '0.10'); t.is(toFixed(0.109, 2), '0.11'); t.is(toFixed(0.0041, 3), '0.004'); t.is(toFixed(0.0049, 3), '0.005');&#125;);test('should toFixed big number', t =&gt; &#123; // MAX_SAFE_INTEGER 16位数字 t.is(toFixed(9007199254740991), '9007199254740991'); // 整数 + 小数 不能超过16位 t.is(toFixed(100719925474099, 1), '100719925474099.0'); t.is(toFixed(100719925474099.1, 0), '100719925474099'); t.is(toFixed(100719925474099.5, 0), '100719925474100'); // 整数 + 小数 不能超过16位 t.is(toFixed(1719925474099.005, 2), '1719925474099.01'); t.is(toFixed(1719925474099.101, 2), '1719925474099.10');&#125;);test('should toFixed abnormal float number', t =&gt; &#123; // 0.1 + 0.2 = 0.30000000000000004 t.is(toFixed(0.1 + 0.2, 1), '0.3'); t.is(toFixed(0.1 + 0.2, 2), '0.30'); // 0.1 + 0.7 = 0.7999999999999999 t.is(toFixed(0.1 + 0.7, 1), '0.8'); t.is(toFixed(0.1 + 0.7, 3), '0.800'); // 0.69 / 10 = 0.06899999999999999 t.is(toFixed(0.69 / 10, 3), '0.069'); t.is(toFixed(0.69 / 10, 4), '0.0690'); // (4.05).toFixed(1) = '4.0' t.is(toFixed(4.05, 1), '4.1'); // (1.005).toFixed(2) = '1.00' t.is(toFixed(1.005, 2), '1.01');&#125;); 最后，在前端 JS 里最好别做数值计算，如果一定要计算，可以使用 number-precision 库。 还有，价格这种字段，无论如何都不要在前端计算！做一个有底线的前端。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018未来在哪儿]]></title>
    <url>%2Fblog%2F2018%2F04%2Ffuture-rolls-on.html</url>
    <content type="text"><![CDATA[这并不是一篇畅想技术趋势的文章，文中虽然涉及一些，但更多是对自己工作的反思，在舒适区中感到了无尽的担忧和迷茫。 Origin回顾自己的学习经历，似乎涉及过很多面，但看着又像一片空白。 大三时迷上机器学习和游戏AI，喜欢看书，被各种预测模型惊艳到了。结果呢，死于数学功底差，越往深越啃不动，遂卒。。 大四时才知道 web 前端，当时的 web 框架特指 web 后端框架，几乎是 Structs 和 Spring 的一片天。蜻蜓点水，没有深入过框架原理。 读研后 all in 前端，给导师做一些教学管理和考试系统。靠着这个系统有幸得到了业内顶尖前端团队的实习机会，恰逢拥抱变化，没能留下，其实自己也觉得太累了。 当时是2015年，前端都知道的技术大爆发之年，ES6、React Native 都在2015年火了。当时实习时，团队内已经有不少人在开始 RN 的探索踩坑，我也尝试学过，只因自己基础还不够扎实，应对日常业务还不能游刃有余，一边还在学习别人优秀的代码，一边还要再尝试学习有点跨界的 RN，真心力不从心。 前端 2015 年的转折点，就这么从身边擦过。当时会 React 和 RN 的就能找到很好的工作。实习短短三个月就回校了，终究敌不过惰性，也没有逼迫自己去学。。 研三最后一年，接了个导师与外部合作的试水项目，网站安全监控，爬虫 + 漏洞扫描，从零开始做出了一版 demo，对自己独立分析的能力提升挺大的，但安全方面然后也没有去深挖 &gt;_&lt; 毕业第一份工作，重构了组件库和前端仓库，陷入了舒适区以及老项目历史包袱的矛盾中，看不到自己的成长，待了一年后决定走了。 第二份工作，一个快速迭代的横向团队，需要在业务的重要性、紧急性以及开发代价间权衡，学会了 Vue，确实比 React 更适合这类有N多子项目并且要快速上手的场景。渐渐地，也开始步入了舒适区。 回顾一切，又回到了原点，惰性与自驱的矛盾一直存在。 Smash前端火了三四年了，也赶上了移动互联网时代一起蓬勃。过去谈论大数据的，现在谈论AI了；过去说移动开发的，现在说大前端了。变化是一直存在的，跟上变化是必然的，否则相当于主动退出。 要想突破原点，我认为有以下几个入口 1、极致体验目前大前端风下，已不再将 Native 端与 web 端强拆分了，大家的目标都很一致。 一是，给 C 端用户更好的体验，管TM是 native 还是 web 呢，谁体验好、谁灵活，就用谁的实现（当然这肯定具体场景具体分析） 二是，既然 native 与 web 抱团了，那能不能只写1套代码（或者80%以上的代码都用1套），让它在 ios、android、web 上都有很好的体验。过去讲 PC 与 mobile web 1套代码响应式，现在更多谈论的是 native 与 web 真正的跨终端一致。Write once, run everywhere 2、工程效率工程效率也可以从 C 端和 B 端分别展开，上面说的跨终端一致（Write once），也是在 C 端的工程效率体现。 在实际的工作中，业务更多的会在 B 端（或者是管理端），为了能够快速响应业务决策的变化，我们必须要有很强大的后台系统可以灵活的配置不同的决策。所以工程效率方面更多会体现在： 后台管理页面：主要都是 CRUD 操作，会包含业务逻辑的制约关系，希望这类页面可以自动化生成 业务监控系统：从数据源到数据清洗处理，再到字段映射关系，再直接在前端出报表，希望这类 BI 需求也可以自动化生成 前端发布系统：结合上面说的前端 write once，希望前端的发布流程是极其简洁的，并可以快速回滚，毕竟改前端比改后端快的多 还有很多效率方面的点，比如开发效率、开发体验，也是值得提升的方面。 3、跨界交叉从移动时代到大前端，从前端到全栈，从大数据到AI，我觉得下一个引爆点就在于跨界的融合，尤其是跟上浪潮的跨界。 FEer 已经具备了很多得天独厚的技能树 Nodejs 延伸了做服务的能力，Golang 又将后端性能提升了一个台阶 React 体系占据了前端框架的半壁江山，三大框架将会变成 framework 界的 BAT 3D、VR 也是今后交互的趋势，相信电影《头号玩家》里的场景早就不是科幻，而是老美们切切实实在研究的东西 物联网、城市智慧网，是国家创新的一个大方向，与百姓最贴近的落地点应该是智能穿戴设备，AI 也在悄悄地渗透到前端，今后“前端”的范畴更广，“终端”也就是今后的前端。 前端+全栈，前端+跨终端，前端+交互，前端+AI，前端+安全，等等任何一种结合，相信都是值得投资自己的，在未来肯定不会倒下。 另外补充一点，前瞻性的技术押宝，是需要“熬”的，Golang 出现了好多年后去年才开始真正的火，真不得不佩服七牛-许式伟的技术眼光。再者，交互方式上需要熬的更久，就举现在手机触摸交互，早在1990s 年代老美就在实验了，到商用再到量产，经历了近20年。。。 JobsJobs 指我们每天的工作，这里引用乔布斯2005年在斯坦福大学的演讲来灌个鸡汤 You can’t connect the dots looking forward, you can only connect them looking backwards. Believing that the dots will connet down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path, and that will make all the difference. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. 吸收各种 dots 不代表自己每个点上都要成为 top，而是为了收集更多的信息，你获得的信息越多，今后能创新的点也就越多。相信这就是乔老爷子设计出的产品独一无二的原因。 【5.5更新】 今天看了 FDConf 官网 总结了前端技术从2011年后的变化 11 年，看齐标准，关注 Web 性能12 年，响应式开发，工程化推进13 年，爆发式增长，百花齐放14 年，移动端的崛起，HTML5 和 ES6 落地15 年，观念的转变，步入前端工业化生产16 年，后端服务化，云数据，云安全17 年，端的融合，栈的融合。 — 摘自FDConf 2018，我觉得将会是：前端赋能，从跨端到跨界。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel preset ≠ polyfill]]></title>
    <url>%2Fblog%2F2018%2F04%2Fbabel-preset.html</url>
    <content type="text"><![CDATA[之前一直无脑用着 cli 脚手架，用着默认生成的配置，没有去仔细看 Babel 文档。直到最近接入了前端报错监控后，才发现了许多问题。这里整理下关于 babel preset 与 polyfill 的一些点 ES6ES6 既是一个历史名词，也是一个泛指，含义是 ES5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等。—— 引自ECMAScript 6 入门 ES6 的第一个版本，于 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 语法提案的 5 个阶段 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） Babel plugins1、babel 6.x 之后取消了供浏览器直接使用的版本（之前是 browser.js，可以在浏览器中对 ES6 代码进行转换，但很低效），现在要求必须在 build 过程将 ES6 转换好。 2、babel 根据 .babelrc 文件的约定来工作，babel 默认是啥都不做的，必须指定各种 plugins，并且通常一个 plugin 只做一件事。比如 transform-es2015-for-of 就只做 for…of… 语法的处理。非严格地来说，这种处理我们也称之为“编译”。 3、由于 ES6 涉及的语法糖非常多，而且有些还只在特定 stage 的提案中，所以需要 presets 来约定一个 plugins 的集合，免去我们配置一大堆 plugins。 Babel presetsES2015 preset：也就是我们常说的 ES6 相关方法，包含以下 plugins check-es2015-constants // 检验const常量是否被重新赋值 transform-es2015-arrow-functions // 编译箭头函数 transform-es2015-block-scoped-functions // 函数声明在作用域内 transform-es2015-block-scoping // 编译const和let transform-es2015-classes // 编译class transform-es2015-computed-properties // 编译计算对象属性 transform-es2015-destructuring // 编译解构赋值 transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性 transform-es2015-for-of // 编译for…of transform-es2015-function-name // 将function.name语义应用于所有的function transform-es2015-literals // 编译整数(8进制/16进制)和unicode transform-es2015-modules-commonjs // 将modules编译成commonjs transform-es2015-object-super // 编译super transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数 transform-es2015-shorthand-properties // 编译属性缩写 transform-es2015-spread // 编译展开运算符 transform-es2015-sticky-regex // 正则添加sticky属性 transform-es2015-template-literals // 编译模版字符串 transform-es2015-typeof-symbol // 编译Symbol类型 transform-es2015-unicode-regex // 正则添加unicode模式 transform-regenerator // 编译generator函数 ES2016 preset：只将 ES2016 中新出现的语法转换成 ES2015 的写法 transform-exponentiation-operator // 编译幂运算符 ES2017 preset：只将 ES2017 中新出现的语法转换成 ES2016 的写法 syntax-trailing-function-commas // function最后一个参数允许使用逗号 transform-async-to-generator // 把async函数转化成generator函数 此外，还有用于支持 React 的 React preset，还有 Env preset 用来根据你需要支持的浏览器环境来决定到底需要引入多少 plugins，浏览器支持度的细节可参考这里，以及 compat-table 同前面列出的语法提案的 5 个阶段，也有根据 stage 划分的 preset，stage 4 指已 Finished 的部分，然而没有 stage-4 的 preset，因为它等同于 [&#39;es2015&#39;, &#39;es2016&#39;, &#39;es2017&#39;] 的 presets。 Stage 3 preset transform-object-rest-spread // 编译对象的解构赋值和不定参数 transform-async-generator-functions // 将 async generator function 和 for await 编译为 es2015 的 generator 注：trailing-commas, async, exponentiation will be removed in the next major since they are stage 4 already Stage 2 preset syntax-dynamic-import transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016) Stage 1 preset transform-export-extensions // 编译额外的exprt语法，如 export * as ns from &#39;mod&#39; 细节可以参考这里 注：transform-class-constructor-call 在 Babel7 中会被移除 Stage 0 preset transform-do-expressions // 编译do表达式 transform-function-bind // 编译bind运算符，也就是:: 由于 stage 0 ~ 4 是语法提案从开始到定案的过程，因此 stage 0 会包含更多的语法糖，stage 4 =&gt; 3 =&gt; 2 =&gt; 1 =&gt; 0 是逐渐增量的过程。 plugins VS presets有些 plugins 是 presets 中没有提供的，这时就配合着使用，需要单独引入 plugins transform-runtime 强烈推荐 transform-remove-console plugins / presets 编译顺序 plugins 优先于 presets 进行编译。 plugins 按照数组的 index 增序进行编译。 presets 按照数组的 index 倒序进行编译（因为作者认为大部分人会把 presets 写成 [&quot;es2015&quot;, &quot;stage-0&quot;] ） Babel polyfill1、Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API。比如Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及在 ES5 全局对象上新增的方法（如 Array.from） Babel 不会转码这些方法，必须使用 babel-polyfill，为当前环境提供一个垫片。 2、Babel 默认不转码的 API 非常多，详细清单可以查看 babel-plugin-transform-runtime 模块的 definitions.js 文件。 3、polyfill 的使用姿势，有以下3种 使用方式 优点 缺点 在&lt;script&gt;前插入 babel-polyfill 的CDN文件 大而全 打包过程无法参与，无法做 tree shaking 优化 在 webpack entry 中第一个插入 babel-polyfill 大而全 打包后文件体积增大 在入口文件引入 core-js 自行取所需 最小化 以后会不断追加所需，容易遗漏]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的“多继承”(2)]]></title>
    <url>%2Fblog%2F2018%2F03%2Fmulti-inheritance-2.html</url>
    <content type="text"><![CDATA[首先 JavaScript 中不存在多继承，并且也不推荐使用继承。如果你也这么认为的话，那笔者的观点也就写完啦 233333…. 如果还想回顾下 JavaScript 中“继承”的前世今生，以及对“多继承”的讨论，不妨看下去。 （接上一篇） 试试多继承贪心是人之常情，有了“继承”后，我们就会想要“多继承”。即使在后端语言中，也没有几个语言能真正实现多继承，笔者只知道 C++ 和 python 提供了多继承的语法，而像 Java 只允许继承一个父类，但可以同时 implements 多个接口类，也算一种变相的多继承吧。 多继承要考虑的问题多继承并没有想象的那么美好，首先是对 instanceof 提出了更高的要求 123456789class A &#123;&#125;class B &#123;&#125;// 假定有支持多继承的语法class C extends A, B &#123;&#125;// 那么 C 的实例对象，应该同时也是 A 和 B 的 instancelet c = new C()c instanceof C // truec instanceof A // truec instanceof B // true 如上示例，在多继承中必须将所有的父类标识记录在子类中，才能让 instanceof 实现上面的效果。而 JavaScript 中只有 prototype 链，该死的还约束了一个对象只能指定一个 prototype，所以还得另外想办法去模拟 instanceof 这还不算啥，请看下一张图 这是多继承中典型的问题，称为 Diamond Problem，当 A, B, C 中都定义了一个相同名称的函数时，而在 D 的实例对象中调用这个函数时，究竟应该去执行谁。。。 间接多继承先退而求其次，我们借鉴了 Java 中的思路，实际只继承一个类，通过其他方式将其他类的功能融入。Java 中可以用 Interface 约束一个类应该拥有的行为，当然 JavaScript 也可以这么做，实现 interface 的语法糖，检查“类”中有没有重写 interface 中的所有函数。但这样的话，interface 除了做校验之用，没有实际意义，不如直接 mixin 的方式来的实在。 12345678910111213141516171819202122232425262728293031323334353637383940const mixinClass = (base, ...mixins) =&gt; &#123; const mixinProps = (target, source) =&gt; &#123; Object.getOwnPropertyNames(source).forEach(prop =&gt; &#123; if (/^constructor$/.test(prop)) &#123; return; &#125; Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop)); &#125;) &#125;; let Ctor; if (base &amp;&amp; typeof base === 'function') &#123; Ctor = class extends base &#123; constructor(...props) &#123; super(...props); &#125; &#125;; mixins.forEach(source =&gt; &#123; mixinProps(Ctor.prototype, source.prototype); &#125;); &#125; else &#123; Ctor = class &#123;&#125;; &#125; return Ctor;&#125;;class A &#123; methodA() &#123;&#125;&#125;class B &#123; methodB() &#123;&#125;&#125;class C extends mixinClass(A, B) &#123; methodA() &#123; console.log('methodA in C'); &#125; methodC() &#123;&#125;&#125;let c = new C();c instanceof C // truec instanceof A // truec instanceof B // false 这样就简单模拟了间接多继承，通过构造一个中间类，让中间类直接继承 A，并且 mixin 了 B 的原型成员，然后再让 C 去继承这个中间类。由于 B 是通过 mixin 方式浅拷贝了一份，B.prototype 并不在 C 的原型链上（C.__proto__.__proto__），所以 c instanceof B 为 false。 要想修正 instanceof，只能自己另外实现一套 isInstanceOf() 的逻辑，在继承时将所有的父类引用记录下来，再去比对。 MRO算法针对多继承考虑的第2个问题，前面提到的 Diamond Problem，需要引入一个定义。 Method Resolution Order (MRO) 指的是在继承结构中确定类的线性顺序，例如 C =&gt; B =&gt; A 表示 C 继承 B，B 继承 A，那么 C 的 MRO 就是 C B A，也就意味着当调用 C 实例中的一个函数时，会按照 C B A 的优先级顺序去“寻找”该函数。在单继承的结构中自然没有问题，而在多继承中 MRO 发挥着其作用。 常用的C3算法就是用来计算 MRO，在 python 文档中有对其的完整描述，这里用一个例子简述下算法流程。 假设现在有这样的多继承结构 首先引入类的线性顺序的表示方法，在上图中可以看到 B =&gt; Y =&gt; O 这一部分是单继承的结构，显然 B 的 MRO 为 B Y O，记为 L(B) = BYO 然后还要引入几个符号，在 MRO 的线性顺序中，用 head 表示第一个元素，用 tail 表示余下部分。例如，B Y O 中的 head 就是 B，tail 则是 Y O。MRO 中只有一个元素，如图中的 O 元素，head 为O，tail 则是空。 接下来是最关键的，图中 A 的 MRO 记为 L(A(X, Y))，A(X, Y) 表示 A 同时继承了 X 和 Y，那么 L(A(X, Y)) = A + merge(L(X), L(Y), XY) 其中 merge 的规则如下 12345取出第一个序列的 head如果，该 head 不在其它序列的 tail 中 则把这个 head 添加到结果中并从所有的序列中移除它否则，用下一个序列的 head 重复上一步直到所有序列中的所有元素都被移除（或者无法找到一个符合的head） 最后我们来计算下上图中各个类的线性顺序 123456789101112131415L(O) = OL(X) = X + L(O) = XOL(Y) = Y + L(O) = YOL(A) = A + merge(L(X), L(Y), XY) = A + merge(XO, YO, XY) = AX + merge(O, YO, Y) = AXY + merge(O, O) = AXYOL(B) = B + L(Y) = BYOL(C) = C + merge(L(A), L(B), AB) = C + merge(AXYO, BYO, AB) = CA + merge(XYO, BYO, B) = CAX + merge(YO, BYO, B) = CAXB + merge(YO, YO) = CAXBYO 上述多继承结构的 python 示例可参见 https://glot.io/snippets/ez5bqslav2 输出了 C 这个类的 MRO 即 C A X B Y O 当然C3算法也有 bad case，会导致上述的 merge 在中途失败，也就是无法求出 MRO 的 case。关于 MRO 的更多细节可参考 https://www.python.org/download/releases/2.3/mro/ 总之不推荐设计出过于复杂的多继承结构 =_= 模拟多继承有了上面的基础后，我们来模拟实现下多继承： 为每个“类”提供独立的 isInstanceOf() 函数以解决 instanceof 的问题 同时引入 Method Resolution Order (MRO) 的C3算法，将每个“类”的 MRO 线性序列存在 meta 数据中 将多继承中的第一个父类，使用原型链的方式继承，而剩下的父类则使用 mixin 的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const mixinProps = (target, source) =&gt; &#123; Object.getOwnPropertyNames(source).forEach(prop =&gt; &#123; if (/^(?:constructor|isInstanceOf)$/.test(prop)) &#123; return; &#125; Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop)); &#125;)&#125;;const mroMerge = (list) =&gt; &#123; if (!list || !list.length) &#123; return []; &#125; for (let items of list) &#123; let item = items[0]; let valid = true; for (let items2 of list) &#123; if (items2.indexOf(item) &gt; 0) &#123; valid = false; break; &#125; &#125; if (valid) &#123; let nextList = []; for (let items3 of list) &#123; let _index = items3.indexOf(item); if (_index &gt; -1) &#123; items3.splice(_index, 1); &#125; items3.length &amp;&amp; nextList.push(items3); &#125; return [item, ...mroMerge(nextList)]; &#125; &#125; throw new Error('Unable to merge MRO');&#125;;const c3mro = (ctor, bases) =&gt; &#123; if (!bases || !bases.length) &#123; return [ctor]; &#125; let list = bases.map(b =&gt; b._meta.bases.slice()); list = list.concat([bases]); let res = mroMerge(list); return [ctor, ...res];&#125;;const createClass = (parents, props) =&gt; &#123; const isMulti = parents &amp;&amp; Array.isArray(parents); const superCls = isMulti ? parents[0] : parents; const mixins = isMulti ? parents.slice(1) : []; const Ctor = function(...args) &#123; // TODO: call each parent's constructor if (props.constructor) &#123; props.constructor.apply(this, args); &#125; &#125;; // save c3mro into _meta let bases = [superCls, ...mixins].filter(item =&gt; !!item); Ctor._meta = &#123; bases: c3mro(Ctor, bases) &#125;; // inherit first parent through proto chain if (superCls &amp;&amp; typeof superCls === 'function') &#123; Ctor.prototype = Object.create(superCls.prototype); Ctor.prototype.constructor = Ctor; &#125; // mix other parents into prototype according to [Method Resolution Order] // NOTE: Ctor._meta.bases[0] always stands for the Ctor itself if (Ctor._meta.bases.length &gt; 1) &#123; let providers = Ctor._meta.bases.slice(1).reverse(); providers.forEach(provider =&gt; &#123; // TODO: prototype of superCls is already inherited by __proto__ chain (provider !== superCls) &amp;&amp; mixinProps(Ctor.prototype, provider.prototype); &#125;); &#125; mixinProps(Ctor.prototype, props); Ctor.prototype.isInstanceOf = function(cls) &#123; let bases = this.constructor._meta.bases; return bases.some(item =&gt; item === cls) || (this instanceof cls); &#125; return Ctor;&#125;; 接着来测试一下如图3中的多继承结构 123456789101112131415161718192021222324252627const O = createClass(null, &#123;&#125;);const X = createClass([O], &#123;&#125;);const Y = createClass([O], &#123; methodY() &#123; return 'Y'; &#125;&#125;);const A = createClass([X, Y], &#123; testName() &#123; return 'A'; &#125;&#125;);const B = createClass([Y], &#123; testName() &#123; return 'B'; &#125;&#125;);const C = createClass([A, B], &#123; constructor() &#123; this._name = 'custom C'; &#125;&#125;);let obj = new C();console.log(obj.isInstanceOf(O)); // trueconsole.log(obj.isInstanceOf(X)); // trueconsole.log(obj.isInstanceOf(Y)); // trueconsole.log(obj.isInstanceOf(A)); // trueconsole.log(obj.isInstanceOf(B)); // trueconsole.log(obj.isInstanceOf(C)); // trueconsole.log(obj.testName());console.log(obj.methodY()); 以上代码仅供学习，还有很多不足，比如构造函数中只能调用自身的 constructor 函数，无法调用父类的constructor。这是由于 JavaScript 限制了无法通过 X.prototype.constructor.apply() 的方式调用其他类的构造函数（constructor 只能在 new 的时候调用），想绕开这个问题的话，只能换个函数名，叫 initializtion、init 之类的名字都行。 demo 代码在这里，多改变下参数试试，尝试理解前面所说的 C3 MRO 算法。 存在的问题上面的代码，为了模拟多继承，只将第一个父类放入了子类的原型链中，而其他父类只能通过 mixin 的方式将其 prototype 中的属性拷贝到子类的 prototype 中。这受限于 JavaScript 原型链的机制，即图1中 __proto__ 只能指向一个目标。所以既然这样实现的，肯定是与真正的多继承相悖的，像 C++ 中有虚函数表的机制，在多继承中调用函数时，会去查表找出真正的函数地址。而我们模拟出的 JavaScript 多继承，是将所有父类中的函数都揉到了一个 prototype 中（只不过按照 MRO 优先级顺序来依次揉入）。 仔细看上面代码的话会发现，c.testName() 输出的与 Method Resolution Order 中所述的算法不符。在那一节中，我们知道 C 的 MRO 应该为 C A X B Y O，示例代码中按理来说应该优先调用 A 中的 testName() 函数，实际却输出了”B”……卧槽，这代码有毒的吧？？ 123456789101112131415// inherit first parent through proto chainif (superCls &amp;&amp; typeof superCls === 'function') &#123; Ctor.prototype = Object.create(superCls.prototype); Ctor.prototype.constructor = Ctor;&#125;// mix other parents into prototype according to [Method Resolution Order]// NOTE: Ctor._meta.bases[0] always stands for the Ctor itselfif (Ctor._meta.bases.length &gt; 1) &#123; let providers = Ctor._meta.bases.slice(1).reverse(); providers.forEach(provider =&gt; &#123; // TODO: prototype of superCls is already inherited by __proto__ chain (provider !== superCls) &amp;&amp; mixinProps(Ctor.prototype, provider.prototype); &#125;);&#125; 注意代码里有句 (provider !== superCls) 的过滤，你可以把它去了再试下 demo。。笔者这里也纠结，因为 superCls 是第一个父类，已经在原型链上继承了，而在根据 MRO 顺序 mixin 其他父类时，按理应该将第一个父类过滤掉。然而一旦加上了 (provider !== superCls) 条件后，其他父类 prototype 上的属性都被拷贝到了 Ctor.prototype 上，而第一个父类中的原型却在 Ctor 的原型链上，显然 Ctor.prototype 上的函数优先级更高。 那我们将这个条件干掉！然而仍有 bad case。。 因为它将所有父类中的 prototype 都拷贝到了自己身上（它明明不应该有的），而当别人再继承它时，别人会误以为它定义了那么多函数，就会出现函数覆盖时的顺序与 MRO 计算出的顺序不一致的问题了。 归根到底还是“没有查函数表”的锅！或者我们在使用方式上做强约束，多继承中的所有函数调用都必须经过统一的形如 invoke(methodName, args) 的接口，在 invoke 时根据 MRO 的优先级顺序，依次查找有无 methodName 的函数，再真正调用。 为什么不建议继承说了那么多，笔者的体会是不要想着继承，不要想着继承，不要想着继承。。。 JavaScript 本身就不是面向对象的语言，干嘛要让它做它不擅长的事情 =_= 虽然语法糖已经提供了“类”的支持，那是照顾有面向对象想法的人，但它本质上不同于其他语言中的继承。不要把他人的宽容当作放任的理由，能模拟继承就不错了，就别再惦记“多继承”了。 再回过头来想一想，我们为什么需要继承？继承是一种强耦合关系，到底是否有必要用继承，可以考虑下在应用场景中是否需要用父类型去接收子类型的实例，即子类向父类的向上转型。在 JavaScript 中不会出现这样的需求，应该更多使用组合的方式以代替继承，以及函数式编程也许是更好的方案。 总结本文从 JavaScript 对“类”的语言机制出发，回顾了随着语言的进步，“继承”在 JavaScript 中变得越来越方便。然后讨论了“多继承”时需要考虑的问题，介绍了 Method Resolution Order (MRO)，并尝试在 JavaScript 中模拟“多继承”。 然而，JavaScript 本质上不存在继承的概念，这种通过 prototype 模拟出来的“多继承”不会很完美，体验上比原生支持继承或多继承的语言要差的多。因此不要想着多继承，JavaScript 中也不建议使用继承。 【2018.4.4更新】 看了知乎网友的评论，推荐了一篇文章 How to use classes and sleep at night，读完后更是觉得以前自己使用多层继承（非多继承）是多么 naive 了，文中主要给出了这几点建议： 对外提供API时不要直接暴露 class。因为这样你不知道别人会怎么用你的类，会让你今后升级API时出现很多 break changes 不要使用多层继承。嗯…我在以往的工作中就这么做，最后陷入了找 bug 的坑中，都不知道真正执行的函数在哪一层 不要调用 super 中的函数，直接覆盖它们。again…我在以往的工作中也犯了同样的错误，为了重用 super 中的逻辑，但又有部分逻辑不同，不得不继续拆分更细粒度的函数，以满足可以复用 super。结果一样，最后陷入了找 bug 的坑中。。。 不建议对外提供类，即使不得以这么做，提供方也要做好类型校验和对“可见性”的保护，防止使用方滥用。要提供更加明确的API，让使用方传入一个函数作为参数来满足自定义需求，而不是让使用方来 override 尝试入坑 Functional Programming Good Night 参考资料You-Dont-Know-JS Java Doc - Polymorphism Python Doc - MRO C3 linearization Class declare in dojo]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的“多继承”(1)]]></title>
    <url>%2Fblog%2F2018%2F03%2Fmulti-inheritance-1.html</url>
    <content type="text"><![CDATA[首先 JavaScript 中不存在多继承，并且也不推荐使用继承。如果你也这么认为的话，那笔者的观点也就写完啦 233333…. 如果还想回顾下 JavaScript 中“继承”的前世今生，以及对“多继承”的讨论，不妨看下去。 苦苦追求的语法糖在ES6之前，在还没有使用 React, Vue 等框架之前，我们在做稍复杂的前端页面和组件时，会经常用模块化的思想去封装一些可复用的逻辑，会想着给 JavaScript 提供“类”的支持，再结合一些设计模式，就可以做出各种灵活的代码结构。 我们知道 JavaScript 中并不存在 class，存在的只是原型链，都是通过函数和 prototype 去封装一些东西来模拟“类”。可以说任何一个函数都可以被视为一个“类”，只要你愿意。 关于 prototype 不是本文的重点，笔者一直收藏了这张图经常用来给自己复习。 那些年，我们一直在等待“类”的语法糖。。。 模拟一个类在强类型的语言中，类是为了面向对象，就不得不提其三大特性【封装】【继承】【多态】 1234567891011121314151617181920212223var Book = (function() &#123; // 私有静态属性 var privateStaticAttribute = 0; // 私有静态方法 var privateStaticMethod = function() &#123;&#125;; // 构造函数 return function(props) &#123; // 私有属性 var title; // 私有方法 this.getTitle = function() &#123; return title; &#125;; this.setTitle = function(title) &#123;&#125;; &#125;&#125;)();// 公有静态方法Book.staticMethod = function() &#123;&#125;;// 公有方法Book.prototype.publicSharedMethod = function() &#123;&#125;; 这样的代码想必都很面熟，借鉴了强类型语言中的“类”的概念，既然是类，它除了封装一些属性和方法，还需要做到可见性的控制。由于 JavaScript 中没有可见性修饰符，只能用闭包来模拟 public 与 private。虽然比起 Java 中的类还有很多不足，但至少做到了一些封装，而且通常我们还可以建立命名规范，约定下划线开头的属性名或方法名为私有的。 有了【封装】之后，我们就要考虑【继承】了。JavaScript 也没有继承的机制，都是使用 prototype 去模拟，实现方式有很多，出现了各种各样的“继承”方法。原型式继承、类式继承，甚至模拟super关键字，提供 Class.extend()、this.super() 等便利的用法，都是运用闭包和 prototype 实现的 Syntactic sugar。这也就是过去 Prototype.js 这样的库对前端产生的影响。 而至于【多态】，这是只在强类型语言中需要考虑的，当无法在编译时确定一个对象的类型时，只能在运行时确定一个函数要从哪儿去获取。常见的应用场景是：用父类型的引用去接收子类型的对象，使用父类型中定义的函数去统一操作不同子类的对象，并且子类中可以覆盖父类中的函数。正巧 JavaScript 的弱类型特征，不存在编译时要确定类型，天然支持多态。 到了ES5后ES5有了Object.create()，让我们更便捷地使用原型继承，Object.getPrototypeOf、Object.setPrototypeOf 可以更自由地操控原型链。 123456789101112131415161718192021222324252627282930313233var Book = function(title) &#123; Object.defineProperty(this, 'title', &#123; writable: false, value: title &#125;);&#125;;Book.prototype.getTitle = function() &#123; return this.title; &#125;;var EBook = function(link) &#123; Object.defineProperty(this, 'link', &#123; writable: false, value: link &#125;);&#125;;EBook.prototype = Object.create(Book.prototype, &#123; download: &#123; writable: false, value: function() &#123; console.log('Start...'); &#125; &#125;&#125;);// 一定要修正 constructorEBook.prototype.constructor = EBook;// testingvar jsorz = new EBook('//jsorz.cn');console.log(jsorz instanceof Book);console.log(jsorz instanceof EBook);console.log(jsorz.constructor === EBook);console.log(jsorz.hasOwnProperty('getTitle') === false);console.log(Object.getPrototypeOf(jsorz) === EBook.prototype);console.log(Object.getPrototypeOf(jsorz).constructor === EBook); 注：Object.getPrototypeOf 返回的即图1中 __proto__ 的指向。 ES6中的继承在ES2015中有了 class 语法糖，有了 extends、super、static 这样的关键字，更像强类型语言中的“类”了。 12345678910111213141516171819202122class Book &#123; constructor(props) &#123; this._title = props.title; &#125; get title() &#123; return this._title; &#125; static staticMethod() &#123;&#125; toString() &#123; return `Book_$&#123; this._title &#125;`; &#125;&#125;class EBook extends Book &#123; constructor(props) &#123; super(props); this._link = props.link; &#125; set link(val) &#123; this._link = val; &#125; toString() &#123; return `Book_$&#123; this._link &#125;`; &#125;&#125; 上面的语法确实清晰简单了，我们再看下编译成ES5后的代码是怎样的~ 123456789101112131415161718192021222324252627282930313233343536var Book = function () &#123; function Book(props) &#123; _classCallCheck(this, Book); this._title = props.title; &#125; _createClass(Book, [&#123; key: "toString", // 省略... &#125;, &#123; key: "title", // 省略... &#125;], [&#123; key: "staticMethod", // 省略... &#125;]); return Book;&#125;();var EBook = function (_Book) &#123; function EBook(props) &#123; // 省略... &#125; _inherits(EBook, _Book); _createClass(EBook, [&#123; key: "toString", // 省略... &#125;, &#123; key: "link", // 省略... &#125;]); return EBook;&#125;(Book); 示例生成的代码可以用 Babel REPL 查看，可以看到 ES6 提供的 class 语法真的是 Syntactic sugar，本质上与我们用 ES5 甚至更早时模拟“类”与继承如出一辙。其中重点的 _inherits 函数如下： 1234567891011121314function _inherits(subClass, superClass) &#123; if (typeof superClass !== "function" &amp;&amp; superClass !== null) &#123; throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125; 小结JavaScript 很容易模拟一个“类”，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态。从最初去模拟一个“类”，到 ES5 提供更便捷的原型操控API，到 ES6 中提供更多“类”相关的关键字，都是在帮我们减小 JavaScript 中面向对象的使用成本，使它看起来像跟它没有半毛钱关系的 Java 语言。 虽然 JavaScript 中的“继承”并不是真正的继承，“类”也不是真正的“类”，相比 Java 肯定还有很多实现不了的地方，比如 abstract class、Interface 等，只能通过一些 tricky 的办法去模拟。因此 JavaScript 中所谓的“继承”，是为了方便程序员用面向对象的方式来组织代码。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合计数问题]]></title>
    <url>%2Fblog%2F2018%2F03%2Fmath-counting-question.html</url>
    <content type="text"><![CDATA[假设有 A、B、C 三种药丸，现在要从 A、B、C 三种药丸中取100粒进行调剂，规则如下： A、B、C 这三种药丸每种至少有1粒 不考虑药丸的顺序 同种药丸每粒都相同 问：药品调剂的组合共有多少种？ 排列组合首先回顾下排列 (Permutation) 与组合 (Combination) 的基本公式 $ P_n^k = C_n^k \times P_k^k = \frac{n!}{(n-k)!} $ 上面的药品调剂问题，需要转化下模型，先将“100粒”改为“5粒”，看下有没有规律 如图，准备好5个放药丸的盘子，再在盘子之间放入2块“隔板”，并规定在左起第1块隔板的左边都放 A，第2、3块隔板中间都放B，第3块隔板右边都放C。5个盘子共有4个间隙，因此组合数就是 $ C_4^2 $ 同理，换成“100粒”后，药品调剂的组合共有 $ C_{100-1}^{3-1} $ 种 三角形问题此问题来自 一个平庸的码农 下图中有多少个三角形？有没有什么好的计数策略 先尝试用组合计数来求解，如果每个点与其他所有点 都存在连线的话，那么三角形个数就容易算了，就是 任意3个点的组合数 - 3点在一条直线上的组合数 其中“任意3个点的组合数”就是 $ C_n^3 $ 而“3点在一条直线上的组合数”只要找出所有的直线，再对直线上的节点数求 $ C_k^3 $ 但是很遗憾，上图中不满足“每个点与其他所有点 都存在连线”。。。。 https://myst729.github.io/#/blog/articles/2016/counting-triangles/ 提供了一种巧妙的方法 将三角形做拓扑变换（Topology），即可用如下数据结构简单的表示图形中的点关系 123456[ ['A', 'A', 'A', 'A'], ['B', 'C', 'D', 'E'], ['H', 'G', 'F', 'E'], ['H', 'I', 'J', 'K']] 再遍历变换后的矩形，只要满足矩形的4个节点有且只有3个不相同的节点，即代表一个三角形 最后。。。答案是 24]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN License 更改]]></title>
    <url>%2Fblog%2F2018%2F02%2Fopen-source-license.html</url>
    <content type="text"><![CDATA[【News】两天前，React Native 将 License 改成了 MIT，详见Commit 这是半年来 Facebook 第二次修改 React 相关的协议了，此前饱受喷击的 BSD + Patents 没几天就认怂了。与之前的 Commit 类似，React Native 也打开了 MIT 的大门。 图片引用自 如何选择开源许可证？ MIT是和BSD一样宽松的许可协议，作者只想保留版权，而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>News</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本defer与async]]></title>
    <url>%2Fblog%2F2017%2F11%2Fscript-defer-async.html</url>
    <content type="text"><![CDATA[在之前一篇笔记中写到： defer 源自IE，保证执行顺序，都会到 domReady 后再执行 async 现代标准，不保证执行顺序，什么时候下载完就什么时候执行 现在就来具体展开解释下~ MDN介绍defer This Boolean attribute is set to indicate to a browser that the script is meant to be executed after the document has been parsed, but before firing DOMContentLoaded. This attribute must not be used if the src attribute is absent (i.e. for inline scripts), in this case it would have no effect. To achieve a similar effect for dynamically inserted scripts use async=false instead. Scripts with the defer attribute will execute in the order in which they appear in the document. async A boolean attribute indicating that the browser should, if possible, execute the script asynchronously. This attribute must not be used if the src attribute is absent (i.e. for inline scripts). If it is included in this case it will have no effect. Dynamically inserted scripts execute asynchronously by default, so to turn on synchronous execution (i.e. scripts execute in the order they were loaded) set async=false 划重点 defer 与 async 不适用于内联脚本，浏览器直接无视这个属性 没有 defer 或 async 时，浏览器遇到 &lt;script&gt; 就会立即加载并执行指定的脚本，“立即”指的是它是一个同步的过程，它会中断后续 html 文档的解析（直到 &lt;script&gt; 执行完后） 有 async 时，&lt;script&gt; 的加载与执行不会阻塞后续 html 文档的解析和渲染，即 &lt;script&gt; 是异步的、并行的。 有 defer 时，&lt;script&gt; 的加载也是与后续 html 文档的处理并行的，但是 &lt;script&gt; 的执行是在所有文档解析完成之后，且 DOMContentLoaded 事件之前才执行。 一图流 需要补充说明的是： 不管是什么 script，它执行时（非加载）一定是会阻塞 html 解析的，因为浏览器不知道 script 里有没有 document.write document.append 这样的改变文档结构的操作，所以浏览器肯定需要停下来等 script 执行完再继续解析文档。 当有多个 defer 脚本时，它们最后执行时是按照加载时的顺序执行的 而多个 async 脚本时，无法保证顺序，它们是按照”谁先加载完，就谁先执行“的规则 应用场景 首先养成好习惯，&lt;script&gt; 尽量都插在 &lt;body&gt; 的最后 脚本的并行加载，可用来加快首屏显示，当依赖多个外部脚本时，效果就比较明显 一些动态插入的 &lt;script&gt; 比如 pollyfill 之类的，可以使用 defer 而一些不会与其他任何脚本发生依赖的 &lt;script&gt;，则 async 会更适合]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾调用尾递归]]></title>
    <url>%2Fblog%2F2017%2F10%2Ftail-call-recursion.html</url>
    <content type="text"><![CDATA[本文来源于一道题目：以下递归函数存在栈溢出的风险，请问如何优化？ 123function factorial (n) &#123; return n * factorial(n - 1);&#125; 普通递归一看，递归没写退出条件，太 easy 了 1234function factorial (n) &#123; if (n === 1) return n; return n * factorial(n - 1);&#125; 应该是题目故意埋的坑，当n很大的时候，仍会溢出，因为函数调用时会不断的压栈 文艺递归出题者的意图应该是使用尾递归~~（见参考链接） 1234function factorial (n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125; 然而放在浏览器试下，factorial(10000)仍是溢出的。。 因为，ES6 的尾调用优化只在严格模式下开启，正常模式是无效的~ 尾递归转化123456789101112131415161718192021function tailCall (f) &#123; let value; let active = false; const argsQueue = []; return function () &#123; argsQueue.push(arguments); if (!active) &#123; active = true; while (argsQueue.length) &#123; value = f.apply(null, argsQueue.shift()); &#125; active = false; return value; &#125; &#125;&#125;const factorial = tailCall(function (n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;); 当执行factorial(3)的时候，它会先在argsQueue.push([3, 1])，然后执行到while循环里，这时执行f.apply(null, [3, 1])其实才是真正要递归的函数。 然后又执行了factorial(2, 3)，因此又在argsQueue.push([2, 3])。而由于前一次已经将active置位了，所以factorial(2, 3)就算执行结束了，无返回值 回到第一次的while里，发现argsQueue多了条[2, 3]，于是继续调用f.apply(null, [2, 3])。同理，会执行factorial(1, 6)，又在argsQueue.push([1, 6])。 再次回到第一次的while里，发现argsQueue又多了条[1, 6]，于是继续调用f.apply(null, [1, 6])。而注意此时f(1, 6)直接返回total了，因此argsQueue里没有新增参数了，于是factorial就返回了value = 6 以上过程说白了仍是递归，区别在于普通递归时函数调用里继续函数调用，需要保存函数调用前的上下文（context）信息。而使用了尾递归转化后，递归调用时只会向共享的argsQueue里压入参数，在外层通过循环的方式（直到argsQueue为空）逐步调用函数主体。 总结打个比方来说，普通递归的过程有点像深度优先遍历，函数调用一层层深入下去，需要不断保存 context 信息，最后再逐层回溯。因此函数调用栈是连续增长的，容易发生栈溢出。 而尾递归优化后的递归过程就像广度优先遍历，函数调用后只在队列里增加一条参数，并不是逐层深入，而是通过循环逐渐执行函数体。因此函数调用栈是压入1次再弹出1次，不会发生溢出~ 这是尾递归优化后的执行结果，虽然结果值已经超出 MAX_VALUE，但函数调用不会溢出 参考链接stackoverflow: What is tail recursion? ruanyifeng: 尾调用优化 ruanyifeng: es6尾递归优化]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再看reduce]]></title>
    <url>%2Fblog%2F2017%2F08%2Fmore-about-reduce.html</url>
    <content type="text"><![CDATA[前一篇中提到了可利用reduce函数做数组扁平化以及数据统计之类的操作，这篇中将会介绍利用 reduce 实现的更高级操作。 reduce 的用法为 arr.reduce(callback[, initialValue])，在MDN中对 initialValue 有这么一段解释。 Value to use as the first argument to the first call of the callback. If no initial value is supplied, the first element in the array will be used. Calling reduce() on an empty array without an initial value is an error. callback 函数接受4个参数：之前值、当前值、索引值以及数组本身。若指定 initialValue，则当作最初使用的 previous 值；如果不指定 initialValue，则使用数组的第一个元素作为 previous 初始值，同时 current 往后顺延。因此不指定 initialValue 时会比指定时少一次迭代。 123[1, 2, 3].reduce((previous, current) =&gt; previous * current)[1, 2, 3].reduce((previous, current) =&gt; previous * current, 0) 用这个简单的例子可以体会出有无 initialValue 的差别了吧。 给力一点我们再来看一个黑科技，利用 reduce 结合函数 bind 可以实现函数的链式调用 1234567891011121314// 给定2个字符串处理函数const reverse = str =&gt; str.split('').reverse().join('');const upper = str =&gt; str.toUpperCase();// 写法1[reverse, upper].reduce((prev, action) =&gt; action(prev), 'abcdefg');// 写法2const compose = (...fns) =&gt; &#123; return (str) =&gt; &#123; return fns.reduce((prev, action) =&gt; action(prev), str); &#125;&#125;;compose(reverse, upper)('abcdefg'); 再给力一点注：以下代码出自十年踪迹(月影)的函数式编程入门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Task&#123; constructor()&#123; this.plugins = &#123; '*': [] &#125;; this.pluginId = 0; &#125; use(router, functor)&#123; if(typeof router === 'function')&#123; [router, functor] = ['*', router]; &#125; this.plugins[router] = this.plugins[router] || []; this.plugins[router].push(&#123; functor, id: ++this.pluginId &#125;); &#125; dispatch(router, ...args)&#123; let plugins = this.plugins['*']; if(router !== '*')&#123; plugins = plugins.concat(this.plugins[router] || []); &#125; plugins.sort((a, b) =&gt; a.id - b.id); // 关键在这里 let entrace = plugins .map(plugin =&gt; plugin.functor.bind(this, ...args)) // 注意无 initialValue 时, a指向前一个函数，作为参数传入b .reduceRight((a, b) =&gt; b.bind(this, a)); entrace(); &#125;&#125;// for testlet task = new Task();task.use(function(req, res, next)&#123; console.log(req, res); next();&#125;);task.use('/', function(req, res, next)&#123; req.a++; res.x++; next();&#125;);task.use('/', function(req, res)&#123; console.log(req, res);&#125;);task.dispatch('/', &#123;a: 1&#125;, &#123;x: 2&#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会reduce函数]]></title>
    <url>%2Fblog%2F2017%2F08%2Fmake-use-of-reduce.html</url>
    <content type="text"><![CDATA[Array 中有几个很实用的函数，比如 each, map, filter, find, some 等，这些我们平时的业务实现中会经常用到，而有一个 reduce 函数可能经常被忽视。 简单介绍可直接参考MDN: Array.prototype.reduce 简单来说就是这样的函数形式 1234[].reduce(function (accumulator, currentValue, currentIndex, array) &#123; // do something return accumulator;&#125;, initialValueOfAccumulator); 在迭代函数中会接收一个accumulator，在 reduce 开始时可以为它设置初始值（即上面的initialValueOfAccumulator）。在迭代中做的事情就是把处理后的结果追加到accumulator上再将其返回，这样就使得accumulator在迭代中依次传递（第0次的结果会传给第1次，第1次的结果传递给第2次，…），所有的处理结果都汇聚在accumulator上。最后 reduce 函数的返回值就是最终的accumulator值。 map-reduce 关系MapReduce 是在分布式中提出的计算方法，我看过两篇解释简单又清晰的文章，可供参考 用通俗易懂的大白话讲解Map/Reduce原理 十张图解释MapReduce js 中也有map和reduce函数，用它俩也能实现 MapReduce，区别是 js 没有分布式计算的支持。这里简单示意下 word count 程序 123456789101112131415161718192021222324252627// 一些列文章，数组中每个元素相当于一篇文章的完整字符串var articles = [ 'This is an example of word count.', 'This is an example of word count.', 'todo...'];articles.map(function (content) &#123; // 将每篇文章的字符串都切成单词数组，如果需要预处理（比如剔除某些助动词）也在这时处理 var words = content.replace(/[^\w\s]/g, '').split(/\s+/); // 统计该篇文章的 word count var countMap = words.reduce(function (accumulator, word) &#123; accumulator[word] = (accumulator[word] || 0) + 1; return accumulator; &#125;, &#123;&#125;); // 返回每篇文章的单词统计 return countMap;&#125;).reduce(function (stats, countMap) &#123; // 将每篇文章的统计结果合并起来 for (var word in countMap) &#123; stats[word] = (stats[word] || 0) + countMap[word]; &#125; return stats;&#125;, &#123;&#125;); 运用场景举例1. 数组扁平化题目：将形如 [[0, 1], [2, 3, 4], [5]] 的数组转成扁平结构的一维数组 [0, 1, 2, 3, 4, 5]。 用 reduce 实现的话代码就很简单 123[[0, 1], [2, 3, 4], [5]].reduce(function (flatten, item) &#123; return flatten.concat(item);&#125;, []); 现在考虑一下：如果输入的数组可能嵌套多层呢？形如 [[0, [1]], [2, [3, 4]], [[[5]]]] 且嵌套的深度我们无法预知 1234567891011121314151617181920212223// 对多维数组的 flattenvar flatten = function (array) &#123; // 如果当前 array 已经是基础类型了，就转成1维数组 if (array instanceof Array === false) &#123; return [array]; &#125; // 临时空间，它的每个成员都要保证是1维数组 var tmps = []; for (var i in array) &#123; tmps.push(flatten(array[i])); &#125; // 利用 reduce 函数可以将形如 [[a], [b, c]] 的数组扁平化成1维数组 return tmps.reduce(function (res, item) &#123; return res.concat(item); &#125;, []);&#125;;flatten([0, 1, 2, 3, 4, 5]);flatten([0, [1], [2, 3], 4, 5]);flatten([[0, [1]], [[2], [3]], [[4, 5]]]);flatten([[[0, 1]], [2, [3, 4]], [[[5]]]]); 如果需要从右向左的顺序 flatten 处理，则可使用 reduceRight 代替 reduce 当然，这个多维数组的例子有点刻意使用 reduce 的感觉，只要使用递归，其中 reduce 可以用 tmps = tmps.concat(flatten(array[i])) 代替。 顺便附上 flatten 函数的 underscore 实现版本（非递归实现） 123456789101112131415161718192021// Internal implementation of a recursive `flatten` function.var flatten = function(input, shallow, strict, output) &#123; output = output || []; var idx = output.length; for (var i = 0, length = getLength(input); i &lt; length; i++) &#123; var value = input[i]; if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; // Flatten current level of array or arguments object. if (shallow) &#123; var j = 0, len = value.length; while (j &lt; len) output[idx++] = value[j++]; &#125; else &#123; flatten(value, shallow, strict, output); idx = output.length; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125; 2. 统计节点标签数另一个实用例子是统计一个页面中所有的节点数，利用 document.getElementsByTagName(&#39;*&#39;) 可取出所有节点的 HTMLCollection，再配合 map 和 reduce 函数就可轻松统计出各 tagName 的数目。 12345678Array.prototype.slice.call(document.getElementsByTagName('*')) .map(function (el) &#123; return el.tagName; &#125;) .reduce(function (total, tag) &#123; total[tag] = (total[tag] || 0) + 1; return total; &#125;, &#123;&#125;); reduce 内部实现根据 reduce 函数的定义，可以简单这样实现（仅供学习使用） 123456Array.prototype.reduce = function (iterator, accumulator) &#123; for (var i = 0; i &lt; this.length; i++) &#123; accumulator = iterator(accumulator, this[i], i, this); &#125; return accumulator;&#125; reduce 函数是 es5 中的标准，从 MDN 上抄了一份 Polyfill（可用于生产环境） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Production steps of ECMA-262, Edition 5, 15.4.4.21// Reference: http://es5.github.io/#x15.4.4.21// https://tc39.github.io/ecma262/#sec-array.prototype.reduceif (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; value: function(callback /*, initialValue*/) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.reduce ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError( callback + ' is not a function'); &#125; // 1. Let O be ? ToObject(this value). var o = (Objectthis); // 2. Let len be ? ToLength(? Get(O, "length")). var len = o.length &gt;&gt;&gt; 0; // Steps 3, 4, 5, 6, 7 var k = 0; var value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in o)) &#123; k++; &#125; // 3. If len is 0 and initialValue is not present, // throw a TypeError exception. if (k &gt;= len) &#123; throw new TypeError( 'Reduce of empty array ' + 'with no initial value' ); &#125; value = o[k++]; &#125; // 8. Repeat, while k &lt; len while (k &lt; len) &#123; // a. Let Pk be ! ToString(k). // b. Let kPresent be ? HasProperty(O, Pk). // c. If kPresent is true, then // i. Let kValue be ? Get(O, Pk). // ii. Let accumulator be ? Call( // callbackfn, undefined, // « accumulator, kValue, k, O »). if (k in o) &#123; value = callback(value, o[k], k, o); &#125; // d. Increase k by 1. k++; &#125; // 9. Return accumulator. return value; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础部分]]></title>
    <url>%2Fblog%2F2017%2F08%2Fes6-basic.html</url>
    <content type="text"><![CDATA[【阅读笔记】本文内容均来自：ECMAScript 6 入门 变量let 不存在变量提升 暂时性死区 不允许重复声明 与顶层对象的属性脱钩 let a = 1 不会挂到 window 上 块级作用域 ES5 只有全局作用域和函数作用域 ES6 允许块级作用域的任意嵌套 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了 ES6 明确允许在块级作用域之中声明函数，但在浏览器的ES6实现中仍把块级作用域的函数声明当作var处理，建议写成函数表达式。 const 只在声明所在的块级作用域内有效，特性同let const 声明变量时必须复制，以后不能赋值 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 对于基础数据类型，const 指向的就是其值；而对于对象类型，const 指向其引用地址，对象的地址不可改变，但对象本身的属性值仍可以改。 如果必须将对象冻结（地址和值都不能改），应该使用Object.freeze 解构赋值数组解构形式1234let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 解构赋值允许指定默认值，默认值生效的条件是：数组成员的值严格等于undefined 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象解构形式123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 默认值生效的条件是：对象的属性值严格等于undefined 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 如果要将一个已经声明的变量用于解构赋值，必须非常小心。因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 常用场景：let { log, sin, cos } = Math; 函数参数的解构赋值12345[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ][1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 变量解构赋值的用途 提取对象数据（或用于遍历数据结构） 函数参数的映射及默认值 输入模块的指定方法 字符串的扩展 ES6为字符串添加了Iterator接口，使得字符串可以被for...of循环遍历。 新增：includes(), startsWith(), endsWith(), repeat() 模板字符串 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数 高级用法 12345678const tmplFn = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 模板编译 123456789101112131415161718192021222324252627282930313233var template = `&lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`;function compile(template)&#123; var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; var script = `(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; 正则的扩展以下非 es6 新增 正则表达式中，点.是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。以下四个字符属于”行终止符“： U+000A 换行符\n U+000D 回车符\r U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 但是，很多时候我们希望匹配的是任意单个字符，有一种变通的写法[^] 数值的扩展新增 Number.isFinite() Number.isNaN() Number.parseInt() Number.parseFloat() Number.isInteger() Number.EPSILON 2.220446049250313e-16 Number.isSafeInteger() -2^53 ~ 2^53 函数的扩展函数参数的默认值 参数变量是默认声明的，所以不能用let或const再次声明。 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。 也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 rest 参数rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 注意 rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 箭头函数 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。（但是箭头可以作为 async 函数） 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 注意：由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5无埋点数据采集]]></title>
    <url>%2Fblog%2F2017%2F06%2Fauto-tracker-on-h5.html</url>
    <content type="text"><![CDATA[前一阵团队里做了个项目，称为“无埋点圈选”，目的是在 app 中无需为特殊的按钮或事件编写埋点，可在 app 发布后通过可视化的方式来圈选需要“埋”的点，然后在 app 端通过配置下拉的方式来获取埋点信息，实现埋点数据的自动发送。 工作流程圈选的主要步骤为 在 web 管理端打开【圈选】功能的入口，开启长连接 在 app 中通过特殊手势开启【圈选】状态，连接 socket app 端实时将手机截屏以及控件结构传送给 web 端 在 web 端圈出需要【埋点】的控件，并保存为配置 而数据采集时的步骤为 app 启动时自动更新一份埋点配置信息 Native 与 webview 部分的页面，分别捕获用户的点击事件，并根据埋点配置信息发送指定的埋点事件日志 需注意的是，Native 部分的控件均由 app SDK 负责处理，而 webview 里面的页面，由 app SDK 将特定 js 注入 webview 中，再由 js 负责处理。 整体架构Hybrid 关系H5 与 SDK 部分的关系如下： 12345678 发起请求SDK ------------&gt; 注入js (根据功能场景注入下面不同的js文件) getViewportTree圈选js -------------------&gt; 得到页面可视结构 (由SDK主动调用js bridge) 监听点击事件，事件过滤，调用SDK采集js --------------------------------&gt; 由SDK处理日志发送 其中“圈选js”只负责分析当前页面的可视结构，并将结果传递给 SDK 端。而“采集js”只负责监听当前页面事件，并根据埋点配置过滤出有效埋点事件，并发送给 SDK 端（由SDK负责处理日志的发送） 圈选部分获取可视结构树遍历算法 1TO be continue 效果示意图 结构化数据表示可视结构取自DOM document，本质上仍使用 XPath 来表示一个DOM节点在 document 中所处的路径，形如BODY[0]/DIV[0]#main/DIV[1]/A[0]#query …… 为了方便与其他端的数据交互，这里使用统一的 JSON 结构来表示任一控件元素的路径，包括在 Native 中的部分以及在 webview 中的部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; // 注：由于 Native 部分的控件不是均可点击，所以path保留从上一个父节点到当前节点的相对路径 path: [ &#123; p: 'UIWebView', // 路径上的path节点类型 i: '0', // 节点index，相对于"同类型"控件 t: 'UIWebView' // 控件继承的系统控件类型 &#125; ], type: 'UIWebView', // 系统控件类型 url: 'http://m.ctrip.com/html5/', // 只有webview时才有url字段 value: '', // SDK端从控件属性取出来 frame: &#123; // 相对于当前屏幕左上角，四舍五入 x: 0, y: 100, w: 320, h: 480 &#125;, child: [ &#123; // H5中的路径表示法与 Native 保持一致，由于H5中不会存在父元素不可圈选而子元素可圈选的情况 // 因此 H5 的文档数据中，每个节点的 path 数组里都只有1项 path: [ &#123; p: 'BODY', // H5中即 tagName （**从BODY开始**） i: '0', // 同类 tagName 在父节点中的 index t: 'BODY' // H5中只有使用自定义标签（如 &lt;my-app&gt;）时，t 和 p 才不同 &#125; ], type: 'BODY' // 同 path 数组中最后一项的 t value: '', // H5中约定：详见“获取节点content” frame: &#123; // 相对于当前webview左上角（webview有可能不撑满手机屏幕） x: 10, // 注：&lt;body&gt; 可能设有 margin y: 10, w: 300, h: 460 &#125;, child: [ &#123; path: [ &#123; p: 'DIV', i: '0', t: 'DIV', d: 'mainContainer' // 元素有id时存在此字段 &#125; ], type: 'DIV', value: '', frame: &#123;...&#125; child: [...] &#125; ] &#125; ]&#125; 获取节点content节点 content 即一个DOM节点的内容文案，不能都用innerText来概括，而应根据节点类型取不同的属性 如果是/(input|textarea|select|option|form)/等表单元素，不取 content 特例&lt;input type=&quot;button&quot;&gt; 和 &lt;input type=&quot;submit&quot;&gt; 实为按钮，取value属性作为 content 如果有title alt属性，就以其值作为 content value 如果元素设有contenteditable属性（视为可编辑的元素），不取 content 如果元素无children（末端叶子节点），直接取innerText 如果元素仍有子元素，取所有的文本节点（也是它的子节点，且nodeType==3） 以上过程都不满足，返回空字符串 采集部分事件捕获下面主要记录在实现H5页面的数据采集时，关于 touch 事件所遇到的坑。 Android IOS 客户网页中使用 touchend 跳转 监听 click 事件 OK（只要用户不在 touchend 中故意阻止事件preventDefault） 无法捕获 监听 touch 事件 OK 无法捕获 客户网页中使用 普通 click 跳转 监听 click 事件 OK OK 监听 touch 事件 OK 无法排除 safari 双击放大，双击中的第1次 touch 仍会触发匹配流程 客户网页中使用 fastclick 跳转 监听 click 事件 OK OK 监听 touch 事件 OK 同样无法很好的处理 double-tap 问题 几个现象 android 上不存在 double-tap 放大，会触发两次 click ios 上即使页面设了user-scalable=no，double-tap 时仍会被判未没有生效的“放大”操作 android 上的长按链接，时长限制在 590~600ms，与 ios 上长按的时长不同 ios safari 在链接上快速flip手指时，容易不触发 touchstart 折衷方案 ios 上只监听 click 事件 android 上监听 touchstart -&gt; touchmove -&gt; touchend，同时监听 click 事件用于补偿不能判定的case touch 事件用于排除【多指触摸、移动偏差过大、长按】等不应该触发埋点的情况 同时 double-tap 会触发两次 touchend，将忽略其中的第二次 在 touchend 阶段判定有效的点击，并触发埋点 其余不能判定的case，将在 click 阶段再判定是否触发埋点 路径匹配算法H5页面上已被圈选的【埋点】元素路径可能会很多，采用遍历每条圈选路径并打分的算法（最多1轮循环）找出最佳匹配的规则，保证最多触发1个圈选的事件。 1TO be continue Bad Case下面主要记录了开发过程中发现的一些特殊 case 以及相应的处理措施。 case 阶段 状态 备注 float 父元素塌陷 直接过滤了 圈选 FIXED 暂时不直接过滤高为0的节点，区域裁剪时也加入了overflow的判断 轮播 banner 不能圈（很依赖轮播的具体实现） 圈选 PENDING 能圈，但只能圈当前那一帧的图片。如果图片撑满了整个轮播容器，那就没法圈到轮播整体。。如果是通过&lt;ul&gt;定位实现的，left 或 translate 负值实现的轮播动画，则无法圈选（因为&lt;ul&gt;已经被判为不在 viewport 中） 位于页面顶部的 fixed header 内容不方便圈（如果后面的元素设了padding） 圈选 PENDING 案例：ctrip h5 顶部搜索 父容器被下方元素遮住后续考虑在前端做层叠的提示，让用户选择那一层的元素 父容器设有margin，子元素定位时的参考元素在元素在父容器之外，会在区域裁剪时裁掉 圈选 部分缓解 案例：&lt;body&gt;设了 margin, &lt;div&gt;子元素定位相对&lt;html&gt;，被认为超出父容器&lt;body&gt;边界。目前引入了子元素最大区域的概念，当父元素非overflow时，子元素可接受的范围可向右向下延生，延生到父元素的可接受最大区域（只要路径上没有节节点设过overflow，原理上子元素可接受范围可延生到视窗的最右和最下）注意：目前只接受向右向下延生到父元素之外，其他方向超出父元素时，仍然会被裁剪到父元素边界 两个子元素区域之和正好等于父元素区域，就无法圈到父元素 圈选 PENDING 现象就是：前端点不到父元素的区域 开发者对 html body 设了 height: 100% 导致页面滚动后根节点区域缩小 圈选 FIXED 在计算前先对body设height: auto，完了后再还原 使用 touch 事件，直接在 js 中跳转页面 采集 解决部分case 监听 touchstart / touchend 事件来判定，同时监听 click 事件来辅助当前规则：touch 位移容忍范围为&lt;=10px，touch 时长容忍为&lt;=750ms，两次touch间隔时间&gt;250ms（参考了 zepto.js 中的阈值）FUCK: 仍无法排除 ios safari 下“双击放大”，会误判为 touchend 触发2次事件 动态添加出来的元素，碰巧与圈选的元素 path 相同，会被视为1次触发 采集 低成本缓解 已使用路径中的id减少了此类干扰（只匹配最里层id之后的 tag 和 index）但无法保证用户所有圈选的控件元素都存在id 暂不支持： 不支持列表内同级元素的忽略下标 不支持全部 iframe / flash 实现的页面 (视为1个整体元素)，例如 http://music.163.com/ 不支持手动放大缩小页面时的圈选]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理 (听课笔记)]]></title>
    <url>%2Fblog%2F2017%2F04%2Fnotes-of-browser-displaying-a-page.html</url>
    <content type="text"><![CDATA[这也是公司培训的听课笔记，关于浏览器渲染过程中各个阶段的技术细节，整理的范围比较广，都列了一些点，可作为今后学习这块的提纲。 资源下载&lt;script&gt; &amp; &lt;link&gt; css未下载完前，页面不会显示内容（为了体验） js未下载完前，是可以正常显示页面的 服务器端 Response.Flush() 分块传输，让客户端充分利用下载的间隙做解析，分块解析 document.write 页面渲染完后调用它，会使页面变成空白 【重要】document.write 会使浏览器重新解析DOM树，禁止使用 new Image().src 唯一不用添加元素就能发请求的办法 常用于发送日志 有些浏览器会报错，因为返回类型不是图片 defer VS async defer 源自IE，保证执行顺序，都会到 domReady 后再执行 async 现代标准，不保证执行顺序，什么时候下载完就什么时候执行 资源优先级 link[rel=stylesheet] / script 第一优先级（没有就没法看） object / img / iframe 第二优先级（是页面内容的一部分） link[rel=prefetch] 预加载（与当前页面没有关系） 脚本依赖 下载阻塞 VS 执行阻塞 执行阻塞可以并行下载，只需保留执行的顺序，效率更高 Connection并行度 现代浏览器资源下载并行度是6，旧的IE上是4 服务器压力 VS 客户端效率 比如 Socket重用 TCP三次握手的时间与客户端带宽没有关系 Connection: keep-alive 保证TCP连接不关闭 然后何时能够知道文件下载完了 Content-Length: 告诉你多长就读多长 Transfer-Encoding: chuncked 分块，最后一块都是0，表示下载完了 正确性保证 Content-MD5 意义也不是很大 断点续传 Accept-Range 告诉服务器我要哪段的数据，也可用于多线程下载 Content-Range BS架构的精髓 - 缓存 补丁机制 胜过CS软件 验证型缓存：去问服务器是不是最新的，会有个请求，但省去了下载这个资源 Last-Modified &amp; If-Modified-Since / If-Unmodified-Since ETag &amp; If-Match / If-None-Match If-Range 非验证型缓存：完全不去问服务器，服务器更新了本地也不会知道 Cache-Control Expires 缓存失效 Vary / Via / Date / Age 比如现在是个代理服务器，Chrome请求资源缓存下来后，IE再请求时要不要使用缓存，通过 Vary 指定 缓存年龄计算 age_value date_value 缓存过期计算 max-age=0 VS no-cache 区别 max-age=0：是用于验证型缓存的，相当于告诉服务器禁止非验证型缓存， no-cache：禁止任何缓存 小结 http的超链接特性注定资源之间有关联的依赖 外部资源位置、类型不同，影响下载时机 Response.Flush 对下载的影响 缓存机制复杂但完善 页面解析字符串 –&gt; 序列化 –&gt; 转义 –&gt; 标签匹配 脚本执行会增加解析的回溯 DOM 结构的变化 document.write 会使浏览器解析过程回溯到序列化的状态 CSS计算 元素 - 匹配样式 耗内存 &amp; 耗CPU Webkit 特定条件下样式共享（节省内存） 鼠标状态相同 没有id class 和标签名相同 …. 样式计算的过滤（省CPU） 以最后选择器为依据 将css规则按最右为 id, class, tag, general 分组 属性选择器也会归到 general 组里，因此效率低 CSS层级 来源层级 浏览器UA样式 用户样式 作者样式 作者样式 !important 用户样式 !important 样式层级 1, 1, 1, 1 算法 inline(0/1), count(id), count(attribute), count(tag) 从左到右按位比，数字大就胜出，直接结束比较 Render Tree 元素没有渲染对象 head / meata / script 元素有多个渲染对象 html 会包含滚动条 li 会包含前面的小圆点 select input[type=file] 通过CSS改变渲染对象 ::before / ::after display: none js 控制DOM树，css 控制渲染树 布局 流布局 HTML三条流 文档流、浮动流、定位流 其他因素 display: list-item display: run-in table布局 display: table / inline-table / table-row / …. 坐标系 前端中都以左上角为 0,0 点，右|下 为正坐标 地图是以左下角为 0,0 点 布局是个递归过程 流布局可自左向右、自上而下进行，流中靠后的元素不会影响流中靠前的元素的布局（无回溯） table布局需要回溯才能够完成（知道每一个单元格的大小，才能完成整个布局） 流式布局特点是无论如何后面元素都不会影响前面，例如ol中四位数、五位数的预留位置不变，浏览器直接暴力地留了3位数的空间 全局reflow 整个 Render Tree 全部重新计算布局 全局布局样式变更：body {} / 添加新样式表 窗口大小变化 局部Reflow 仅标识为 needLayout / dirty 的渲染元素计算布局 Render Tree 中插入新的渲染元素 渲染元素属性比拿货 Reflow 会引起另一个 Reflow：比如 Reflow 导致滚动条位置变化 同步Reflow 全局Reflow通常同步进行 读取 offsetWidth / offsetHeight 等属性，会产生1次reflow 禁止在循环中读取 offsetWidth / offsetHeight 异步Reflow 局部Reflow通常异步进行 FireFox: Reflow任务进入线程Queue，任务调度器负责执行 Webkit: 定时器遍历Render Tree，布局所有 needLayout 对象 Reflow任务可合并，一次脚本执行过程中多个样式修改仅做1次Reflow，但有limit（大约100~200个） 手动Reflow 把元素先remove，改完一堆样式后再append进去 循环中使用 fragment 文字布局 text-align: justified white-space: nowrap / pre / pre-wrap overflow: hidden / visible 换行计算 每行一个line-box负责渲染 当需要换行时，通知父元素…. 渲染 transform / filter / z-index / color / visibility … Reflow VS Repaint：display none VS visibility hidden 渲染顺序（CSS2） background color background image border children outline 渲染计算的优化 firefox: display list webkit: rectangle storage chrome 的 Repaint 在独立进程中]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash基础编程 (听课笔记)]]></title>
    <url>%2Fblog%2F2017%2F04%2Fnotes-of-bash-commands.html</url>
    <content type="text"><![CDATA[也是去年公司培训里听课的一些笔记，较为粗略，主要供自己查阅用。bash 命令自己平时用的少，得督促了，在写 build 过程中很管用的。 热身seq 12seq 0 5seq -s bc 12echo 1+2 | bcecho '1+2' | bc 求和 1seq -s '+' 100 | bc 基础概念命令 关键字 内建命令 外建命令，如 wget shell 特点 quick and dirty 符合 unix 哲学 一切都是字符 一切都是进程 面向过程的编程 运行模式 交互式、登录shell echo &#39;aaa&#39; 非交互式、非登录shell ./xxx.sh 非交互式、登录shenll bash -l xxx.sh 交互式、非登录shell bash -i xxx.sh 几种模式 加载的文件不同 查看当前模式：echo $- 基础编程变量 赋值时=不能加空格 $a =&gt; ${a} 变量字符匹配：被匹配的，即是被删除的 echo ${a##.*} 1234567$&#123;a&#125;$&#123;#a&#125; 变量得长度$&#123;a%&#125; 尾匹配$&#123;a%%&#125; 最大尾匹配$&#123;a#&#125; 头匹配$&#123;a##&#125; 最大头匹配 数组 12345array=(a b c)$&#123;a[0]&#125;$&#123;#a[0]&#125; 第一个元素的长度$&#123;a[@]&#125;$&#123;#a[@]&#125; 数组的长度 成功与非成功 0 为成功，非0 为不成功 所有返回值，介于 0~255 之间 true, false 命令 与、或，“&amp;&amp;”、“||” &amp;&amp; 可连续多个，|| 建议只用于二选一，避免逻辑混乱 注：有点类似 js 里 echo $? 前一次脚本的返回值 条件判断 返回值“0”为“真（成功）” if、test、[[ ]] bash兼容了很多种写法，建议只记住if [[ ]] 循环遍历 12345#!/bin/bashary=(a b c)for (( i=0; i&lt;$&#123;#ary[@]&#125;; i++ )) ; do echo $&#123;ary[$i]&#125;done 字符处理 正则与通配符 正则，一般通过外部命令实现，如 awk, grep 等 通配符即 “glob”，优先于正则 glob 优先 echo 2*3 | bc echo 2* 3 | bc echo 2 * 3 | bc 此时*会被认为是通配符 标准写法：echo &#39;2 * 3&#39; | bc 使用单引号 set 命令：更健壮的脚本 set -u 阻止变量空值，抛出错误 set -e 异常 false 值是否放行 1false || echo 'something false here' set -o pipefail 管道中的 false 值 高阶话题锁：保证幂等性 标准模板 TODO 调试 12trap DEBUGbash -x here-document 文本输入：&lt;&lt; 进程替换 1diff &lt;(echo x) &lt;(echo y) here-string 1sed 's/a/A/' &lt;&lt;&lt; abc 多进程并发控制 标准模板 TODO 用 read 来阻塞（等输入） 用 fd 误操作rm 重灾区 123456rm -rf $dir/rm -rf / dir （路径前多了一个空格，也相当于把根目录也删了）rm -rf /path/a/bcd dir/ （如果dir目录不存在，不知道会删掉啥。。）rm -rf * double check set -ue 执行前加#，防止没敲完时直接执行]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做PPT报告的表达技巧 (by 林大班)]]></title>
    <url>%2Fblog%2F2017%2F04%2Ftechniques-for-making-presentations.html</url>
    <content type="text"><![CDATA[去年在公司听了林大班老师关于做“简报”的分享，“简报”是台湾那边的叫法，就是我们说的PPT报告。虽然主要针对的是商业汇报的PPT，但其中一些技巧对我们日常工作还是挺有启发的。这里就记录了一些笔记（未提炼过），感兴趣的可以参考大班老师的豆瓣小组 摘要 简报沟通力 = 职场竞争力 做人做事，还要会作秀 简报就是送礼：简单到难以置信 (或者) 悬乎到鬼才相信 ppt汇报不要占满时间，提前结束才是正确的 好的简报：说真话、用故事说真话、用图片说故事 首先介绍你的tag 不要超过3个重点，超过3个等于没有重点 不要用太常见的形容词，比如“热情” 同一件事情换句话说，比如用台湾的用语 用具体量化的词来介绍tag，比如星巴克“脑残粉”，平均每天2.5杯 最棒的东西不要在第1页讲，在适当的时候出现，也不要在最后 技巧 一部最爱的电影 –&gt; 说真话 一句经典台词 –&gt; 用故事说真话 一个印象最深的画面 –&gt; 用图片说故事 内容、讲者、听众 都重要 听众最重要 目标影响内容，比如加薪3k与3w 特定对象产生思维的改变 特定对象采取具体的行动 结尾要给出行动，而不是“谢谢”两个字 做简报的rule 不要打开电脑，纸上作业 架构规划 3分法，分为Part 1,2,3，然后 1.1, 1.2, 1.3 等 一定要强制分成3份，缺一不可，实在不行可以“其他” 不一定要完全等分 不要线性地来做 使用便签纸来可视化逻辑 简报情境 会议报告 销售提案 教育训练 演讲故事 会议报告 说故事可以拿来用，但不要有说故事的情境 D.I.G 来三分 Data 信息状况，不要讲太多大家都知道的，但一定要提一下，比如看比赛肯定要先知道比分再来看下面的 Information 导致缘故，高级主管提高这块的分析能力 Go! 解决方案，低级主管是提高解决方案的能力 向上汇报最重要的不是说服力，而是影响力，影响领导做决策 销售提案 M.T.H Motivation 引发动机 Technique 专业内容 How-to 具体行动 动机没有对错之分，只有强弱之分，视听众而定 要实现做听众分析 听觉、视觉 + 第3觉，能有实物的就带demo 引发听众的行动，要再最后，如果一开始就暴露就会让听众反感]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域通信常用技术]]></title>
    <url>%2Fblog%2F2017%2F03%2Fcross-domain-comm.html</url>
    <content type="text"><![CDATA[前端常用通信方法实验，侧重跨域以及单双向 通信形式 iframe 场景 不改写 document.domain 跨子域主域 不使用 Flash JSONP 单向通信 ✘ ✔ ✔ ✔ window.name 单向通信 ✔ ✘ (IE6/7 例外) ✔ ✔ CORS 单向通信 ✘ ✔ ✔ ✔ Flash URLLoader 单向通信 ✘ ✔ ✔ ✘ Server Proxy 单向通信 ✘ ✔ ✔ ✔ document.domain 双向通信 ✔ ✘ ✘ ✔ FIM 双向通信 ✔ ✔ ✔ ✔ Flash LocalConnection 双向通信 ✘ ✔ ✔ ✘ postMessage 双向通信 ✔ ✔ ✔ ✔ Cross Frame 双向通信 ✔ ✔ ✔ ✔ 参考资料 跨源资源共享（CORS）]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[现在还在重构jquery...]]></title>
    <url>%2Fblog%2F2017%2F03%2Fupgrade-to-jquery-seems-outdated.html</url>
    <content type="text"><![CDATA[前面忙了三个多月，从11月开始前期的计划和调研，到12月开始每天早起，到年后2月底差不多小结。除了正常的需求迭代开发之外，全都投在了这一件事，把系统的前端做了个大重构。这是这半年的代码量统计，实际没那么多，因为是重构，insertions 和 deletions 都会被录入代码行数。真的体会了把重构是个体力活儿，起步阶段会比较快，但后面会越来越陷入debug，这和开发是一样的。。 业务背景上图是我最近半年的代码提交统计，近三个月的提交激增，正是因为重构。简单罗列下这项工作的背景 公司这个产品最初是用了一个开源框架实现的，但去年下半年该框架已宣布停止维护 此前的代码夹杂着原生js和框架js实现的逻辑，但是产品业务的发展不允许我们停下手头的工作来重做此前的业务功能 有个兄弟产品已经完成了旧代码和新业务齐头并进的整改，将旧代码重构的同时，加了一些新业务或新UI元素进去 因此团队决定从兄弟产品中抽取可复用的组件元素，形成我们俩产品通用的组件库，而在这基础上再将我们的产品代码迁移成新代码。 说了这么多废话，其实这套“新代码”仍是jquery，因为以前我们连jquery都用不起。。虽然这项重构工作是实实在在的体力活，但经历过后又让我重新思考以前对所谓的“组件”的认识，因为这个过程中走了不少弯路。 做了啥简单罗列下我所做的事情 从兄弟产品中抽取可复用的组件和交互元素，形成组件库的base 要保证组件中没有业务强相关的逻辑，有则必须抽离出去，作为自定义参数或回调函数的方式实现 保证组件库中的组件都是可以复用到相似产品的，同时尽量不要破坏组件原有的参数格式 组件库中的组件都是可以再二次扩展的，可以使用继承或组合的方式，揉入业务强相关逻辑 业务特有的组件就放在业务的代码库中，或者称为业务库组件 业务页面中会同时依赖组件库中的组件和业务库组件 业务库组件可能是基于组件库组件做二次开发而形成的，也可能是独立的新组件 使用 gulp 进行打包，并做成可复用的build模块 可由业务指定“我只需要组件库中的哪些组件” 组件库的组件和业务库的同名组件，可通过不同的 namespace 区分 可自动判断一个页面中所需组件的最小集，只将最少代码打包到页面中 最后，利用这套框架，将旧的业务代码逐页面迁移过来。。虽然最后这步是纯粹的体力活儿，但其中踩了不少坑，也反映了一些设计问题，会在本文最后一部分中一起来review。 组件库class.js 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950define(function () &#123; var initializing = false; var fnTest = /xyz/.test(function () &#123;var xyz; &#125;) ? /\b_super\b/ : /.*/; // The base Class implementation (does nothing) var Class = function () &#123;&#125;; // Create a new Class that inherits from this class Class.extend = function (prop) &#123; var superProto = this.prototype; // Instantiate a base class (but only create the instance, // don't run the init constructor) initializing = true; var prototype = new this(); initializing = false; // Copy the properties over onto the new prototype for (var name in prop) &#123; // Check if we're overwriting an existing function prototype[name] = typeof prop[name] === 'function' &amp;&amp; typeof superProto[name] === 'function' &amp;&amp; fnTest.test(prop[name]) ? (function (name, fn) &#123; return function () &#123; var tmp = this._super; // Add a new ._super() method that is the same method // but on the super-class this._super = superProto[name]; // The method only need to be bound temporarily, so we // remove it when we're done executing var ret = fn.apply(this, arguments); this._super = tmp; return ret; &#125;; &#125;)(name, prop[name]) : prop[name]; &#125; // The dummy class constructor function Class() &#123; // All construction is actually done in the init method if (!initializing &amp;&amp; this.init) &#123; this.init.apply(this, arguments); &#125; &#125; // Populate our constructed prototype object Class.prototype = prototype; // Enforce the constructor to be what we expect Class.prototype.constructor = Class; // And make this class extendable Class.extend = arguments.callee; return Class; &#125;; return Class;&#125;); 特点： 类式继承 继承的链式调用 提供_super调用父类函数的方式 缺点 使用这套方式定义的类，实例化后对象的constructor都指向了上面的Class函数，丢失了面向对象中重要的instanceof信息。 注：在Javascript模式之五-代码复用模式写过另一种实现，保留了constructor 类层次结构123456789 Class | -------------------------------- | | | ClassBase UIBase ChartBase | | ------- -------- | | | |RecordTarget 等 Dialog, Table 等 定义了三种 base class，分别代表非UI组件，UI组件和绘图组件，具体组件再依次继承。 私有成员保护12345678910UIBase.extend(&#123; options: &#123; &#125;, __private: &#123; _items: null, _selectedItems: null &#125;, type: ''&#125;); 由于通过Class.extend，会将所有属性挂到prototype上，所以必须将实例属性区分开，这里约定将__private里面的属性直接挂在实例上。（在 UIBase 的 init 函数里操作） 组件扩展123456789101112define(function (require) &#123; var Table = require('sawse/component/Table'); return Table.extend(&#123; // 覆盖父类方法 render: function (table) &#123; // 调用父类的同名方法 this._super(table); // do something else &#125; &#125;);&#125;); 构建打包1gulp [task] [--dir=PROJECT_DIR] [--config=CONFIG_FILE] 使用 gulp 来组织构建，对库代码和业务代码分别配置。 123456789101112131415161718192021222324252627282930313233343536&#123; // 组件库打包 libPackConf: &#123; febase: &#123; baseDir: 'fe-base/js/', // 相对于 src 的路径 patternsInCopy: ['**/*.js'], // 以下路径都 相对于 baseDir ignoresInCopy: ['dep/**/*.js'], // 在 copy 时过滤 prependsInPack: [], // 在 pack 时追加在开头，以保证优先顺序 patternsInPack: ['**/*.js'], // 要 pack 的文件，可包含 prependsInPack 的文件 ignoresInPack: [], // 在 pack 时过滤 namespace: 'sawse', // 组件定义时追加的命名前缀 outputName: 'sawse.js', // 打包产物的文件名 outputDir: 'js/' // 打包产物的相对于 webroot 的目录 &#125;, febaseCss: &#123; baseDir: 'fe-base/sass/', // 相对于 src 的路径 patternsInCopy: [ // 以下路径都 相对于 baseDir '**/*.scss', '**/*.css', 'decorator/**/*' // css 图片要一起 copy 过来 ], ignoresInCopy: [ // 在 copy 时过滤 'base/normalize.css', 'base/reset.css' ], prependsInPack: [ 'base/sprite_def.css', // sprite 先定义在开头 'base/*.css' // css 合并时要保证优先顺序 ], patternsInPack: ['**/*.css'], // 只打包编译后的 css 文件 ignoresInPack: [], // 在打包时才过滤 outputName: 'sawse.css', // 输出打包的文件名（不含路径） outputDir: 'css/sawse/' // 作为 css/ 下的完整子目录（保证图片引用正确） &#125; &#125;&#125; 以上只列了组件库的一些配置项，还有对业务库、页面的打包配置，具体的实现抽成了一个独立模块，细节这里略过。 使用 glulp 就是很多事情得自己做，在 stream 里做字符串处理，拼接文件等操作。。。 上线考虑简单来说就是得兼容，因为重构和迁移是逐步推进的，线上会存在一个过渡期，通过路由字典指明哪些是走新页面，哪些走旧页面。而且新旧页面的产物必须在两个完全隔离的目录下，便于发布和回滚。（旧页面也可能在这个过渡期有bugfix发布） 总结思考1、动态类型一时爽，代码重构火葬场 真理！特别是面对好几年前的N手代码，看着很正规的函数在调用时都会防不胜防 需要好好评估重构的代价，重构之后一两年内是否还需要重构，长痛不如短痛的重做还是重构 2、使用什么库并不是第一位的重要，业务组件的梳理和规范性才是页面实现时的瓶颈 不管用什么库，把业务通用的组件梳理出来并规范几种使用场景，这是项目需要沉淀出的base，在这之上做需求会很快 3、不要轻易将一个产品中的组件去统一到另一个产品 即本文开头列的从兄弟产品中抽取可复用的组件和交互元素，形成组件库的base，现在感觉是件很傻的事情，经验不足 不同产品必定有不同的交互思路，想要从其他产品抽出的组件库作为base组件，势必还要再包一层改造成自己产品的业务组件 只有纯粹的组件库是可取的，比如 Bootstrap、ElementUI、AntDesign，可以在其上包装成自己的业务组件 4、工欲善其事必先利其器 gulp 的自动化程度还不够，很多特性比如子页面的打包，比如组件及样式的分批合并，需要在 stream 手写很多。。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>web组件</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用git命令]]></title>
    <url>%2Fblog%2F2017%2F02%2Fcommon-usage-of-git.html</url>
    <content type="text"><![CDATA[主要记录些 git 工作流中最最常用的几个操作，如：提交合并，撤销修改，回滚等操作。 之前也整理过关于 git submodule 的文档，这里简单记录一些自己常用的命令。 提交用于保持commit树的整洁 12git commit --amend 【修改最后一次提交】git pull --rebase 手动合并 12git fetchgit merge branch_name 【在一个分支下合并另一个分支上的改动】 撤销回退1234git rm --cache file_path 【撤消已暂存的文件】git checkout -- file_path 【撤消对文件的修改】git reset --hard commit_id 【撤消commit】git reset --hard HEAD^ 【回退到最新的前一次commit】 Git入门指南八:Git撤消操作 Git入门指南十一:Git branch 分支与合并分支 回滚的两种情况A) 还没有 push这种情况发生在你的本地代码仓库，可能你 add commit 以后发现代码有点问题，准备取消提交，用到下面命令 1git reset [--soft | --mixed | --hard] 1、--mixed 会保留源码，只是将 git commit 和 index 信息回退到了某个版本。git reset 默认是 –mixed 模式。 2、--soft 保留源码，只回退到 commit 信息到某个版本，不涉及index的回退。如果还需要提交，直接commit即可。 3、--hard 源码也会回退到某个版本，commit 和 index 都回回退到某个版本。注意，这种方式是改变本地代码仓库源码。 当然有人在 push 代码以后，也使用 git reset --hard &lt;commit_id&gt; 回退代码到某个版本之前，但是这样会有一个问题，你线上的代码没有变，线上commit 和 index都没有变，当你把本地代码修改完提交的时候你会发现全是冲突。。。 B) 已经 push对于已经把代码push到线上仓库，你回退本地代码其实也想同时回退线上代码。回滚到某个指定的版本，并使线上/线下代码保持一致，要用到revert命令。 git revert: 用于反转提交，执行 revert 命令时要求工作树必须是干净的。 【注意】git revert 用一个新提交来消除一个历史提交所做的任何修改 revert 之后你的本地代码会回滚到指定的历史版本，这时你再 git push 既可以把线上的代码更新，也不会像 reset 造成冲突的问题。 1git revert commit_id revert 与 reset 区别reset 是在正常的 commit 历史，删除了指定的 commit，这时 HEAD 是向后移动了。而 revert 是在正常的 commit 历史中再 commit 一次，只不过是反向提交，它的 HEAD 是一直向前的。 如果在日后现有分支和历史分支需要合并的时候，reset 恢复部分的代码依然会出现在历史分支里，但是 revert 方式提交的 commit 并不会出现在历史分支里。 参考图解Git：https://marklodato.github.io/visual-git-guide/index-en.html 官方手册：https://git-scm.com/book/zh/v2/]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1次书签同步的误操作后]]></title>
    <url>%2Fblog%2F2017%2F02%2Fa-mistake-of-collection.html</url>
    <content type="text"><![CDATA[事情经过是这样的，可能 chrome 自动升级后，当我让 chrome 帮我记住密码时，突然弹出登录谷歌账号。由于公司电脑，我以前故意不登录，以免同步在学校时用的一堆过时书签。但就在今天，我手抖了，忘了这个事，输完 google 账号后它旧开始帮我同步 bookmarks 了！然而网速很快，一眨眼就还原到我学生时代的收藏夹了。。。 满满的回忆，在学校的最后两年里，自己网上找资料学前端，整个实验室近20号人就我独爱前端，chrome 存了一堆书签，evernote 里也收藏了上百条文章。在我准备校招面试期间，都有把这些回顾看过。 Web里内容太广，什么都看过一点，还有本科时一直学的Java，这差不多是我在学校里了解过的所有分类 然而问题来了。。。在学校里主要积累知识的广度，因为做的“产品”并不会有百万数量级的用户和并发，所用的解决方案只要够用就行了，主要还是考察如何更快更廉价的满足需求，遇到问题时可以选择绕过问题，而不是解决问题。 于是到了公司，看见什么都感觉“咦 这感觉和以前看过的啥啥类似”，想搞的方向太多，最后什么也没搞。。戒骄戒躁，就抓一两个点，做到极致]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入prototype]]></title>
    <url>%2Fblog%2F2017%2F01%2Fprototype-in-detail.html</url>
    <content type="text"><![CDATA[来自一个知乎上的讨论 Mark key points here.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(非专业)如何快速建站]]></title>
    <url>%2Fblog%2F2017%2F01%2Fnon-technical-site-making.html</url>
    <content type="text"><![CDATA[本文针对非软件行业人士，如何快速建站。这样的建站需求大多是面向中小公司，或者个体工商户，我大致分为两类。一类是门户型，只做内容的宣传或者产品引导，不涉及到客户公司的具体业务。另一类是业务型，即需要在网站上完成客户的具体业务，比如购买，或者收集用户的行为。 门户型网站这类网站需求都比较简单，简单点都是放些公司的介绍、业务范围、联系方式等宣传材料就行了，再放个公司位置的百度地图，顶多再接个留言功能。另外的话，需要有个管理后台，可以让客户自己修改页面文章的内容。 这类简单的门户型网站，找专业开发人员的话，估价在 3000 元左右，视个人或网站行业而定。若要求特殊的效果，比如3D场景，或者需要高度定制的交互效果的话，价格大几千或上至万元也是可能的（比如这种）。 对于前者简单的网站，没必要找专业人员开发，一般千元以内就能搞定，那就是使用“建站产品”。我这儿推荐两款： 1. 建站之星：http://www.sitestar.cn/建站之星是美橙互联旗下的板块，可以到官网的企业建站板块下看。付的费用其实就是买“模板”，几百块就能买一个。同时它也提供了私人订制的服务，那就贵了，几千和上万的都有。 为什么我推荐这家公司的建站产品呢，因为我博客的域名就是在美橙互联上买的，它是国内比较早的搞域名注册和服务器托管的公司了，应该比阿里云和万网（原来是 www.net.cn）都要早。因此论公司资质的话，“建站之星”作为美橙互联公司的企业建站产品，应该靠谱。 这是建站的套餐价格，包含了服务器租费(占大头)、域名费(很便宜)、以及建站模板和后台服务费。 注：这里的“网店版”即我后面要说的业务型网站 2. 凡科：http://www.faisco.com/凡科的建站产品是我在知乎里看到的，该公司成立于2009年，相比美橙互联的公司资质稍逊，这一点可以从它们的官网上很容易感觉出来。 凡科最大的一个优势就是价格，并且它提供免费版，可以先试用看效果。各版本的功能对比可详见：http://jz.faisco.com/proFunc.html 最后看各人选择，想要长期稳定的话就选建站之星，毕竟公司规模大，配套设施多；但想要节约成本的话，可以先用凡科看是否能达到预期效果。这里有个对两者产品的使用评测：http://jz.faisco.com/news/443 业务型网站其实上面介绍门户型网站的两个公司里也都包含“营销版”/“商城版”的产品，即业务型网站。 1. 微盟：http://weimob.com/微盟在微信公众号开放后开始火了起来，我两三年前就听说过。当时有个被炒起来的概念“微商”，而微盟抓住了这条船，把微信商城做了起来。我前几天有专门打过咨询电话，了解到他们去年就得到了腾讯的投资，腾讯已是他们第二大股东。不言而论，微盟的微信商城产品肯定是市面上与微信结合做得最好的产品之一。（2017.1.10日更新，微盟已打通微信小程序，详见使用说明） 这款产品叫微盟旺铺，我在微盟官网找了个客户案例：http://318325.m.weimob.com/vshop/index 可用以下二维码查看 2. 千米网：http://www.qianmi.com/千米网是我在南京软件开发者大会上了解的这家公司，公司总部在南京，应该说是在江苏内做电商产品的较专业的公司。其实在前面介绍门户型网站时，建站之星和凡科的“营销版”/“网店版”也能满足商城的需求，但我会更倾向专一做电商解决方案的千米网的云商城产品。主打“魔方建站”的概念，即像玩魔方一样，一转就是一个面，电商的各个面。 这是联系他们售前顾问，找到了一个示例：http://store148551.b2c.1000.com/ （注意这是测试的站点，请不要真下单） 手机版/微信版的演示如图 可用以下二维码体验 产品对比 微盟 - 旺铺 千米网 - 云商城 年费 10800 6800 PC版 无 有 手机版(手机浏览器) 有 有 微信版 同手机版 同手机版 搭建时间成本 全包，1~2周交付 提供教程，需要自己动手 绑定域名 不支持（统一在 m.weimob.com 下） 支持 绑定微信公众号 支持，如果是微信服务号的话，可以互通 支持，但仅是加个菜单链接 支付宝付款 支持 不支持 微信付款 支持 支持 银行卡付款 支持 支持 余额充值 不支持 支持，但作为买家一般不愿意充 购物需否注册 不需要，直接与买家微信绑定 需要注册独立账号 订单跟踪 可在微信服务号中查看 需要从公众号菜单进入商城再查看 客服支持系统 未询问 （期待与微信服务号的消息平台整合） 由合作的第三方公司提供客服系统 合作价 199元/年 总结 要想和微信结合紧密，就用微盟的产品 优点是全包，把商品素材和微信服务号授权给他们，帮你全串通 缺陷是不能绑定独立域名，也就不能使用百度来推广 建议之后可考虑使用建站之星或凡科，做企业门户网站，绑定独立域名，使用百度推广，再在网站里引导用户关注与商城绑定的公众号 要想一次性搞定 PC 和 手机版 统一的商城，就用千米云商城 缺点是需要手工操作的部分比较多 优点是一次性就支持域名，可为 PC 和 手机版 分别绑定二级域名 但我不是很建议把 PC 版也做成商城，因为PC上的订单量只占20%，这是淘宝天猫的数据 网站运营顺应现在 Mobile First 的潮流，我的建站思路是 先做好移动版的站点，一开始不要在 PC 版投入过多人力财力 使用微信公众号来运营网站，初期不建议做独立 App，费钱且黏度比微信低 待积累一定量客户后，再做一个 PC 版的主页，引流到公众号。如果体量真的上去了，再考虑做 PC 上的业务系统 1. 微信运营微信公众号的申请是免费的，建议使用公司名义去注册。使用公司营业执照完成认证，只需 300元 的年费，但这样就可以升级为微信“服务号”，拥有更多的能力。 微信有配套的后台系统，可管理公众号的菜单，推送消息文章。找人做些软文和内容策划，运营的成本很低。 2. 百度推广百度推广是百度重要的收入来源，其两大重要产品就是关键词排名和网盟推广。关键词就不多说了，网盟推广就是指在与百度合作的上百万家网站的广告位上推送你的网站和图片链接。 我也咨询过百度推广的销售顾问，首次开通的话需要 1000元开通费 + 5000元广告费。其中，如果你已有独立域名的网站，1000元开通费会在3个月后返回到余额账户中。而广告费是按次数扣费的，即用户通过百度的推广点击进入你的网站，网站显示正常的话就要扣1次费。 竞价排名，这个词也许听说过，是指对具体一个关键词的出价，出价越高则会越优先显示在搜索结果的前排。但也并不绝对，假设你现在的出价可以排在搜索的前3页，仍然可以通过对网站标题和内容的更新，主要是内容要有新意，keywords 写得好，慢慢地你的网站是可以上升到第1页的。这就是所谓的 SEO 优化。 我听销售顾问这么说，一般不是很通用很常见的关键词，只要出到关键词的平均价，一般都能挤进前两页，后期就靠网站运营慢慢提升排名。而这关键词的价格，要根据所覆盖的城市，南京一个价，江苏一个价，江浙沪又是一个价，要覆盖全国就更贵了。 我这儿只能提供一个粗略的数字，1~3元/次，都是普通词语（不是热门词）的平均价，可以估算下自己网站推广的预算。一个推广账号里可以配置1万个关键词，要对每个词语都出价，扣费也是对每个词语累计的。 数据统计服务网站做了后，运营起来后，当然还需要经常观察下网站的使用情况，包括最基本的 PV / UV 这样的数据，进阶些可能要看各页面的访问量分布以及新老用户的占比。再高级些也许还要查看一些转化率数据，比如从 商品详情=&gt;加入购物车=&gt;下单，每个步骤的转化比例。 对于这样的数据统计和观察需求，我首推百度统计，不仅仅是因为我这个博客也使用了它，而是这两三年里我确实看到了它在进步。（关键还是免费的） 参考资料知乎讨论：https://www.zhihu.com/question/26027774 建站之星：http://www.sitestar.cn/ 凡科建站：http://jz.faisco.com/ 微盟首页：http://weimob.com/ 旺铺宣传页：http://www.weimob.com/website/topic/wangpu 旺铺产品手册：http://www.weimob.com/website/site/help?help=12 千米网-云商城：http://www.qianmi.com/products/ysc/ 百度推广：http://e.baidu.com/ 百度统计：http://tongji.baidu.com/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016: 生活不止眼前的苟且]]></title>
    <url>%2Fblog%2F2016%2F12%2Fthe-end-of-2016.html</url>
    <content type="text"><![CDATA[今天圣诞节，可是第一次一个人在外面，还下着雨，未免有些凉意。还是和以往一样，周末没什么事的话就来公司吧，至少吹着暖气，座位舒服些。最近两三个月有了点决心，每天都能早起，早早的来公司，能避开一波公交高峰。相当标准的三点一线生活，每天的步数都能踩到 6~7 千之间，要说不累还真有点累，要说无聊还真有点无聊。 一、昨天看到阮一峰老师的文章，第一句就是“人生没有大变化，一整年都在工作”。他的 github 状态也是变态到令人颤抖。。。 恭喜阮老师，我居然找到了一个空白的格子。。。 我的导师也和他一样，是个全年工作的疯子。我很佩服，看着实验室越来越强大，陈老板正在一步步走向巅峰，是身边最真实的励志鸡汤。 二、我很庆幸自己遇到了陈老板，我不太会表达，经常词不达意。大四那年我还是个只顾着自己，有点不羁，还yy着哪天一个人跑到荒山野外去看大自然的奇妙。了解我的朋友或许知道那段时间我经常一个人骑车、睡觉、锻炼、吃饭，生活就是这样的循环。 真正成长的时候在 2014 年，那年开始学习了开了博客，还学了驾照，那年开始认真给老板干活，拿了不少报酬。还有，那年认识了我的那个她。 三、要说今年都干了啥，无非都和老板和我的她有关。通过陈老板认识了另一位“老板”，可他并不像自己老板那样，他更像个“商人”也许这才是真正的“老板”。陈老板推荐了我，牵头给“老板”做了一个产品的原型，过程有点辛酸，期间身体还犯了老毛病，年初时动了手术，恢复了好久。生活就是在医院、电脑、和床之间切换，还有那个我担心她、她又担心我的那个她。 四、顺利毕业了，陈老板绝对是中国良心老板，他让你明白，在这里你可以干自己喜欢的事，但你不能什么都不干。也没发过一篇论文，但托老板的福，去过了北京、桂林、厦门，还有新加坡，非常棒！只是以前答应过我的那个她要一起去哪里哪里，结果都变成了我蹭了老板一个人去浪了。 五、老板的十年，从一穷二白变成了一“穷”二娃，这碗鸡汤我会继续熬下去。要说一点都不羡慕别人那是假话，但至少现在还有公平的机会可以创造可能。明年一定要带我的那个她去一次说走就走的旅行。 这样就这样，我仍是一个不太会表达的人。 window.MusicUtil.insertIframe('//music.163.com/outchain/player?type=2&id=167802&auto=1&height=66');]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之 domReady]]></title>
    <url>%2Fblog%2F2016%2F12%2Fcode-patterns-of-dom-ready.html</url>
    <content type="text"><![CDATA[第一次看到 domReady 这个字眼是在 jquery 中，即 document ready。之后也见到一些别人的代码里有 DOMContentLoaded，它和页面的 onload 有什么关系，以及和 document ready 有何渊源。以前都见过这些词，但都似懂非懂，今天查了些资料收集了些代码，做个完整的理解。 第一印象在 jquery 中，我们的第一个 hello world 程序，教程中可能会教如下的写法： 123$(document).ready(function () &#123; // $('#el').on('click', function () &#123;&#125;)&#125;); jquery 也提供了一个更简洁的写法，即 $(function(){...}) 那这样套了一层后，能保证里面的 js 代码会在页面 DOM 树都解析完后再执行。 12345678910&lt;head&gt; &lt;script&gt; $(function () &#123; $('#el').html('hello'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="el"&gt;&lt;/div&gt;&lt;/body&gt; 因为很久以前，我们都是习惯把 &lt;script&gt; 写在 &lt;head&gt; 中，而我们知道浏览器在解析 HTML 时，遇到 script 是会阻塞 DOM 的解析（准确来说是增加 DOM 解析的回溯）。因为浏览器要知道 script 里对页面干了哪些事，可能元素又会变化，所以要等中途的 script 执行完才能继续解析渲染后面的 DOM element。 我们可以拿下面的代码做个实验： 1234567&lt;body&gt; &lt;h1&gt;hahaha&lt;/h1&gt; &lt;script&gt; debugger &lt;/script&gt; &lt;div id="el"&gt;can you see me&lt;/div&gt;&lt;/body&gt; 在浏览器中开 debug 模式，可以看到停在这行时，页面中能看到 &lt;h1&gt; 元素，但下面那个 &lt;div&gt; 还未解析到 DOM 树中。 因此，为了避免在文档还未解析完成前就操作 DOM（可能会报错），也为了让 非页面前置依赖 的脚本在 DOM 解析完后再执行，所有教程上都建议把能放在最后的脚本都放在最后。 123456789&lt;body&gt; &lt;h1&gt;hahaha&lt;/h1 &lt;div id="el"&gt;can you see me&lt;/div&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;script&gt; // 页面交互逻辑 ... &lt;/script&gt;&lt;/body&gt; 回到最前面，$(document).ready(fn) 就是用来保证，如果不小心将 script 提到了前面，或者出于某些考虑一定要 script 提前，那么它将保证文档 DOM 都解析完后再执行 fn 内部的 js 逻辑。 要理解 document ready，首先得看下 document 的文档状态。 文档状态文档加载的状态都在 document.readyState 中，具体可参见 MDN 上的定义，它有三个状态值： loading：文档还在加载 interactive：document 已加载并解析完，但文档里的资源（如样式、图片、iframe）仍在加载中 complete：document 和文档里的资源都已加载完，意味着将触发 load 事件 readystatechange 事件当 document.readyState 值变化时，会触发 readystatechange 事件，可以用以下代码监听： 12345678document.onreadystatechange = function () &#123; if (document.readyState === 'interactive') &#123; // initLoader ... &#125; else if (document.readyState === 'complete') &#123; // initApp ... &#125;&#125; 等价的写法也可以是这样 123document.addEventListener('readystatechange', function (event) &#123; // event.target.readyState&#125;); DOMContentLoaded VS onload从 MDN 的定义中可以明确两件事 DOMContentLoaded 在 document.readyState === &#39;interactive&#39; 时触发，即页面 DOM 树已有，但样式、图片等资源还在加载中。 window.onload 在 document.readyState === &#39;complete&#39; 时触发，即页面 DOM 和其他资源都已加载完成。 123456789document.addEventListener('DOMContentLoaded', function(event) &#123; // 等同于 onreadystatechange 中的 // document.readyState === 'interactive'&#125;);window.onload = function() &#123; // 等同于 onreadystatechange 中的 // document.readyState === 'complete'&#125;); 后者还可以写成 window.addEventListener(&#39;load&#39;, function(event) {})，但要注意下 addEventListener 的兼容性方式（attachEvent）。 还有更多文档状态的事件，关于 unload &amp; beforeunload 可参见MDN示例，这里先跳过了。 Polyfill从上一小节中可以看到，判断页面加载的状态，关键是 readystatechange 事件，在一个事件回调中可以判断 document.readyState 的三种状态。那这么 diao 的方式一定会存在兼容性问题的， 来自MDN： Internet Explorer 8 supports the readystatechange event, which can be used to detect when the DOM is ready. In earlier versions of Internet Explorer, this state can be detected by repeatedly trying to execute document.documentElement.doScroll(“left”);, as this snippet will throw an error until the DOM is ready. 本文最初提到的 $(document).ready(fn)，等同于 DOMContentLoaded 的触发时刻，即 document.readyState === &#39;interactive&#39; 的时刻。因此 jquery 在实现 ready 函数时，肯定要有很多兼容性的考虑。 初步兼容123456789101112131415161718192021document.ready = function (callback) &#123; // 兼容 FF, Chrome if (document.addEventListener) &#123; document.addEventListener('DOMContentLoaded', function () &#123; document.removeEventListener('DOMContentLoaded', arguments.callee, false); callback(); &#125;, false) &#125; // 兼容 IE else if (document.attachEvent) &#123; document.attachEvent('onreadytstatechange', function () &#123; if (document.readyState == 'complete') &#123; document.detachEvent('onreadystatechange', arguments.callee); callback(); &#125; &#125;) &#125; else if (document.lastChild == document.body) &#123; callback(); &#125;&#125; 这是网上收集的一段实现 ready 的代码，但是从上面 MDN 的定义中知道，IE 8 以下是不支持 onreadystatechange 事件的。 深度兼容123456789101112131415161718192021222324252627282930313233343536373839404142(function () &#123; var ie = !!(window.attachEvent &amp;&amp; !window.opera); var wk = /webkit\/(\d+)/i.test(navigator.userAgent) &amp;&amp; (RegExp.$1 &lt; 525); var fn = []; var run = function () &#123; for (var i = 0; i &lt; fn.length; i++) &#123; fn[i](); &#125; &#125;; var d = document; d.ready = function (f) &#123; if (!ie &amp;&amp; !wk &amp;&amp; d.addEventListener) &#123; return d.addEventListener('DOMContentLoaded', f, false); &#125; if (fn.push(f) &gt; 1) &#123; return; &#125; if (ie) &#123; (function () &#123; try &#123; d.documentElement.doScroll('left'); run(); &#125; catch (err) &#123; setTimeout(arguments.callee, 0); &#125; &#125;)(); &#125; else if (wk) &#123; var t = setInterval(function () &#123; if (/^(loaded|complete)$/.test(d.readyState)) &#123; clearInterval(t); run(); &#125; &#125;, 0); &#125; &#125;;&#125;)(); 可以看到这里就是用了 MDN 中提到的 document.documentElement.doScroll(&quot;left&quot;)，不断循环地去执行它，直到 DOM ready 时，它就不会抛异常了。这是一种值得学习的 trick 方式。 jquery 官方实现官方实现的代码和上面大体相似，我找了 jquery 1.4.4 的版本，因为之后 1.5.x 的 ready 函数实现中引入了类似 promise 中的一些概念，所以用之前的版本更能纯粹的理解 dom ready 的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344bindReady: function() &#123; if ( readyBound ) &#123; return; &#125; readyBound = true; // Catch cases where $(document).ready() is called after the // browser event has already occurred. if ( document.readyState === "complete" ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready return setTimeout( jQuery.ready, 1 ); &#125; // Mozilla, Opera and webkit nightlies currently support this event if ( document.addEventListener ) &#123; // Use the handy event callback document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false ); // A fallback to window.onload, that will always work window.addEventListener( "load", jQuery.ready, false ); // If IE event model is used &#125; else if ( document.attachEvent ) &#123; // ensure firing before onload, // maybe late but safe also for iframes document.attachEvent("onreadystatechange", DOMContentLoaded); // A fallback to window.onload, that will always work window.attachEvent( "onload", jQuery.ready ); // If IE and not a frame // continually check to see if the document is ready var toplevel = false; try &#123; toplevel = window.frameElement == null; &#125; catch(e) &#123;&#125; if ( document.documentElement.doScroll &amp;&amp; toplevel ) &#123; doScrollCheck(); &#125; &#125;&#125; jquery 中 ready 函数最核心的部分就是上面这段，和前面深度兼容的原理大体一致，但有一些特殊的 fallback 处理，还判断了在 IE 中是否是顶层 frame。源代码可参见以下链接： ready 函数入口 bindReady DOMContentLoaded handler doScrollCheck 检测trick jQuery.ready 执行逻辑 第一次认真学习 jquery 源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之 RAF]]></title>
    <url>%2Fblog%2F2016%2F12%2Fcode-patterns-of-js-raf.html</url>
    <content type="text"><![CDATA[RAF(requestAnimationFrame) 在好多地方都有见到过，只知道它和浏览器的动画有点关系，它到底是个什么鬼，有啥作用有啥好处，今天查了一些资料和以往的笔记，做个整理。 什么是 RAF回想第一次见到 requestAnimationFrame 应该是当时在公司实习的时候，经常看到它常常和 setTimeout 同时出现，比如下面这样的代码片段 1234567var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) &#123; // 保证 60fps 帧率的流畅效果，每帧间隔 16.7 ms window.setTimeout(callback, 1000 / 60); &#125;; 第一印象：这货和动画有关，and 这货可以用 setTimeout 来模拟。 关于它们两者的关系，可以看张鑫旭的科普文章，可以明确两件事： 递归调用 setTimeout 来做动画时，如果间隔时间选择不当，或者中途有其他 timer 任务乱入时，会导致动画卡顿 而 requestAnimationFrame 会跟着浏览器的绘制走，由浏览器来保证它的执行间隔时间（60fps 的动画相当于 16.7ms 一帧） 官网解释 The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint. 以上是来自 MDN 的解释，链接里还包含了 demo 代码，以及它的兼容性情况。 特别需要注意的是：在页面当前不在活动状态下，requestAnimationFrame是不会运行的，而 setTimeout 仍会在后台运行。 我举个不一定恰当的类比：如果 setTimeout 是不停重设元素 position 来做的动画，那 requestAnimationFrame 就好比是 CSS3 transition 动画。效果和性能，显然后者胜于前者。 PolyfillRAF 既然这么好的东西，显然是存在兼容问题的，在上面 MDN 链接里可以看到，IE 10+，不容乐观啊。。。所以本文最初第一印象的那段代码可以视为一种 Polyfill (可以理解为“备胎”函数) 查了网上的解决方案，包括 淘宝 也使用了这套 Polyfill： 12345678910111213141516171819202122232425262728// http://paulirish.com/2011/requestanimationframe-for-smart-animating/// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel// MIT license(function() &#123; var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;; &#125;&#125;()); 关键是 timeToCall 的计算，保证每次调用 requestAnimationFrame 都是在浏览器的空闲期（前一帧动画已经执行完）。相比只使用 setTimeout，可以减少动画丢帧的情况。 应用场景应用1：确保页面onload12345678910111213onLoad: function(callback) &#123; var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(fun) &#123; setTimeout(fun, 16); &#125;; if (document.readyState === 'complete') &#123; rAF(callback); &#125; else &#123; window.addEventListener('load', function() &#123; rAF(callback); &#125;); &#125;&#125; 上述效果即 window.onload()，确保了 callback 都在 RAF 中有序的执行，减少了执行 onload 回调时页面卡顿（丢帧）的发生情况。（2017.1.6日更新）现在我觉得是避免 onload 时页面已不处于 active 状态（比如用户切换了浏览器标签），因此用 RAF 可以保证页面在 active 时才执行回调。 应用2：改进动画性能12345678910111213141516171819202122232425var requestAnimFrame = window.requestAnimationFrame || (function () &#123; var timeLast = 0; return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) &#123; var timeCurrent = (new Date()).getTime(); var timeDelta; /* Dynamically set the delay on a per-tick basis to more closely match 60fps. */ /* Technique by Erik Moller. MIT license. */ timeDelta = Math.max(0, 16 - (timeCurrent - timeLast)); timeLast = timeCurrent + timeDelta; return setTimeout(function () &#123; callback(timeCurrent + timeDelta); &#125;, timeDelta); &#125;;&#125;)();// 递归调用 timeoutself.timer = setTimeout(function () &#123; // 保证在上一次动画结束后再执行 // 若页面不在 active 状态下，requestAnimFrame 不会执行 // 相比 “递归 setTimeout” 动画会一直运行，节省CPU（尤其在移动端） requestAnimFrame(function () &#123; clearTimeout(self.timer); self.next(); &#125;);&#125;, self.timeout); 注：这个动画方案主要用在 app 内嵌 webview 的页面中，当 app 不在活动状态时（在后台驻着），递归的 setTimeout 仍会执行下去，会导致后台CPU使用率升高。而 requestAnimFrame 只会在页面重绘的时候调用，当页面不在 active 时，RAF 的回调并不会执行。 应用3：模块懒加载1234567891011121314151617181920212223242526var __lazyLoaded = false;function runLazyQueue() &#123; if(__lazyLoaded) &#123; return; &#125; __lazyLoaded = true; $(window).detach("mousemove scroll mousedown touchstart touchmove keydown resize onload", runLazyQueue); var module; while (module = lazyQueue.shift()) &#123; ~function(m)&#123; // 保证在浏览器空闲时间处理 JS 程序, 保证不阻塞 window.requestAnimationFrame(function() &#123; new Loader(m.$mod, m.data, m.force); &#125;); &#125;(module); &#125;&#125;$(window).on("mousemove scroll mousedown touchstart touchmove keydown resize onload", runLazyQueue);// 担心未触发 onload 事件, 5s 之后执行懒加载队列window.requestAnimationFrame(function() &#123; runLazyQueue();&#125;, 5000); 主要用于当页面上有很多个模块组成的时候（尤其是一些商品活动页面），每个模块都有自己的 js 执行逻辑，而在页面加载后，没必要一下子把所有模块的 js 逻辑都执行一遍。这里便采用的是当用户操作（例如滚动页面）时，才执行各模块的 js。 我们可以结合之前的常用模式片段之JS视窗，改进懒加载的逻辑：当模块处在当前视窗的一定范围内时，才执行该模块的 js 代码。 requestAnimationFrame 是个好东西 （以下 2017.1.6日补充） 应用4：函数节流[引自：ghugo.com] 在高频率事件中，为了防止16ms内发生多次函数执行，使用 raf 可保证16ms内只触发一次，这既能保证流畅性也能更好的节省函数执行的开销。16ms内函数执行多次没有意义，因为显示器16ms刷新一次，多次执行并不会在界面上有任何显示。 12345678$box.on('mousemove', function(e)&#123; requestAnimationFrame(function()&#123; $point.css(&#123; top : e.pageY, left : e.pageX &#125;) &#125;)&#125;) [引自：404forest.com] 认为在循环体中调用 raf 并不能达到真正的函数节流，因为循环中的 raf 已经一下子执行完了，只是 raf 中的回调会按照 16ms 的频率依次排队执行。 123456789101112$(function()&#123; var lazyLoadList = [A, B, C, D]; var load = function() &#123; var module = lazyLoadList.shift(); if(module) &#123; new module(); // 要写个递归，才能真正保证一个模块加载完再执行下一个模块 window.requestAnimationFrame(load); &#125; &#125; window.requestAnimationFrame(load);&#125;) 参考文章 天猫实习时组里的大神博客：http://www.ghugo.com/requestanimationframe-best-practice/ 详细的实验对比文章：https://www.404forest.com/2016/08/15/使用%20requestAnimationFrame%20实现性能优化与懒执行/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站安全监测 - Node实战]]></title>
    <url>%2Fblog%2F2016%2F11%2Fnode-action-in-website-detection.html</url>
    <content type="text"><![CDATA[（拖了近一年的文章）去年这个时候接了一个心力交瘁的项目，大体目标是：1、为用户的网站提供安全监测的服务，用户在我们的管理端系统中添加一个站点并勾选要检测的项；2、然后由后台爬虫系统完成用户站点链接的入库，并定时针对站内链接执行各种检测任务；3、再由前端系统给用户交付网站监测报表。在中间这一步，最重要的爬虫系统，我第一次学习用 Nodejs 来做。 Node起步安装 nvm 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash node 0.12.x 1nvm install 0.12 cnpm 镜像 1npm install --registry=http://r.cnpmjs.org -g cnpm debug 工具 12cnpm install -g node-inspectornode-debug yourApp.js 教程 Node.js 包教不包会 中文API文档 一些库 用于爬虫 superagent 处理请求的模块 request 另一个处理请求的模块，比起 superagent，语法配置项更多一些。如果说 superagent 是 $.post()，那 request 就是 $.ajax() cheerio 用于DOM解析，提供与 jquery 选择器类似的接口 异步流程控制 Q in Github Promise 化的一种实现，promise 不是万能，改造复杂的动态决定的执行链是比较烦的事情 async 点赞数很高的库，有人说有毒，我觉着很好用 eventproxy @朴灵的基于事件的流程控制，我觉着和 promise 或 async 搭配着使用很好用 主程序设计在摘要中已经提到，这个项目的目标分为3步：添加检测任务 =&gt; 爬虫执行任务 =&gt; 前端报表展现。但在具体实现时，需要对爬虫进行细分，最终会有6步过程。 1、添加要监测的站点 在web端添加一个站点任务，输入客户的摘要信息以及要监控的站点列表，然后可以更改检测类别的周期以及具体检测项等配置。 “可用性”检测主要是网站的一些基本信息，通常都在首页的 http 头中就能找到。而“内容检测”需要对网站中的所有页面进行检测，因此会有一个“检测深度”和“最大页数”的配置，页面深度越深，页面数目会呈指数级增长，这对爬虫服务器是巨大的压力。 此外还有一个“安全检测”的模块，具体检测项有：ActiveX挂马，iframe挂马，js挂马，WebShell后门，暗链，以及后台地址检测。由于我对安全方面了解太少，在这个系统中实现得也很simple，就不多说了。。。 2、站点入库由于上面“内容检测”和“安全检测”都需要对网站首页下的其他页面全部检测，因此我们需要维护一个 site 表和 site_link 表，记录下网站的域名和 ip 信息，并且存下每个页面链接的信息，包括该页面相对于首页的深度层级，该页面的链接是 同源、同域 还是 外链，以及页面的发现时间、状态信息等。 另外注意的是，从首页开始取链接，然后再对链接再取它的后继链接，整个过程应采用“广度优先”的策略。而“检测深度”和“最大页数”也是在这个时候进行限制的，如果当前页面深度为 N，N + 1 &gt; 检测深度，那么该页面就不再往爬取队列中 push 后继链接了。 3、周期性生成检测任务站点任务配置完，站点链接也入完库，这时候就可以根据上面配置的检测周期来定时产生任务。例如当内容检查的周期到来时，需要取出该站点下所有符合的页面链接，对每个页面的每个检测项都生成1个检测任务。 需要注意生成任务时，要按照页面链接的顺序来遍历，而不是先遍历检测项。这样的好处是当具体爬虫执行时，相同 url 的检测任务在队列中会连续挨着，这样可以给爬虫做爬取的合并，同样的 url 只需要爬取1遍，就可以给不同的检测任务去执行。 4、爬虫执行检测任务如果说第3步生成任务是“生产者”，那么现在就轮到“消费者”。爬虫系统要支持并发，多机器 + 多线程。在1台机器上，1次从任务队列中取100个出来，如第3步所说检测任务是按相同url连续排列的，那么这100个检测任务可以抽出20个任务组（举个例子），每个任务组都可以只爬取1个页面，然后将内容传递给各检测项去执行。而每个检测项的执行结果都以 log 的形式存储。 如果爬虫的机器不是那种“树莓派”微型机器，那可以先将 log 以文件形式存到本地，留出带宽给爬虫。或者每个检测项的结果 log 都发送到1个指定的地方，这就会多占用带宽，也需要专门搞1台日志服务器。 5、定时计算日志爬虫的任务执行过程是很连续又很离散的，连续是因为做完1个就要做下1个，离散是说日志的离散，单独1个页面的1个检测项的1次执行日志并没有太大意义，要整合到整个站点和时间段、检测类别的维度来看才有价值。从前面的步骤可以看到，站点链接的入库以及周期性的生成任务时，会有一定的“顺序”控制，并且只有全部入完库才会进入下一步骤。而爬虫系统是很离散的，它可能分布到多台机器上，只要任务队列中有东西，它就会取出来执行，也不会区分任务是来自哪个站点哪个类别的。 因此，如果 log 分布在各爬虫机器上，那就需要一个定时的脚本对其进行汇总计算后传回数据中心。而如果有统一的日志服务器，那同样需要将原始日志计算成有效的数据。 6、前端报表查询前端系统直接查数据中心，可以得到站点级和检测类别级的报告。前面“生产者”生成检测任务时，会在数据库中打上一些任务模块的时间信息，前端系统也能够查到一些调度状态信息。 架构图整个系统分为4个部分：前端系统、任务Producer、爬虫系统、日志计算同步进程。架构图如下，可以看到箭头就代表着数据流的方向。 而爬虫调度和执行是典型的“生产者-消费者”模式，这里生产者只有1个，而有N个消费者爬虫进程。 所谓的检测任务队列，实际就是数据库中的一张表，多个爬虫进程或多台爬虫机器都共享这张表，只要保证从表的顶部开始读取，读完后就要重置状态位，防止被其他进程重复读取。而当任务执行失败后，会将该检测任务的记录移到 table 的队尾，并设置1个失败次数的字段。 爬虫实现思路技术框架在本文第一节中就列出了一些库，在页面爬取方面，使用 superagent 获取页面内容，使用 cheerio 做文档解析。而对于一些不需要解析内容的爬取任务（比如查询某个页面的 header 信息，或是检查某个页面是否 200 状态），使用 request 来发请求。 对于爬虫系统中最关键的异步流控制，我在实现时做了多种风格的尝试，在数据库读写层面使用 promise 风格，在检测项内部使用 async，而在爬虫的实例中使用 eventproxy 来进行流控制。 目录结构 base/ 跟继承和通用相关的 conf/ 各种配置项（检测项的配置、规则的配置） constant/ 各种常量的定义和配置 database/ 数据库配置和连接池 models/ 数据库表对应的 json schema dao/ 与 model 相应的 Dao 增删改查封装 util/ 通用数据的helper factory/ 工厂封装类，统一任务的组建过程 modules/ 具体检测项 (爬虫上搭载的具体task实现) basic/ 基础信息 可用性检测 content/ 内容检测大类 secure/ 安全检测大类 common/ 站点入库、链接入库，以及抓取页面内容也抽象成1个通用task crawler/ 爬虫对象与池管理（1个crawler实例只负责1次页面请求） scheduler/ 监控和调度进程 (每隔一段时间就执行一轮) runner.js 用来执行检测任务 (任务消费者) siteRunner.js 针对“站点链接入库”的 runner app.js 主程序，用来启动 runner appSite.js 主程序之一，用来启动 SiteRunner appPath.js 用来启动低频高请求量的检测任务（详见下面的地址型检测类） 爬虫实现流程由上面的结构可以看到，程序运行时的调用过程是：app.js =&gt; runner.js =&gt; crawler =&gt; 具体检测项。 app.js其中 app.js 只是个程序入口，里面构造了一些参数给 runner，代表性的参数有：runner 每轮执行时取出的任务数量（即1个消费者每次消耗的数量），以及每轮执行之间的间隔时间（因为执行1轮任务时会有 N 个请求，如果不做间隔时间的限制，同时等待请求响应的线程太多会爆）。 runner.jsrunner.js 首先提供1个支持间隔时间的循环执行接口，这里使用 async 库来实现。 123456789101112131415161718192021222324252627282930313233RunnerBase.prototype = &#123; start: function()&#123; var that = this; that._count = 0; async.whilst( function()&#123; if(that.loopCount)&#123; return that._count &lt; that.loopCount; &#125; return true; &#125;, function (callback)&#123; // 第一次立即执行 if(!that._count)&#123; that._count = 1; that.run(); callback(null, that._count); &#125; else&#123; that._count++; setTimeout(function()&#123; that.run(); callback(null, that._count); &#125;, that.loopInterval || 10000); // 默认10秒间隔 &#125; &#125;, function (n)&#123; console.log('Runner with [n=' + n + ']'); &#125; ); &#125;&#125;; 而 runner 中的run()方法就是每轮具体要执行的操作，它其实整体是个串行过程，有以下步骤： 1、取出数据库中的任务队列中靠前的 N 个任务 2、如果取出为空，直接跳到第6步 3、将任务状态标为 PROCESSING 4、对 N 个任务按检测的 url 重新分组，比如得到 M 个组，则构造 M 个 Crawler 实例（这里设计的准则就是1个 Crawler 实例只爬取1个页面） 5、使用 async.parallel 并行执行 M 个 Crawler 的 run() 方法 6、一轮 runner 执行结束 这里整体是串行，使用了 eventproxy 来进行流程控制 1234567891011121314Runner.prototype.run = function(cb)&#123; var that = this; var ep = new EventProxy(); // 统一错误处理 TODO ep.fail(function (err)&#123; console.log(err); &#125;); // 各步骤一起调用，通过 event信号 等待 Runner.steps.forEach(function (fn)&#123; fn.call(that, ep, cb); &#125;);&#125; 而其中最关键的步骤是并行执行 M 个 Crawler，其实现原理如下 12345678910111213141516171819202122232425262728293031323334353637383940414243function (ep)&#123; var that = this; ep.on('crawlerReady', function (crawlers)&#123; // 构造 async.parallel 的执行函数 var threads = crawlers.map(function (crawler)&#123; return function (callback)&#123; // run前的累计 that.crawlerCount++; crawler.run(function (err)&#123; // run完的累计 that.crawlerCountDone++; if (err)&#123; console.log(err); callback(err); &#125; else &#123; callback(null); &#125; &#125;); &#125; &#125;); async.parallel(threads, function (err, res)&#123; console.log('[OK] 并行Crawler[len=' + threads.length + ']执行完毕'); &#125;); // 这里释放信号不能放在 async.parallel 的回调里，以防有爬虫挂了就卡死了 // 直接到最后1步，可在每轮的最后看到爬虫累计的页面数目，and 爬虫监控池 TODO ep.emit('crawlerDone'); &#125;);&#125;,function (ep, cb)&#123; var that = this; ep.on('crawlerDone', function()&#123; console.log('[OK] 消费者1轮, ' + '累计爬了 ' + that.crawlerCount + ' 个页面, ' + '累计结束 ' + that.crawlerCountDone + ' 个页面'); cb &amp;&amp; cb(); &#125;);&#125; crawler.js上面已经提到了多次：1个 Crawler 对象只负责 1次 页面请求，在 Crawler 对象中主要记录着分组后的任务数组，它们有着同样的目标 url。先请求页面 url，得到页面文档后将内容依次传递给各检测项去各自执行任务。所以总的来说，这里也是一个串行过程，具体步骤如下： 1、将分组后的任务，通过任务类型的 key，反射到具体的类，得到可执行的任务对象的数组。 2、调用请求页面内容的通用检测项，作为 starter 3、将页面内容的文档作为 context 入参，依次调用各任务对象的数组 4、任务全部完成后，在数据库中将其移出队列；若失败，则先移除，计失败次数+1，然后重新插入队尾 这里也是用 eventproxy 控制流程的，其中关键的 context 传参调用各任务对象，实现如下 1234567891011121314function (ep)&#123; var that = this; // 使 task.run() 结果按顺序排列 ep.after('oneTaskFinished', that.tasks.length, function (results)&#123; ep.emit('allTasksFinished', results); &#125;); ep.on('starterFinished', function (context)&#123; that.tasks.forEach(function (task)&#123; task.run(context, ep.group('oneTaskFinished')); &#125;); &#125;);&#125;, 注意，使用 ep.group() 方法可以保证得到的执行结果的顺序是与调用顺序一致的，而各 task 的执行是并行的。 检测项工作模式反射原理在上面讲 crawler 的第1步中提到：将分组后的任务，通过任务类型的key，反射到具体的类。因为从数据库任务队列取来的检测任务只会含有 模板url / 检测大类 / 检测项小类 这样的数据，所以就要反射到具体的检测类来构造对象。 “反射”是强类型编程语言中的概念（我最早是在 Java 中了解的），而 js 天然的弱类型和动态特性，很容易实现。 12345// 根据命名规则，取检测模块的引用getModuleFromCrawlTask: function(crawlTask)&#123; var modulePath = ModuleConf.getPath(crawlTask['item_key']); return require(modulePath);&#125; 这里每个检测项任务都会带有 item_key 字段，表示具体的检测项，其实还有 mod_key，对应到系统的3大类检测：可用性，内容检测，安全检测。具体见下一段。 检测项分类1234567891011121314151617181920// 表明这个TaskItem属于哪一大类 (通用的除外)var modDict = &#123; COMMON_CRAWL: 'COMMON_CRAWL', // 通用爬取方法 如请求页面document, 取链接等 BASIC_DETECT: 'BASIC_DETECT', // 可用性检测 CONTENT_DETECT: 'CONTENT_DETECT', // 内容检测 合并了篡改检测 SECURE_DETECT: 'SECURE_DETECT' // 安全检测&#125;;// 表明这个TaskItem能否与其他合并, 能否共用1次请求var typeDict = &#123; EXCLUSIVE: 'EXCLUSIVE', // 排它性 (独占 request 的任务) INCLUSIVE: 'INCLUSIVE' // 可合并性 (只需传递 context)&#125;;// 表明这个TaskItem应该在哪个表中, 应该交给哪个Runner处理var runnerTypeDict = &#123; COMMON: 'COMMON_TASK', // 普通任务 -&gt; Runner -&gt; app.js SITE: 'SITE_TASK', // 站点入库类 -&gt; SiteRunner -&gt; appSite.js PATH: 'PATH_TASK' // 路径检测类 -&gt; Runner -&gt; appPath.js&#125;; 这里定义了两种表示任务属性的类型：INCLUSIVE 表示该任务是可以与同目标 url 的其他任务合并的，只需要请求1次页面，传递页面内容的 context 即可，详见 crawler.js 的部分实现代码。而 EXCLUSIVE 表示该任务内部要自己发请求，比如查 Whois 信息，或者要检测是否存在某些后门路径，这类任务是不可以合并的。 而 runnerType 又是另一个层面的另一种分类，在第二节主程序设计中提到过站点链接入库。我在实现时做了一层抽象，将“站点入库”和“链接入库”也视为一种检测项任务，任务放在单独的一个队列表中。这样就能共用一些 crawler 和 runner 的逻辑。 此外对于路径类检测，比如 Webshell 地址检测，或是敏感路径检测，由于规则的字典很大，1个检测项可能会有上千次请求。因此对于这类“低频”又“高请求量”的检测项，我也单独将任务放在另一个独立的队列表中，也由另一个程序入口启动。 并行与管道总结整个爬虫调度与检测项的工作流程，是“串行”与“并行”同时存在着。 由 runner 执行时每轮会取出一堆任务，生成多个 crawler 实例，这是并行的。而在每个 crawler 内部可以理解为像工厂的流水线模式，先请求页面 url，然后将页面内容一个个传递给各检测项去完成相应的提取或检测工作。每个检测项内部都会去写各自的 log 文件，最后所有检测任务都完成后，间隔一段时间后会进入下一轮 runner 的执行。 注意的是，检测项是根据目标 url 来分组的，搭载在 crawler 实例上执行的，同一组的检测项都执行完后，相应的 crawler 实例也应该销毁。而 runner 对象的实例是始终存在的，它像一个定时器一样每隔十来秒就会再触发1轮执行。同时，1个 runner 实例应该对应1个进程，多个 runner 实例应该跑在多台爬虫服务器上。 总结与不足这个项目从去年11月开始需求分析，做界面 demo，到任务分解和组装过程的设计，再到爬虫的实现，也是从零开始学 nodejs，整个过程最初都只有我1个人，对自己的挑战提升很大。熬了两三个月后才有人手帮我做日志的回收计算以及前端的报表部分，之后项目就交给他们了，他们后来做了一些安全检测项方面的强化以及多机器的部署和通信。 我在单机（Mac Air Book @2012）上运行的效率平均1小时，爬取近1万个页面，并完成剩余的内容检测项部分。在前面图中一轮取出的任务数量以及并行 Crawler 的数目，对机器的性能和网速都有要求，如果入不敷出（每轮间隔时间内都只有少数的 crawler 执行完），最终会产生很多内存错误，或者 TCP 连接数过多，也得不到结果。 我尝试后得到的经验参数是，每隔 10 秒，取 50 个任务，根据目标 url 合并完后大约有 20~30 个任务组。注：用的是云服务器，内存 2G，带宽 2M。 还是简单粗暴这个爬虫系统和检测项都还比较简陋，可以从以下方面改进： nodejs 的 cluster 尝试，能否对爬取效率有性能提升 数据库“同步写”的锁问题，多台爬虫机器共用同一个数据库的任务队列，有性能瓶颈（或者说集中式存储的通病） 内容检测方面的篡改识别算法，目前仅用 content-length 和 md5 来判别页面更改 引入 phantomJS 来做网页截图，警示页面恶意篡改 加强安全检测方面的力度，对各种挂马和暗链的代码模式的识别 支持对检测项的扩展，能让更有经验的安全工程师编写的 python 代码也接入到系统中 TODO 在开发过程中还记录了一些遇到的问题，nodejs爬虫实现中遇到的坑 后续会慢慢整理补充 有时间再抽象出一个业务无关的可配置的“生产者-消费者”模式的网站检测框架，供学习交流]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之 sticky position]]></title>
    <url>%2Fblog%2F2016%2F10%2Fcode-patterns-of-sticky-position.html</url>
    <content type="text"><![CDATA[以前面试当被问到 css position 能取哪些值时，只回答了 relative absolute fixed 外加 static inherit，在 MDN 上可以看到有个新增的实验性的 position sticky sticky 定义就是将某个元素固定在某个位置，乍一看和 fixed 定位有点像，但它们有以下不同 fixed是相对于 viewport 来定位，而sticky是相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。 fixed会使元素脱离文档流，而sticky则不会，后续元素的位置仍按照未定位时的位置来确定。 简单的demo sticky 踩坑使用时的注意点 具有sticky属性的元素，其父级高度必须大于sticky元素的高度 sticky元素的底部，不能和父级底部重叠 sticky元素的父级不能含有 overflow:hidden 和 overflow:auto 属性 必须具有top或bottom属性，如果同时定义了top和bottom，top胜 sticky元素仅在他父级容器内有效，超出容器范围则不再生效了 浏览器兼容性 Chrome已经不再支持sticky属性 【2017更新】Chrome 56 开始支持了 Safari 从 6.1开始支持，但表现也不太完美 Firefox 从版本 32开始支持了 IE一直不支持，放弃吧… js 实现以前没有position: sticky的时候，都必须用 js 监听滚动并且动态改变元素定位方式，才能实现相应的效果 具体实现思路是 保存元素初始的位置，判断当前距离 viewport 的位置 如果&lt;=定义的 top 值，则将元素改为fixed定位 在元素上挂个 data-sticky 作为标记 并且在文档流中插入一个与之同样大小的占位元素 否则恢复元素初始的位置，删除 data-sticky 标记，并删除占位元素 现有 jquery 插件 jquery.pin fixed-sticky 判断浏览器是否支持sticky1234567891011121314function supportSticky() &#123; var _supportCSS = function(property, value)&#123; var el = document.createElement('i'); el.style[property] = value; var r = el.style[property]; el = null; return r === value; &#125;; var supportVals = ['-webkit-sticky', '-ms-sticky', 'sticky'].filter(function(item)&#123; return _supportCSS('position', item); &#125;); return supportVals.length ? supportVals[0] : null;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之JS视窗]]></title>
    <url>%2Fblog%2F2016%2F10%2Fcode-patterns-of-js-viewport.html</url>
    <content type="text"><![CDATA[继续【常用模式片段】系列的JS部分，首先整理了下关于滚动视窗的一些判定方法，经常用于做各种滚动相关的交互效果，比如滚动刷新，图片延迟加载（当图片位于视窗范围内才加载） 一、页面scrollTop在jquery中直接$(window).scrollTop()就完事了，但也要知道在原生js中的兼容性写法为 1window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop 可参考如下 关于pageYOffset scrollY scrollTop的小结 stackoverflow中的问答 二、判断元素距离视窗的距离元素距视窗顶部 deltaTop = el.offset().top - 页面scrollTop 判断是否在当前视窗范围内的临界值 (式1) deltaTop - TOP_MARGIN &gt; 0 元素距视窗底部 deltaBottom = window.innerHeight - deltaTop - el.outerHeight() 判断是否在当前视窗范围内的临界值 (式2) deltaBottom - BOTTOM_MARGIN &gt; 0 替换deltaBottom的计算式后，上式等价于 (式3) deltaTop &lt; window.innerHeight - el.outerHeight() - BOTTOM_MARGIN 注：以上【TOP_MARGIN】【BOTTOM_MARGIN】表示距离视窗范围的固定量，类似于fixed定位时的 top bottom 所代表的距离。 综上，如果要判定一个元素是否在视窗范围内，只要同时满足 (式1)(式2/式3) 即可。 三、判断到达页面底部在各种手机app上经常能看到到达页面底部后，就自动触发“下拉刷新”的交互。这里与上面类似但又有所不同 先定义两个值，表示整个文档的可见区域高度和可滚动距离（针对移动端的写法） viewHeight = document.documentElement.clientHeight scrollHeight = document.documentElement.scrollHeight 判定是否到达页面底部的临界值 scrollHeight - window.pageYOffset - viewHeight &lt; BOTTOM_MARGIN 这里【BOTTOM_MARGIN】表示距离页面底部的可接受距离。 附offsetHeight &amp; clientHeight &amp; scrollHeight参考文章：JavaScript中的各种宽高以及位置总结 几种窗口的宽度document.documentElement.offsetWidth：视窗宽度（不滚动的情况下，一屏可以看到多宽的文档），且不包含滚动条的宽度 document.body.offsetWidth：页面文档真正的宽度，可以通过滚动看到的文档的全部宽度 window.innerWidth：同“视窗宽度”，但貌似在 IE8 下与 document.documentElement.offsetWidth 不相等 window.outerWidth：整个浏览器窗口的宽度，如果不开调试工具窗口，一般情况下其等于 视窗宽度 + 滚动条宽度 window.screen.width：整个屏幕的宽度，与你怎么拖拽窗口大小没有关系。。。 window.screen.availWidth：啥情况下会小于 window.screen.width ？(TODO)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 git submodule 建立子项目依赖]]></title>
    <url>%2Fblog%2F2016%2F10%2Fusage-of-git-submodule.html</url>
    <content type="text"><![CDATA[在使用 git 做项目时，也许会碰到一些组件需要独立出去，同时供多个项目使用，而不是在多个项目里拷贝两份组件的代码。如果公共的组件已经成熟了，可以发布到CDN上供多个项目去引用。但如果都在开发阶段，在多个项目里都要引用某个公共组件，这是就需要用到 git submodule 的功能了。 建立 Submodule演示仓库 主项目：git@github.com:xxx/your-app.git 子项目：git@github.com:xxx/your-lib.git 在主项目 your-app 中使用git submodule add 子项目地址 在主项目中的路径 git submodule add git@github.com:xxx/your-lib.git libs/your-lib 然后git status会发现如下 new file: .gitmodulesnew file: your-lib 查看.gitmodules内容 123[submodule &quot;libs/your-lib&quot;] path = libs/your-lib url = git@github.com:xxx/your-lib.git 需要commit，但这里子模块目录并不是以文件形式提交，注意下面出现的160000模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。 create mode 100644 .gitmodulescreate mode 160000 libs/your-lib 更新 Submodule我们先在 your-lib 里做了新的commit，但在主项目 your-app 中直接git pull并不能获取到子模块的最新更新。 【注意】需要进到主项目中子模块的具体目录里再 git pull 然后在主项目根目录下发现。。。 modified: your-lib (new commits) 在主项目中需要再次commit，以告诉HEAD当前的子模块指向哪个版本。在 git 的提交记录里能看到变化内容只是个commit标识 Git 在主项目中记录了一个子模块的提交日志的指针，用于保存子模块的提交日志所处的位置，以保证无论子模块是否有新的提交，在任何一个地方克隆下顶级项目时，各个子模块的记录是一致的。避免因为所引用的子模块不一致导致的潜在问题。如果我们更新了子模块，我们需要把这个最近的记录提交到版本库中，以方便和其他人协同。 克隆主项目方法1： 12git clone git@github.com:xxx/your-app.gitgit submodule update --init --recursive 方法2： 1git clone --recursive git@github.com:xxx/your-app.git 今后对主项目 pull 时 12git pullgit submodule update --recursive Submodule 开发协作在主项目中添加了 submodule 作为子项目，其实进入到子项目中，它跟平常git clone下来的仓库没啥区别，同样可以在里面 commit, pull, push 如果需要将子项目回退到之前的版本，可以使用git reset –hard commit_id，即在主项目中不使用最新版本的子项目（此时同样需在主项目中 add commit 1次，以更新 Subproject 的指针位置）。更多 git 工作流的协作&gt;&gt; 删除 Submodule在主项目中git rm libs/your-lib/删除子模块后，.gitmodules文件的内容也会相应移除 更多参考 Git 工具 - 子模块]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之CSS弹性布局]]></title>
    <url>%2Fblog%2F2016%2F10%2Fcode-patterns-of-css-flexiable-layout.html</url>
    <content type="text"><![CDATA[续前面的CSS布局篇，这篇针对移动端布局的特点整理了几种弹性布局的案例。 百分比布局相较于写死像素绝对值的布局，百分比布局是最简单的实现弹性布局的方式，只需将原来宽度的绝对大小都替换成百分比即可。 12345678910111213141516171819.layout-container &#123; background: #eee; padding: 5px; font-size: 0; .box &#123; box-sizing: border-box; display: inline-block; height: 80px; padding: 5px; width: percentage(1/3); .inner &#123; background: #ccc; height: 100%; width: 100%; &#125; &#125;&#125; 注：部分手机浏览器无法计算到很精确的percentage，在四舍五入时会出现问题，比如总宽度超过了100%就会将最后一个元素挤到下一行去。因此将上述percentage(1/3)改为33.3%即可。 flex 布局关于flex布局的教程请看：一个完整的Flexbox指南 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.flexbox()&#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-lines: multiple; -moz-box-lines: multiple; -ms-flex-wrap: wrap; -webkit-flex-wrap: wrap; flex-wrap: wrap; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -moz-box-orient: horizontal; -moz-box-direction: normal; -ms-flex-direction: row; -webkit-flex-direction: row; flex-direction: row; &amp;.vertical&#123; -webkit-box-orient: vertical; -moz-box-orient: vertical; -ms-flex-direction: column; -webkit-flex-direction: column; flex-direction: column; &#125;&#125;.flex(@grow, @shrink, @basis)&#123; -webkit-box-flex: @grow; -moz-box-flex: @grow; -ms-flex: @grow @shrink @basis; -webkit-flex-grow: @grow; -webkit-flex-shrink: @shrink; -webkit-flex-basis: @basis; -webkit-flex: @grow @shrink @basis; flex-grow: @grow; flex-shrink: @shrink; flex-basis: @basis; flex: @grow @shrink @basis;&#125;.order($val) &#123; -webkit-box-ordinal-group: $val; -moz-box-ordinal-group: $val; -ms-flex-order: $val; -webkit-order: $val; order: $val;&#125;.layout-container&#123; background: #eee; padding: 5px; .flexbox(); &amp;, *, *:after, *:before &#123; box-sizing: border-box; &#125; .box&#123; background: #ccc; height: 80px; margin: 5px; .flex(1, 1, 0); /*flex-basis在老webkit下不生效*/ width: 0; /*android有些浏览器下面如果重置宽度，不会通过flex来计算宽度*/ max-width: 100%; display: block; /*padding: 0 !important;*/ /*position: relative;*/ &#125;&#125; 弹性图片弹性图片的需求是当屏幕尺寸变化时，图片保持等比缩放，且不能出现文档高度的抖动。 12345&lt;div class="item"&gt; &lt;div class="img-wrapper"&gt; &lt;img src="http://img.taobaocdn.com/tfscom/TB1Fhi3HVXXXXXlXpXXSutbFXXX_q50.jpg"&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920.item&#123; float: left; width: 50%;&#125;.img-wrapper&#123; margin: 0 10px 10px 0; position: relative;&#125;.img-wrapper::before&#123; content: ''; display: block; padding-top: 30%;&#125;.img-wrapper img&#123; height: 100%; left: 0; position: absolute; top: 0; width: 100%;&#125; 原理 padding 的百分比值都是参照父元素的 width 计算出的 absolute 元素的 width、height 百分比值也是参照最近 relative 父元素的 通过在 img 父元素内做个伪类，用padding-top将父元素撑起来，padding-top的百分比等于图片的高宽比。这样当图片未载入时，也预留出图片的占位，不会产生文档高度的跳动。 demo效果 两列同步拉伸弹性图片的需求再进一步，需要实现等比缩放的两列布局，可以是图片，也可以是图文混排。（可参考双11商品活动页的移动端展现） 12345678&lt;div class="box banner"&gt; &lt;div class="box-inner"&gt; &lt;img class="banner-img" src="http://gtms04.alicdn.com/tps/i4/TB1BHIGHFXXXXbHXFXXTYq7_VXX-240-347.jpg"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="box item"&gt; &lt;div class="box-inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041@cellPadding: 10px;@cellRatio: percentage(275/160); //图片高宽比.box&#123; background: #fff; border: 1px solid #000; border-width: 0 1px 1px 0; border-radius: 0; box-sizing: border-box; float: left; position: relative; padding: @cellPadding; width: 50%;&#125;.box::before&#123; content: ' '; display: block; padding-top: @cellRatio;&#125;.box:nth-of-type(2n)&#123; border-right-color: transparent;&#125;.box:last-of-type,.box:nth-last-of-type(2)&#123; border-bottom-color: transparent;&#125;.box-inner&#123; position: absolute; top: 10px; left: 10px; bottom: 10px; right: 10px;&#125;.banner-img&#123; height: 100%; width: 100%;&#125;.item .box-inner&#123; background: #f35656;&#125; 移动端布局特点： 绝对定位时不要写死px，用百分比，或者同时设置top left bottom right 要考虑到屏幕resize和旋转的情况 demo效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之CSS兼容性]]></title>
    <url>%2Fblog%2F2016%2F10%2Fcode-patterns-of-css-hack.html</url>
    <content type="text"><![CDATA[续前面的CSS布局篇，这里整理一些需求下的浏览器兼容性写法。 色彩滤镜opacity1234567891011121314/* IE 8 */-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=50)"; /* IE 5-7 */filter: alpha(opacity=50); /* Netscape */-moz-opacity: 0.5; /* Safari 1.x */-khtml-opacity: 0.5; /* Good browsers */opacity: 0.5; 灰白滤镜1234567891011.grayscale()&#123; filter: gray; /* For IE 6 - 9 */ filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter: url("data:image/svg+xml;utf8,&amp;lt;svg xmlns=\'http://www.w3.org/2000/svg\'&amp;gt;&amp;lt;filter id=\'grayscale\'&amp;gt;&amp;lt;feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;/svg&amp;gt;#grayscale"); /* Firefox 10+, Firefox on Android */ filter: grayscale(100%); /* For Standard */ -webkit-filter: grayscale(100%); /* Chrome 19+, Safari 6+, Safari 6+ iOS */ -webkit-filter: grayscale(1); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 居中问题table-cell 垂直居中123456789101112131415161718192021.table &#123; height: 300px;/*高度值不能少*/ width: 300px;/*宽度值不能少*/ display: table; position: relative; float:left;&#125;.tableCell &#123; display: table-cell; vertical-align: middle; text-align: center; padding: 10px; *position: absolute; *top: 50%; *left: 50%;&#125;.content &#123; *position:relative; *top: -50%; *left: -50%;&#125; 行排列inline-block IE6/7 hack12*display: inline;*zoom: 1; 未完待续请持续关注~]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之元素偏移量]]></title>
    <url>%2Fblog%2F2016%2F10%2Fcode-patterns-of-dom-position.html</url>
    <content type="text"><![CDATA[获取元素相对于页面左上角的位置，是比较常用的需求。比如将一个浮层元素定位到当前操作的元素附近，就需要计算当前操作的元素相对于页面左上角的位置，然后将浮层元素也绝对定位到该位置附近。 offsetParent 法123456789101112function getOffset(el) &#123; let top = 0; let left = 0; let target = el; while (target.offsetParent) &#123; top += target.offsetTop; left += target.offsetLeft; target = target.offsetParent; &#125; return &#123; top: top, left: left &#125;;&#125; 思路就是取元素offsetTop和offsetLeft，然后使用offsetParent逐层向上直到根元素，这样就取出了相对于页面左上角的偏移。 clientRect 法getBoundingClientRect 取出的是元素相对于视窗的距离，那么再加上页面滚动条的偏移，就可以求出元素相对于页面左上角的距离。 1234567891011121314151617181920212223function getOffset(el) &#123; if (el === document.documentElement) &#123; return &#123; top: 0, left: 0 &#125;; &#125; const box = el.getBoundingClientRect(); let top = 0; let left = 0; if (window.pageYOffset !== undefined) &#123; top = Math.floor(box.top + window.pageYOffset); left = Math.floor(box.left + window.pageXOffset); &#125; else &#123; // 有个 bad case 即当HTML或者BODY元素有 border width 时，会有偏差 top = Math.floor(box.top) + Math.max(doc.documentElement.scrollTop, doc.body.scrollTop); left = Math.floor(box.left) + Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft); top -= doc.documentElement.clientTop; left -= doc.documentElement.clientLeft; &#125; return &#123; top: top, left: left &#125;;&#125; 可见getBoundingClientRect方法比取offsetParent效率要高的多，并且搭配window.pageYOffset代码更简单。 jquery 法使用 jquery 里的offset 和 position，可分别获取相对于页面左上角和相对于父元素的偏移。 源码参见https://github.com/jquery/jquery/blob/1.7.2/src/offset.js#L7，而在1.9版本中简化了其实现https://github.com/jquery/jquery/blob/1.9.1/src/offset.js#L1 对比下 baidu/tangram 库中的相应实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051baidu.dom.extend(&#123; offset: function() &#123; function setOffset(ele, options, index) &#123; var tang = tang = baidu.dom(ele), position = tang.getCurrentStyle('position'); position === 'static' &amp;&amp; (ele.style.position = 'relative'); var currOffset = tang.offset(), currLeft = tang.getCurrentStyle('left'), currTop = tang.getCurrentStyle('top'), calculatePosition = (~'absolute|fixed'.indexOf(position)) &amp;&amp; ~ ('' + currLeft + currTop).indexOf('auto'), curPosition = calculatePosition &amp;&amp; tang.position(); currLeft = curPosition &amp;&amp; curPosition.left || parseFloat(currLeft) || 0; currTop = curPosition &amp;&amp; curPosition.top || parseFloat(currTop) || 0; baidu.type('options') === 'function' &amp;&amp; (options = options.call(ele, index, currOffset)); options.left != undefined &amp;&amp; (ele.style.left = options.left - currOffset.left + currLeft + 'px'); options.top != undefined &amp;&amp; (ele.style.top = options.top - currOffset.top + currTop + 'px'); &#125; return function(options) &#123; if (options) &#123; baidu.check('^(?:object|function)$', 'baidu.dom.offset'); for (var i = 0, item; item = this[i]; i++) &#123; setOffset(item, options, i); &#125; return this; &#125; var ele = this[0], doc = this.getDocument(), box = &#123; left: 0, top: 0 &#125;, win, docElement; if (!doc) &#123; return; &#125; docElement = doc.documentElement; if (!baidu._util_.contains(docElement, ele)) &#123; return box; &#125; (typeof ele.getBoundingClientRect) !== 'undefined' &amp;&amp; (box = ele.getBoundingClientRect()); win = this.getWindow(); return &#123; left: box.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0), top: box.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0) &#125;; &#125; &#125; ()&#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HSV颜色模型]]></title>
    <url>%2Fblog%2F2016%2F09%2Fcolor-model-hsv.html</url>
    <content type="text"><![CDATA[颜色模型来源颜色模型最早来自美术和打印领域。“三原色”就是一种颜色模型，它来自美术上的概念，指“红/黄/蓝”，因为这三种颜色的配合可以调出除了黑白以外的几乎所有颜色，故称为三原色。 而在计算机/多媒体方面所说的“R/G/B”颜色模型其实是“三基色”，或者教科书上所说的“光的三原色”。红、绿、蓝三种光通过不同的组合，可以获得各种不同颜色光。而红、绿、蓝这三种光是无法用其他色光混合而成的，所以这三种色光叫做光的“三基色”。 物理解释物理课上学过光的色散，肯定见过下面这个图。 可知白光是各种颜色的光叠加而成的，显然光的三原色是一种“加法”颜色模型。 光的颜色是直接进入人的眼睛，而人看到各种物体的颜色，其实是物体反射出的光的颜色。即红色的物体只会反射红色的光，其他颜色的光都被它吸收了；而黑色的物体吸收了所有颜色的光，人看不到它的反射光，所以看到的是黑色。 因此被物体吸收的颜色，其实是所有颜色 - 物体反射的颜色，当颜料叠加时，也遵从了所有颜色 - Σ(反射的颜色)，可以理解为一种“减法”颜色模型。 常用颜色模型RGB即光的三原色，如下图。 RGB 颜色模型可以理解为一个立方体的模型，R/G/B 分别代表三维坐标系中的 x/y/z 轴，而原点表示什么颜色都没有(即黑色) 在计算机多媒体领域中，通常将 R/G/B 三个值标准化到 0~255 的整数区间上，因为这样一个颜色分量共有256个取值，正好可以用一个字节表示。这样 R/G/B 共可组成 2^24 种颜色，当然远远超过了人眼能够分辨的颜色数目。 CMY第一节中提到的美术/印刷领域用的三原色，其实就是 CMY 颜色模型。 在印刷领域也会用 CMYK 模型，表示青(Cyan)品红(Magenta)黄(Yellow)黑(BlacK)四种颜料，就是在 CMY 的基础上也将黑色作为基础颜色，因为打印时由品红、黄、青合成的黑色不够纯粹。 从上面可以看到 CMY 和 RGB 的颜色合成图有点类似，R和B可以成品红。这里要说明下，RGB 颜色是越叠加越亮(越接近白色)，而 CMY 颜色是越叠加越暗(越接近黑色)，这就是“加法混色模型”和“减法混色模型”的区别。 HSVHSV 使用六角锥体模型来表示 色调（Hue）、饱和度（Saturation）、明度（Value）。 用角度来表示色调H，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，品红为300°。 饱和度S表示颜色接近光谱色的程度，通常取值范围为0%～100%，值越大，颜色越饱和。而S=0时，只有灰度。 明度V表示颜色明亮的程度，通常取值范围为 0%（黑）到 100%（白） HSV 模型的三维表示从 RGB 立方体演化而来。设想从 RGB 沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。 HSLHSL 和 HSV 很相似，它们都是面向用户的颜色模型，定义了：色调(色相)、饱和度、明度(亮度)。相信大家在调节电视或显示器屏幕颜色时都会看到这几个名词吧！ 关于更多 HSL 和 HSV 的区别请参见 维基词条：HSL和HSV色彩空间 颜色模型转化RGB to HSV由 RGB 转换为 HSV 时，设max为 r/g/b 中的最大值，min为 r/g/b 中的最小值。转换公式如下 js 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465rgb2hsv: function () &#123; // 读取 rgb var rgb = this.parseRgbArguments.apply(null, arguments); var r = rgb.r; var g = rgb.g; var b = rgb.b; // rgb 分量的最大最小值 var max; var min; if (r &gt; g) &#123; max = Math.max(r, b); min = Math.min(g, b); &#125; else &#123; max = Math.max(g, b); min = Math.min(r, b); &#125; var delta = max - min; // hsv 分量 var v = max; var s = (v === 0.0) ? 0.0 : delta / v; var h; if (s === 0.0) &#123; h = 0.0; &#125; else &#123; if (r === max) &#123; h = 60.0 * (g - b) / delta; &#125; else if (g === max) &#123; h = 120 + 60.0 * (b - r) / delta; &#125; else &#123; h = 240 + 60.0 * (r - g) / delta; &#125; // 修正色调 ( 0~360 度) if (h &lt; 0.0) &#123; h += 360.0; &#125; if (h &gt; 360.0) &#123; h -= 360.0; &#125; &#125; h = Math.round(h); s = Math.round(s * 255.0); v = Math.round(v); // avoid the ambiguity of returning different values for the same color if (h === 360) &#123; h = 0; &#125; // 注: s,v 分量值域为 0~255 return &#123; h: h, s: s, v: v &#125;;&#125; 注意：因为v = max(r,g,g)，这里我将v和s也转到了0~255的区间上，而h的值域为0~359。 HSV to RGB由HSV转换为RGB时，如果饱和度s = 0，则颜色是非彩色的，色调(Hue)是无意义的，此时r=g=b=v(亮度)。 如果饱和度s ≠ 0，有如下的计算方式： js 实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485hsv2rgb: function () &#123; // 读取 hsv var hsv = this.parseHsvArguments.apply(null, arguments); var h = hsv.h; var s = hsv.s; var v = hsv.v; // rgb 分量 var r; var g; var b; // 特殊处理 if (s === 0) &#123; r = v; g = v; b = v; &#125; else &#123; // 原始亮度 var value = v; // s,v 分量归一化 var s = s / 255.0; var v = v / 255.0; // 修正后的 h 分量 var hFix = (h === 360) ? 0 : h / 60; var hIndex = Math.floor(hFix); var hLeft = hFix - hIndex; // v 分量转化的中间变量 var vs = v * s; var vLeft = value - value * s; switch (hIndex) &#123; case 0: var vTemp = v - vs * (1 - hLeft); r = Math.round(value); g = Math.round(vTemp * 255.0); b = Math.round(vLeft); break; case 1: var vTemp = v - vs * hLeft; r = Math.round(vTemp * 255.0); g = Math.round(value); b = Math.round(vLeft); break; case 2: var vTemp = v - vs * (1 - hLeft); r = Math.round(vLeft); g = Math.round(value); b = Math.round(vTemp * 255.0); break; case 3: var vTemp = v - vs * hLeft; r = Math.round(vLeft); g = Math.round(vTemp * 255.0); b = Math.round(value); break; case 4: var vTemp = v - vs * (1 - hLeft); r = Math.round(vTemp * 255.0); g = Math.round(vLeft); b = Math.round(value); break; case 5: var vTemp = v - vs * hLeft; r = Math.round(value); g = Math.round(vLeft); b = Math.round(vTemp * 255.0); break; &#125; &#125; return &#123; r: r, g: g, b: b &#125;;&#125; 详见 完整代码 和 测试用例 参考 在线转化工具：http://www.kmhpromo.com/rgbtopms/cmyktopantone.html 更多颜色模型：http://blog.ibireme.com/2013/08/12/color-model/]]></content>
      <categories>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模式片段之CSS布局篇]]></title>
    <url>%2Fblog%2F2016%2F08%2Fcode-patterns-of-css-layout.html</url>
    <content type="text"><![CDATA[去年在杭州实习的三个多月收获颇多，不管是代码层面还是思考层面，发现了自己很多一知半解的缺点，正应了墨菲法则，会出错的事总会出错。现在重新整理那时的学习笔记，以备今后之需。 注：此为初稿笔记，未二次提炼。 position 拉伸撑满整个未知宽高容器12position: absolute;top: 0; bottom: 0; left: 0; right: 0; 撑满整个屏幕12position: fixed;top: 0; bottom: 0; left: 0; right: 0; 注：是元素撑满，如果只是背景撑满，只需对根节点设background 居中水平居中已知元素宽度 123456789#parent &#123; position: relative;&#125;#content &#123; position: absolute; left: 50%; margin-left: -200px; // 负 (width/2) width: 400px;&#125; 未知元素宽度 1234567891011121314#parentWrapper &#123; position: relative; overflow: hidden;&#125;#parent &#123; float: left; position: relative; left: 50%;&#125;#content &#123; float: left; position: relative; right: 50%;&#125; demo效果 浮动完备的clearfix1234567891011121314.clearfix() &#123; *zoom: 1; &amp;:before, &amp;:after &#123; display: table; content: ""; // Fixes Opera/contenteditable bug: // http://nicolasgallagher.com/micro-clearfix-hack/#comment-36952 line-height: 0; &#125; &amp;:after &#123; clear: both; &#125;&#125; 左侧菜单 右侧主体左侧定宽，右侧元素自适应铺满 左侧元素定宽，并浮动 右侧元素设oerflow: hidden 父容器可定宽，也可100%铺满 BFC (Block Formatting Context)页面上任何一个元素都可以看成 box，box 种类有：Block-level，Inline-level 和匿名box BFC (Block Formatting Context) 是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的 Block-level box 如何布局，并且与这个区域外部毫不相干。 BFC布局规则 内部的 Box 会在垂直方向，一个接一个地放置 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（margin callapse） 即使是子元素和父元素的关系，如果它们在同一个 BFC Box 下，也会发生 margin callapse 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反） 即使存在浮动元素也是如此，即在一个 BFC Box 内部，浮动流和文档流会发生重叠 BFC 的区域不会与浮动元素重叠（利用它重新构造个 BFC 区域，就可以清除浮动） 计算 BFC 区域的高度时，浮动元素也参与计算 总结 BFC，就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 如何触发BFC float 属性不为 none （即脱离文档流，到浮动流） position 为 absolute 或 fixed （即脱离文档流，到定位流） overflow 不为 visible （IE6/7 无效时，可以设 zoom: 1 触发 hasLayout） display 为 inline-block, table-cell, table-caption, flex, inline-flex 参考资料 W3C标准 Visual formatting model 前端精选文摘：BFC 神奇背后的原理 行排列inline-block 间隙 inline-block之间是会有一个默认间隙的，跟父元素font-size有关，设为0就可以了 老safari下还需设letter-spacing、word-spacing一个负值(0.25em左右)，子元素设为normal block之间没有间隙 inline-block 行高 父元素block，子元素inline-block时，子元素会有一定行高，导致父元素的高度与子元素实际内容的高度不一致 父元素设font-size: 0，同时IE下再设line-height: 0 子元素横向排列边距 子元素都设 margin-right，而最边上的元素需要修正，用 nth-child 会有兼容性问题 父元素设个 margin-right 负值，可将一行的子元素全包进去 文字排列文字竖排 文本元素设width: 1.5em 再对父容器设文本居中 最小字体实现10px的文字大小，而部分浏览器比如chrome只支持最小12px的文字。 12transform-origin: 0 50%;transform: scale(10/12); 注：元素占据的位置不会缩小，仅仅是看上去缩小了 文字overflow 显示’…’单行文字 12345.ui-text-overflow()&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文字（仅webkit有效） 12345678.ui-text-overflow-lines(@line: 2, @lineHeight: 1.5)&#123; display: -webkit-box; -webkit-line-clamp: @line; -webkit-box-orient: vertical; overflow: hidden; @height: @lineHeight * @line; max-height: ~'@&#123;height&#125;em';&#125; 注：该元素本身不要设上下padding，要垂直居中请在父元素上控制 背景背景图固定不跟随滚动1background-attachment: fixed 其他手绘icon这是一个类似√符号的icon，css绘制出来，支持等比缩放。 12345678910111213141516171819202122232425262728293031.icon-get&#123; background-color: #59b726; border-radius: 50%; color: #fff; display: block; height: 18px; width: 18px; position: absolute; top: -10px; left: -10px; transform: rotate(-45deg); &amp;::before, &amp;::after&#123; content: ' '; display: block; position: absolute; &#125; &amp;::before&#123; border-top: 1px solid #fff; width: percentage(11/18); top: percentage(11/18); left: percentage(5/18); &#125; &amp;::after&#123; border-left: 1px solid #fff; height: percentage(7/18); top: percentage(4/18);; //before.top - after.height left: percentage(5/18); &#125;&#125; 自定义滚动条样式类似mac上滚动条的感觉 1234567891011121314151617.mac-scroll &#123; &amp;::-webkit-scrollbar &#123; width: 8px; &#125; /*定义滑条*/ &amp;::-webkit-scrollbar-thumb &#123; background-color: $gray-lightest; background-clip: content-box; border-top: 5px solid rgba(255,255,255,0); border-bottom: 5px solid rgba(255,255,255,0); border-right: 4px solid rgba(255,255,255,0); &#125; /*定义滚动条轨道*/ &amp;::-webkit-scrollbar-track &#123; background-color: #fbfbfb; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>常用片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坑爹的JPA中的'ddl']]></title>
    <url>%2Fblog%2F2016%2F07%2Fjpa-ddl-trapped.html</url>
    <content type="text"><![CDATA[以前做学校里的项目时强推了一把 Play Framework，鼓吹它有多么多么轻量，它用JPA做ORM是多么方便，可参考以前的文章 JPA泛型DAO 和 mooctest项目总结。直到今天踩到了个坑。。。记录下JPA中坑爹的ddl参数 JPAJPA全称为：Java Persistence API。JPA通过Java中的 Annotation 或 XML 来描述“对象－关系表”的映射关系，并将运行期的实体对象持久化到数据库中。这是查自百度的解释，可简单理解为就是Java小组为 ORM(Object Relational Mapping) 定了一套接口规范，我们常见的 Hibernate 和 Spring 中的ORM都可理解为是 JPA 的一种具体实现。（各框架对接口规范的实现程度和匹配度可能并不完全。。。） Play中的JPA在Play Framework 1.2.7中，其JPA底层采用的是 Hibernate 3.6 的实现。在Play的application.conf文件中可以看到有如下一段配置说明： 123# Specify the ddl generation pattern to use. Set to none to disable it # (default to update in DEV mode, and none in PROD mode):# jpa.default.ddl=update 在调试模式下，jpa.default.ddl的默认值就是update。。。那到底什么是ddl呢，坑又是啥？ ddlDDL的全称为：Data Definition Language，大概是学数据库课或集成软件开发的时候见过这类的词汇，大概就是数据库中定义数据结构的方式。我查到一个eclipse里的JPA工具里有这么一段： Use eclipselink.ddl-generation to specify how EclipseLink generates DDL (Data Definition Language) for the database schema (tables and constraints) on deployment. EclipseLink也是一套支持JPA的ORM方案，然而我并没有使用过。。。看名字应该是eclipse的官方组织搞的，但网上说由于文档较少，并不推荐。。 回到上面那段定义，我理解的JPA中ddl的过程如下 读取实体对象类中 Java Annotation 对属性的定义 生成 DDL 的描述文件 根据具体数据库的dialect，生成 schema 的SQL语句 在数据库中生成对应的schema 所以坑是上述 ddl 的好处在于，当项目刚构建时，或在本地开发新模块时，我们可以先定义实体对象的类，通过 Java Annotation 配置字段和实体对象关系，ddl 可以帮我们自动生成相应的数据库表。这是非常便捷的，因为刚开发时实体对象的属性可能会经常调整，ddl 可以在每次运行项目时自动将这些变化同步到数据库中。 所以回过头再看Play中的那段配置 123# Specify the ddl generation pattern to use. Set to none to disable it # (default to update in DEV mode, and none in PROD mode):# jpa.default.ddl=update 所以在开发状态下，ddl可以默认开启，以省去我们手动修改数据库字段的活儿。。而当生产状态下，最好不要开启该 ddl generation 功能！ 下面是重点，我的坑在于，我在本地开发状态下，图省事直接让项目连接了服务器上的数据库 结果就是我还处于 DEV 状态，然而默认jpa.default.ddl=update，当我增加实体对象类中的属性时，就会帮我重新 build 一遍 schema，服务器上我亲手建的数据表里的字段类型和外键索引都乱了。。。最后我把jpa.default.ddl=none加上了 教训 本地开发时禁止连接服务器数据库 不要使用 ddl 生成的数据库表，字段类型和外键名很丑，反正最后还得手动调 希望是先手动建表，然后可以使用类似 hibernate 中逆向工程的那种工具将表结构反射到对象class]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始配置一台服务器]]></title>
    <url>%2Fblog%2F2016%2F04%2Flinux-server-startup.html</url>
    <content type="text"><![CDATA[最近项目要迁移，以前是和其他项目共用一台服务器的，现在要迁移到独立服务器。本人linux用的比较晚，以前是win狗，苦于各种莫名错误，改用mac开发也才1年时间。第一次从零开始配置服务器，故记录以备忘。 服务器起步Hello World购买服务器，选好配置 40G系统盘，500G数据盘，正常项目够用了 内存和带宽看具体应用场景，4G内存带64位系统比较合适，PS.带宽很贵 操作系统我不太懂，听说CentOS比较稳定，目前阿里云上可选的版本有5.8、6.5、7.0。根据版本号a.b.c的规则，我一般不太愿意尝试b位版本号较低的版本，7.0肯定新特性多，但是问题也会存在。像5.8肯定维护的很稳定了，除非官方放弃维护。最后我权衡选择了6.5 =_= 使用root账号登录 OK. Welcome to Elastic Compute Service! 创建用户一直使用root登录是不合理不安全的，所以开始操作前先添加用户： 1useradd fuxiaode 新创建的用户home目录默认在/home/fuxiaode，而root用户的home目录在/root。然后为用户设置登录密码： 1passwd fuxiaode 可以在/etc/passwd文件中查看到刚才创建的用户： 123nscd:x:28:28:NSCD Daemon:/:/sbin/nologinfuxiaode:500:500::/home/fuxiaode:/bin/bashguest:x:501:501::/home/guest:/bin/bash 这里我创建了两个用户fuxiaode和guest，注意其末尾非nologin 下面为fuxiaode用户添加root权限： 打开/etc/sudoers 找到Allow root to run any commands anywhere这一行 添加fuxiaode ALL=(ALL) ALL 测试用户权限切换到guest用户（上面未赋予其root权限） 12su guestsudo vim /etc/passwd 出现一段话 12345678We trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility.[sudo] password for guest: 输完密码，然后并没鸟用，因为guest不在/etc/sudoers文件中！ 切换fuxiaode用户，重新试下sudo，妥妥的！ 基础环境包管理系统中一般会自带一些开发包，但是经常需要升级到我们需要的版本。CentOS中使用yum来管理rpm包： 1sudo yum list yum的具体使用命令详见 http://blog.chinaunix.net/uid-346158-id-2131252.html pythonCentOS 6.5自带的是Python 2.6.6，而编译llvm需要Python 2.7以上。而yum中最新的也是Python 2.6.6，只能下载Python 2.7.10的源代码自己编译安装。 首先要安装编译python需要的包，切换到root用户省的权限麻烦 1234567sudo suyum groupinstall "Development tools"yum install zlib-develyum install bzip2-develyum install openssl-develyum install ncurses-develyum install sqlite-devel 手动下载python 12wget http://python.org/ftp/python/2.7.10/Python-2.7.10.tar.xztar -xf Python-2.7.10.tar.xz 编译和安装 123./configure --prefix=/usr/local# 需要sudomake &amp;&amp; make altinstall 创建软链（-b表示覆盖之前的） 1ln -sb /usr/local/bin/python2.7 /usr/bin/python 查看版本 12which pythonpython --version 至此成功！以上过程参考 Installing python 2.7 on centos 6.3 pipUbuntu下可以用apt-get很方便的安装 12apt-get install pythonapt-get install python-pip 但在yum中是不行的，试过安装easy_install后再装pip，但是我都莫名失败了。。。FUCK 现在使用源码安装 123wget https://pypi.python.org/packages/d3/16/21cf5dc6974280197e42d57bf7d372380562ec69aef9bb796b5e2dbbed6e/setuptools-20.10.1.tar.gzwget --no-check-certificate https://pypi.python.org/packages/41/27/9a8d24e1b55bd8c85e4d022da2922cb206f183e2d18fee4e320c9547e751/pip-8.1.1.tar.gz 然后在解压后的目录里依次使用python命令安装 1sudo python setup.py install 但是尼玛，这时试下pip会提示sudo：pip：找不到命令，这时因为前面安装python时我们设置装到了/usr/local下，安装的命令实际在/usr/local/bin下，因此这里需要同python一样建个软链。 1ln -s /usr/local/bin/pip /usr/bin/pip 现在果断可以使用pip了，查看已经安装过哪些python包 1pip list 可能会提示pip需要升级 12# 需要sudopip install --upgrade pip nodejsnode不用yum或源码安装，node使用自己的npm进行包管理，推荐使用nvm安装。 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash 这条命令安装完后，会在home下生成~/.nvm目录，需要在~/.bash_profile中添加一行： 1source ~/.nvm/nvm.sh 然后使之生效 1source ~/.bash_profile 现在就可以使用nvm命令安装node版本了 12nvm install 0.12nvm alias default 0.12 同样也可以使用npm命令了 1npm install -g koa 通过npm全局安装的包会存在~/.nvm/versions/node/v0.12.13/lib/node_modules目录下。 数据库mongodb安装 12wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.11.tgztar -xzf mongodb-linux-x86_64-2.6.11.tgz /var/lib/mongodb 创建数据库文件夹与日志文件（因为今后数据和日志会增长很快，最好放在另一块硬盘上） 12mkdir /mnt/lib/mongodb/datatouch /mnt/lib/mongodb/logs 首次启动（无身份认证模式） 1/var/lib/mongodb$ mongod --dbpath=/var/lib/mongodb/data --logpath=/var/lib/mongodb/logs --logappend --port=27017 --fork 进入mongodb，设置用户和权限 123$ mongo&gt; use admin&gt; db.addUser(&apos;yourAdminUser&apos;, &apos;password&apos;) 关闭mongod服务 123&gt; use admin&gt; db.shutdownServer()&gt; exit 再次启动（身份认证模式） 1/var/lib/mongodb$ mongod --dbpath=/var/lib/mongodb/data --logpath=/var/lib/mongodb/logs --logappend --auth --port=27017 --fork 进入mongodb，这时use database时需要认证 12use admindb.auth(&apos;yourAdminUser&apos;,&apos;password&apos;) 创建数据库，添加授权用户 12use yourDatabaseNamedb.addUser(&apos;databaseUser&apos;,&apos;password&apos;) 查看所有用户 12use admindb.system.users.find() 需要注意的是，mongod服务起来后，尽量不要用kill进程的方式来关闭服务，尽量使用如下方式来关闭 12use admindb.shutdownServer() mongod也可以从配置文件启动（启动参数位于配置文件中） 1mongod --config /var/lib/mongodb/mongodb.conf 配置内容如下 123456dbpath=/mnt/lib/mongodb/datalogpath=/mnt/lib/mongodb/logslogappend=trueauth=trueport=27017fork=true mongodb journal日志文件会持续增长，占用大量磁盘空间，如需关闭日志，可添加启动参数--nojournal。 mysql我直接看官方的guide，添加yum repo来安装最新的mysql，详见http://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/ TODO之后有空再记录nginx项目部署，以及脚本构建方面的内容。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs爬虫实现中遇到的坑]]></title>
    <url>%2Fblog%2F2016%2F03%2Fblackholes-in-node-crawler.html</url>
    <content type="text"><![CDATA[记录一些具体代码debug时遇到的问题（未完待续） 异步控制流涉及到的库 Q in Github Promise化的一种实现，promise不是万能，改造复杂的动态决定的执行链是件比较吃力的事情 async 点赞数很高的库，有人说有毒，我觉着很好用 eventproxy @朴灵的基于事件的流程控制，我觉着和promise或async搭配着使用很好用 要注意的点 避免 async 中间在 if-else 时多次调用callback()，建议都加上return callback() 整体串行，但其中某步中又有循环异步，建议内层用 async，整体用 eventproxy 去控制 Promise 化方法改造 页面请求涉及到的库 superagent 处理请求的模块 request 另一个处理请求的模块，比起 superagent，语法配置项更多一些。如果说 superagent 是 $.post()，那 request 就是 $.ajax() cheerio 用于DOM解析，提供与 jquery 选择器类似的接口 中文编码问题当请求非 uft 编码的页面时，使用 superagent 请求后用 cheerio 解析，会发现取不到想要的中文字符。网上查了后知道有个叫 iconv-lite 的东西可以用来做转码，具体做法就对 superagent 扩展一个处理过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var superagent = require('superagent');var Request = superagent.Request;var iconv = require('iconv-lite');var jschardet = require('jschardet');/* superagent扩展: 使用iconv转码，统一转成 UTF-8 用法: superagent.get(url).parse().end(...)*/Request.prototype.parse = function() &#123; // set the parser this._parser = function(res, cb) &#123; // res not instanceof http.IncomingMessage var buffers = []; res.on('data', function(chunk) &#123; buffers.push(chunk); &#125;); res.on('end', function(err) &#123; var text, err; try &#123; var buf = Buffer.concat(buffers); var enc = jschardet.detect(buf).encoding; // 注：在服务器上安装 iconv 一直出错，在本地测试是可以用下面两行转码的 // var converted = new (require('iconv').Iconv)(enc, 'UTF-8//TRANSLIT//IGNORE').convert(buf); // text = converted.toString(); // 另一种做法：先用 iconv-lite 转 text = iconv.decode(buf, enc); if(enc !== 'UTF-8')&#123; buf = iconv.encode(text, 'UTF-8'); text = iconv.decode(buf, 'UTF-8'); // FUCK 好像存下来的html文件里还是带&amp;#编码的 &#125; &#125; catch (e) &#123; err = e; &#125; finally &#123; res.text = text; cb(err); &#125; &#125;); &#125;; return this;&#125;;module.exports = superagent; 然后使用 superagent 时就引用这个扩展模块的路径 123456789var superagent = require('./extension/superagent-charset');superagent.get(url) .set('User-Agent', Settings.USER_AGENT) .timeout(Settings.REQUEST_TIMEOUT) .parse() // 编码统一转化 utf-8 .end(function (err, res) &#123; &#125;); 页面重定向问题如果是在服务端的重定向，superagent 是可以捕捉到的，而且它本身就有对 redirect() 的配置接口。现在的问题是在浏览器端的重定向，我遇到过以下两种情况 1、通过设置 meta 标签来触发浏览器 refresh 例如：http://www.jscz.gov.cn，在首页设置了 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;3;url=http://www.haishui.net&quot;&gt; 2、js脚本的页面跳转 例如：http://www.jsrm.gov.cn，在首页有一行脚本 self.location=&quot;/?WebShieldSessionVerify=HtUMyhjlcREk8TaXCDHa&quot; 以上的页面跳转都发生在首页，会导致 superagent 抓来的页面内容是空的，除了去判断类似的代码模式，然后重新请求新的地址，暂时也没想出智能的办法。。。 数据库读写事务rollbackTBD 数据库同步write问题TBD 内存错误process out of memory1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory call stack size exceeded1RangeError: Maximum call stack size exceeded 其他错误double callback!TBD ECONNRESET123456events.js:85 throw er; // Unhandled &apos;error&apos; event ^ Error: read ECONNRESET at exports._errnoException (util.js:746:11) at TCP.onread (net.js:561:26)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mooctest项目总结]]></title>
    <url>%2Fblog%2F2016%2F01%2Fproject-guideline-of-mooctest.html</url>
    <content type="text"><![CDATA[慕测平台（简称mooctest），这个项目致力于编程类考试和练习的服务平台，教师可以轻松监管考试流程，学生可以自由练习编程。系统负责编程练习的自动化评估及可视化展现，配合当下红火的MOOC慕课课程，慕测平台将是学生自学编程的好帮手。目前已支持的编程类型有：Java覆盖测试，Java测试驱动编程，Python统计编程，C++编程，Jmeter性能测试，以及Android应用测试。之所以叫“mooctest”是因为“测试”是我们的主打产品，其中Java覆盖测试、Java Debug分析，以及Android应用测试是我们的核心服务。我们帮助高校的教“软件测试”的老师便捷地组织在线考试，帮助高校的学生接触到工业界真实的app案例，以提高学生的testing能力。 项目概况 mooctest于2014.8月下旬开始启动项目，最初开发者只有2位 2014.11月，完成考试管理平台的基础建设，以及Java覆盖测试的客户端，开始第一轮内测 2014.12月，参加项目原型展示，收集第二轮内测 2015.1月，添加对Java覆盖测试的考题分析功能 2015.3月，正式上线，与网易云课堂合作，开设《概率论与数理统计》慕课课程，由mooctest系统提供“Python统计编程”练习 2015.5月，项目扩张，不断添加新科目，Java测试驱动编程，Jmeter性能测试，以及Android应用测试也有了雏形 2015.7月，Android应用测试独立成Kikbug系统，完成和mooctest系统的对接 2015.9月，Android应用测试与“阿里”达成合作，获得企业内测的真实app 2015.10月，正式在南京大学、东南大学、南京邮电大学、南通大学、大连理工等重点高校试点，作为其“软件测试”课程的白盒测试（以Java覆盖测试为例）和黑盒测试（以Android应用测试为例）的练习和考试平台 2015.11月，再次与网易云课堂合作，开设《开发者测试》微专业课程，由mooctest系统提供“Java覆盖测试”和“Debug调试”的练习 2015.12月，联合“阿里云测”以及TesterHome举办阿里云测找 bug 大赛，圆满落幕！ 截至目前，mooctest平台上已有近1万名学生和400名老师，来自全国各地500多个高校！ 项目结构我作为“码农”，还是来说说我更擅长的事，总结下这个项目的技术选型以及组织结构，以便为今后的项目作参考。 整体上我们就采用了基于Java的Play Framework 1.2.7的版本，之后出的2.0.x以上的版本是基于SCALA的，和1.x.x完全不是一个东西。而Play框架对“从Java学起的软院学生”来说非常友好，比起 Struts 和 Spring 省去了很多繁琐的xml配置和Annotation配置。综合学习成本和项目定位，Play框架是性价比很高的选择。 目录结构后台部分 lib/ 存放各种外部jar包 conf/ Play框架配置文件的目录 application.conf 项目系统设置：debug设置、session设置、server设置、数据库设置等，也可存放自定义的系统级变量设置 routes 路由(url)配置 messages.en 多语言支持的字典文件(英文) messages.zh_CN 多语言支持的字典文件(中文) app/ Play里叫这个，相当于普通project里的src目录 common/ 存放一些项目中用到的定义的常量或枚举量 Constants.java 通用常量 ExamType.java 某个自定义类型的常量 controllers/ MVC中的控制器层，以角色名开头，命名区分；注：只负责request和resonpse，不负责具体业务逻辑 AdmAccountController.java 管理员角色的Account模块 TeaExamController.java 教师角色的Exam模块 StuExamController.java 学生角色的Exam模块 managers/ 具体业务逻辑的包装，供controller调用 admin/ 供管理员角色的 student/ 供学生角色的 teacher/ 供教师角色的 application/ 供系统通用的 interfaces/ 供对外API的 models/ 与数据库对应的Model，用来做ORM(Object Relational Mapping) dao/ 封装对数据库model的原子操作，其中每个具体model的DAO类都继承GenericDao GenericDao.java 泛型DAO，提供通用的增删改查操作 ExamDao.java 具体的跟Exam相关的DAO data.structure/ 跟前台交互约定的非数据库model的数据类型 Pagination.java 跟分页相关的数据类型 WrappedExam.java 对Exam结果的包装，方便前台交互 utils/ helper方法 application/ 跟应用相关的util DataUtil.java 跟应用和模块相关的数据结构转换方法 ParamUtil.java 负责处理request的参数转换方法 ResponseUtil.java 负责对response结果的转换方法 SessionUtil.java 封装对session的操作和转换方法 VcodeUtil.java 封装对验证码的操作方法 data/ 跟通用数据相关的util EncryptionUtil.java 加解密处理的转换方法 ExcelUtil.java 封装对excel格式转换的方法 file/ 跟文件操作相关的util mail/ 跟收发邮件相关的util jobs/ 定时任务相关 extensions/ 对页面模板语法的扩展 views/ 前台页面模板，见下面 前台部分 app/views/ Base/ 页面继承的父页面模板 base_outer.html 不需要登录的页面父模板 base_inner.html 需要登录的页面父模板 base_admin.html 管理员角色的页面父模板，继承自base_inner.html base_teacher.html 教师角色的页面父模板，继承自base_inner.html Application/ 存放不需要登录的页面 class、exam、exercise 等具体功能包的页面 tags/ 自定义页面标签的模板，相当于需要被include的页面子块 examView.html 管理员和教师都需要用到此页面块，供复用 passwordView.html 个人资料页面和忘记密码页面都需要用到此页面块 public/ 存放前端资源的目录 css/ common/ 存放应用所有页面通用的css bootstrap/ 主题库相关 jquery-ui/ 主题库相关 tablesorter/ 插件相关 others/ 其他小插件的css class、exam 等具体功能包的css file/ 存放页面上供下载的静态文件 svg/ 存放编程题目源程序控制流图的svg文件 images/ 存放css的图片 bootstrap/ 主题库相关的图片 jquery-ui/ 主题库相关的图片 others/ 其他小插件的图片 js/ common/ 存放页面通用的js，或者可复用的js bootstrap/ 主题库的js jquery-ui/ 主题库的js tablesorter/ 插件的js others/ 其他小插件的js class、exam 等具体功能包的js 数据库与ORM本系统中使用 MySQL 数据库，Play框架中使用JPA提供ORM(Object Relational Mapping)的功能。 一个简单的Model类定义如下 123456789101112131415161718192021222324252627import javax.persistence.*;import play.db.jpa.Model;@Entity@Table(name="exam")public class Exam extends Model &#123; @Column(name="exam_name") private String examName; @ManyToOne @JoinColumn(name="tea_id", referencedColumnName="id") private Teacher teacher; public String getExamName() &#123; return examName; &#125; public void setExamName(String examName) &#123; this.examName = examName; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125;&#125; 也是通过简单的Annotation来配置数据库字段和成员变量的对应关系，以及一对多/多对多的关系。注意，这里不需要给Exam添加额外的id字段了，因为在Model父类中已经由JPA自带了id字段，格式为Long，所以数据库表里定义id字段时要注意设置“自增”和int(32)。 DAO事务与泛型编程如上面定义了Exam类后，该Model就被注入了JPA提供的增删改查操作了，为了防止职责乱用，我们统一约定由DAO层来封装数据库事务。这样Exam就会有个ExamDao，Teacher就会有个TeacherDao，我们会发现简单的增删改查对所有Model都适用的，为了避免简单操作方法的重复，我们引入“泛型Dao”的概念。 我在以前的文章中写过关于JPA泛型DAO，需要定义一个泛型的GenericDao类，提供通用的增删改查操作。 1234567891011121314151617181920212223242526272829303132333435public abstract class GenericDao&lt;T, PK extends Serializable&gt; &#123; private Class&lt;T&gt; clazz; public GenericDao()&#123; // 反射获取T.class，实参类型 clazz = (Class&lt;T&gt;)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]; &#125; public T findById(PK id)&#123; return (T) JPA.em().find(clazz, id); &#125; public List&lt;T&gt; findByColumn(String columnName , Object value)&#123; String[] columnNames = new String[1]; Object[] values = new Object[1]; columnNames[0] = columnName; values[0] = value; return findByColumns(columnNames , values); &#125; public List&lt;T&gt; findByColumns(String[] columnNames , Object[] value)&#123; String sqlPart = ""; for (int columnIdx = 0 ; columnIdx &lt; columnNames.length ; columnIdx++)&#123; sqlPart += "e." + columnNames[columnIdx] + " = '" + value[columnIdx].toString() + "'"; if (columnIdx &lt; columnNames.length - 1)&#123; sqlPart += " and "; &#125; &#125; return (List&lt;T&gt;) JPA.em().createQuery("select e from " + clazz.getName() + " e where " + sqlPart).getResultList(); &#125;&#125; 而具体Model都有具体的Dao去继承它 1234567891011121314151617public class ExamDao extends GenericDao&lt;Exam, Long&gt; &#123; public Exam findByTeaIdAndExamName(long teaId, String examName) &#123; String[] columns = &#123;"teacher.id" , "examName"&#125;; Object[] values = &#123;teaId , examName&#125;; List&lt;Exam&gt; list = this.findByColumns(columns, values); if (list != null &amp;&amp; list.size() &gt; 0)&#123; return list.get(0); &#125; return null; &#125; public List&lt;Exam&gt; findByTeaOpenid(String teaOpenid) &#123; return this.findByColumn("teacher.teaOpenid", teaOpenid); &#125;&#125; 关于GenericDao的更多细节请看JPA泛型DAO 后端MVC框架从上面的项目结构中已经看到，后端调用层次结构为 Controller-&gt;Manager-&gt;Dao-&gt;Model，Controller最终拿到Model数据传给前端页面，可见这是伪MVC。更准确来说是“分层”结构：上层可以调用下层，下层不能调用上层；同时上层也不能跨层调用。 我们这里说框架的MVC，更着重于Controller怎么和页面View挂钩起来，并不太涉及Model的事，这里就需要路由(url)配置。 route配置规范12345678910111213# 非登录的页面GET / Application.indexGET /faq/&#123;category&#125;/&#123;sub&#125; Application.&#123;category&#125;&#123;sub&#125;FAQ# 登录和注册POST /login LoginController.login# 角色的功能模块* /tea/&#123;action&#125; TeacherController.&#123;action&#125;* /tea/exam/&#123;action&#125; TeaExamController.&#123;action&#125;# Map static resources from the /app/public folder to the /public pathGET /public/ staticDir:public 路由配置支持定义请求方式GET or POST，也可以使用通配符，注意对于“更改”操作一定要使用POST，这是http的规范。url和Controller中的方法一一对应，并且支持变量替代，减少相似的配置条目。 前端页面继承与复用对于前端页面模板，Play框架里同样支持页面继承，Play中使用Groovy模板引擎。关于页面继承细节可看这篇文章前端要给力 — 平凡之路，虽然里面是以Django框架的模板引擎为例，但是原理相同，模板语法略有不同而已。 前端UI组件的沉淀在mooctest这个项目中，前端总体上用页面继承和自定义页面tags来组织。虽然项目起步时偷懒没有引入RequireJS来组织js，但最终还是拎出了不少js组件，使用最朴素的js类定义和jquery插件的写法来封装代码。 1、动态图表 使用Highcharts作图表库，由于项目中大部分图表都是动态从后端取数据的，所以在Highcharts上面封装了一层ajax过程，并且将各图表配置options做了剥离。具体细节可见下面这篇文章： 为Highcharts做包装 2、分页插件 这是一个jquery插件，可自动生成带“滑动窗口”的分页数目，可支持分页直接刷新页面，或者可自行配置ajax分页替换函数。具体细节可见下面这篇文章： 自己写的jquery分页插件 3、学校选择器 这是mooctest项目中最复杂的一个前端功能，并且有多处地方需要编辑学校，需要提供搜索和自定义添加学校的功能。具体实现细节可见下面这个系列文章： 一步步做组件-学校选择器(系列) 这是系列长文，讲述了如何把一段生硬实现的代码一步一步封装和扩展成为一个可配置的UI组件！ 多语言的支持前端部分讲完了，我们最后再看个和前端略有挂钩的需求，就是多语言支持。要在首页提供中文和英文的选项，并且默认使用系统语言。 系统语言判断123456789101112131415161718192021222324252627282930public class Application extends Controller &#123; static final String DEFAULT_LANGUAGE = "zh_CN"; @Before static void setGlobalLang()&#123; // langAction会将lang存入session String lang = SessionUtil.getLang(session); if(lang == null)&#123; // 获取浏览器系统语言 List&lt;String&gt; langs = request.acceptLanguage(); for(String temp : langs)&#123; // 浏览器发送的为 zh-CN if(temp.contains("zh"))&#123; temp = DEFAULT_LANGUAGE; &#125; if(Play.langs.contains(temp))&#123; lang = temp; break; &#125; &#125; if(lang == null)&#123; lang = DEFAULT_LANGUAGE; &#125; // 更新到session SessionUtil.putLang(session, lang); &#125; Lang.set(lang); &#125;&#125; 这里使用Play框架里的拦截器的概念，即上面Annotation的@Before，使得每个页面的action都会先执行setGlobalLang。语言的判断顺序为：先取session里存的语言，再取浏览器request头里传来的系统支持语言，都取不到时再提供个默认语言。 此外，还需为首页的中英文切换再提供个额外的action 123456789101112131415161718public class Application extends Controller &#123; /** 多语言 */ public static void langAction()&#123; String lang = params.get("lang"); setLang(lang); index(""); &#125; static void setLang(String lang)&#123; if(lang == null || !Play.langs.contains(lang))&#123; lang = DEFAULT_LANGUAGE; &#125; // 更新到session SessionUtil.putLang(session, lang); Lang.set(lang); &#125;&#125; 语言字典在本文最初提到的项目目录结构中就有关于messages的文件，messages.zh_CN和messages.en就是中英文的字典文件。 Play框架在这一点方面做的比较简陋，好像一个语言只能有一个字典文件，因此我们需要使用“命名空间”的概念进行分组管理。 1234567#key格式：页面名.[groupName].xxx#通用页面 common.[groupName].xxx#首页################################index.links.guide = GUIDEindex.links.download = DOWNLOADS 这里配置了英文文案，同样也要在messages.zh_CN文件里配置相同key的中文文案。 后端返回文案如果要在后端的Controller里向前端返回错误文案，多语言的支持得使用 play.i18n.Messages 1234// import play.i18n.Messages;// 这里的文案key与上面的语言字典中保持一致Messages.get("LoginController.accountNotExist") 前端的文案在前端的页面模板中，直接使用 &amp;{&#39;common.browserTitles.mooctest&#39;} 就可使用语言字典中的key 但是Play框架只会对模板文件做处理，对其注入通用变量和后端数据，模板文件其实是由后端负责渲染(转成标准html)的。由后端处理的页面模板中可以任意使用 &amp;{&#39;your_text_key&#39;} 语言标记，但是这在.js文件中是不被支持的。 我们需要在所有页面的base父页面中定义一个内联script，事先定义好所有.js中需要使用到的文案。 12345678&lt;!-- 全局多语言文案，供通用js使用 --&gt;&lt;script type="text/javascript"&gt;window.LANG_TEXT = &#123; OK: "&amp;&#123;'common.btn.ok'&#125;", CANCEL: "&amp;&#123;'common.btn.cancel'&#125;", DONE: "&amp;&#123;'common.btn.done'&#125;"&#125;;&lt;/script&gt; 内联script是在模板文件中的，可以被Play框架处理，于是语言文案就被存在了全局window里。在具体功能的.js文件中可以直接使用window.LANG_TEXT变量。 邮件队列与定时任务最后我再来说一个后端额外的小功能，发送邮件，由第三方EDM(Email Direct Marketing)商提供服务。 EDM服务购买可以在网上找到很多这样的EDM服务商，有的是专门做企业短信和邮件营销的，也有的是域名主机和服务都做的。我这儿就不打广告了，自行找一家有点规模的稳定一点的EDM服务商即可。 域名配置买好EDM账号后，在EDM管理平台上就可发邮件了，但是它们默认会给你分配一个带 `edm04621@service.xxx.com` 类似这样的邮箱。这种邮箱发出来的邮件十有八九会被扔进垃圾箱或者被拦截掉，因此我们要配置自己域名的邮箱。 设置一个域名的mx、txt和cname记录，以example.com域为例： 123edm.example.com CNAME edm.edmcn.cnedm.example.com MX sender.f.wsztest.comedm.example.com TXT v=spf1 include:spf.ezcdn.cn ~all 域名解析成功后，就可在EDM管理平台使用自己域名验证过的邮箱地址了，比如叫`service@edm.mooctest.net`，就可以大大减少邮件被扔进垃圾箱的概率。 SMTP接口上面的配置都完成后，确保在EDM管理平台上可以成功发邮件后，就可以去申请开通EDM-SMTP服务。在程序中可以通过javax.mail库去建立邮件Transport协议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.io.UnsupportedEncodingException;import java.util.List;import java.util.Properties;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;import common.Constants;public class SimpleMailSender &#123; private static final String SMTP_EDM = "smtp.trigger.edmcn.cn"; private final transient Properties props = System.getProperties(); private transient MailAuthenticator authenticator; private transient Session session; public SimpleMailSender(final String smtpHostName, final String username, final String password) &#123; init(username, password, smtpHostName); &#125; public SimpleMailSender(final String username, final String password) &#123; String smtpHost; // EDM帐号 if(isEDM(username))&#123; smtpHost = SMTP_EDM; &#125; else&#123; smtpHost = "smtp." + username.split("@")[1]; &#125; init(username, password, smtpHost); &#125; private void init(String username, String password, String smtpHostName) &#123; props.put("mail.smtp.auth", "true"); props.put("mail.smtp.host", smtpHostName); authenticator = new MailAuthenticator(username, password); session = Session.getInstance(props, authenticator); &#125; private boolean isEDM(String account)&#123; if(account.startsWith("edmc") &amp;&amp; !account.contains("@"))&#123; return true; &#125; return false; &#125; private InternetAddress getSenderAddress() throws AddressException, UnsupportedEncodingException&#123; if(isEDM(authenticator.getUsername()))&#123; return new InternetAddress(Constants.EDM_SENDER_ADDRESS, Constants.EDM_SENDER_NAME); &#125; return new InternetAddress(authenticator.getUsername(), Constants.DEFAULT_SENDER_NAME); &#125; public void send(List&lt;String&gt; recipients, String subject, Object content) throws AddressException, MessagingException, UnsupportedEncodingException &#123; final MimeMessage message = new MimeMessage(session); message.setFrom(getSenderAddress()); final int num = recipients.size(); InternetAddress[] addresses = new InternetAddress[num]; for (int i = 0; i &lt; num; i++) &#123; addresses[i] = new InternetAddress(recipients.get(i)); &#125; message.setRecipients(RecipientType.TO, addresses); message.setSubject(subject); message.setContent(content.toString(), "text/html;charset=utf-8"); Transport.send(message); &#125;&#125; 队列设计使用过EDM发送邮件的人会知道，就算我们配置了自己域名的邮箱地址，在使用SMTP协议发送时，也会遇到频率过快，或者对方邮箱拒收，等失败情况。因此我们要设计一套容错和重试的机制。 123456789101112131415161718192021222324import javax.persistence.*;import play.db.jpa.Model;@Entity@Table(name="email_task")public class EmailTask extends Model &#123; @Column(name="receiver") private String receiver; @Column(name="subject") private String subject; @Column(name="content") private String content; @Column(name="try_times") private Integer tryTimes; public EmailTask()&#123; // default this.tryTimes = 0; &#125; // 省略getter和setter&#125; 如本文上面提到的数据库与ORM所述，这里设计一个EmailTask的Model，记录下收件人、主题和正文内容，再额外存个tryTimes字段。这里我们可以规定，当重试3次仍失败后，就忽略该邮件任务。 当发送立即邮件时，比如“忘记密码”的邮件，直接使用上面的SimpleMailSender发送邮件，如果失败，则将邮件信息存成EmailTask存到数据库。而当发送非立即的邮件时，比如通知类的邮件，只需将邮件内容生成EmailTask对象存到数据库，供定时任务来调度。 立即任务与定时任务上面的邮件队列设计中所说的“立即邮件”和“非立即邮件”，其实就是“立即任务”和“定时任务”。在Play框架中有Jobs来实现任务调度。 123456789101112131415161718192021222324252627282930313233343536import play.jobs.Job;public class InstantMailJob extends Job &#123; private static EmailTaskDao taskDao = new EmailTaskDao(); private String receiver; private String subject; private String content; public InstantMailJob(String receiver, String subject, String content)&#123; this.receiver = receiver; this.subject = subject; this.content = content; &#125; public void doJob()&#123; try &#123; MailJobUtil.sendMail(receiver, subject, content); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("Send mail error for receiver " + receiver); // 发送失败，加入task，待下次再发 EmailTask task = new EmailTask(); task.setReceiver(receiver); task.setSubject(subject); task.setContent(content); // 已失败1次 task.setTryTimes(1); taskDao.save(task); &#125; &#125;&#125; 这就是“立即邮件”任务的Job，得 override doJob方法，邮件发送失败的话就加入EmailTask。使用时如下调用即可 1new InstantMailJob(receiver, subject, content).now(); 而对于“非立即邮件”任务，要使用Play框架的定时任务Job，并且设置间隔时间。 123456789101112131415161718192021222324252627282930313233343536import play.jobs.Every;import play.jobs.Job;@Every("1mn")public class BackgroundMailJob extends Job &#123; private static EmailTaskDao taskDao = new EmailTaskDao(); public void doJob()&#123; // 避免邮件服务器异常，一次只发前10个 List&lt;EmailTask&gt; tasks = taskDao.getTopTasks(); for(EmailTask task : tasks)&#123; try &#123; MailJobUtil.sendMail(task.getReceiver(), task.getSubject(), task.getContent()); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("Send mail error for receiver " + task.getReceiver()); // 把当前任务加到队尾 EmailTask failedTask = new EmailTask(); failedTask.setReceiver(task.getReceiver()); failedTask.setSubject(task.getSubject()); failedTask.setContent(task.getContent()); // 累计失败次数 failedTask.setTryTimes(task.getTryTimes() + 1); taskDao.save(failedTask); &#125; // 删除成功的任务 taskDao.remove(task); &#125; &#125;&#125; 同样也要 override doJob方法，但这里还得设置任务周期 @Every(&quot;1mn&quot;)，这个有点类似linux中的crontab。我这里设置了每1分钟执行一次任务，为了避免邮件SMTP调用频率太快而失败，每次执行Job时只取队列中前几个EmailTask。 邮件统计数据这是一开始在EDM管理平台上批量发送邮件的统计数据，发现软退率不低，查看邮局统计后发现是QQ邮箱普遍网关拦截。 而下面是使用了EDM-SMTP协议和邮件队列发送的结果统计，可见成功率稍微高一点。倒数第二条记录软退很高，是因为几乎都是QQ邮箱！ 后记项目能坚持做下去不容易，写文章更不容易，对自己是个总结，也希望可以帮到更多的人。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>泛型编程</tag>
        <tag>Mooctest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多仓库git配置]]></title>
    <url>%2Fblog%2F2016%2F01%2Fmulti-git-repo-config.html</url>
    <content type="text"><![CDATA[最早自己在github上写博客，然后实习的时候用公司内部的gitlab，回学校后实验室又要搞自己的gitlab，提交的时候发现提交信息还是以前公司的，于是恍然大悟，上github一看，果然都是这样。。。 严重影响活跃度啊有木有 (╯‵□′)╯︵┻━┻ 于是我研究了下git多仓库配置的原理（本文只介绍类Unix环境下的配置） git通用配置生成 ssh key1ssh-keygen -t rsa -C "your_email@example.com" 会有提示，一路空格即可，会在 ~/.ssh/ 下生成 id_rsa 和 id_rsa.pub 两个文件，需要将公钥（即id_rsa.pub）的内容添加到 github/gitlab 的账户ssh key设置里。 1cat ~/.ssh/id_rsa.pub 结果为：ssh-rsa AAAA省略几百个字符+yMS5Nl4F “your_email@example.com” 可以看到末尾就是你的邮箱。如果这是你的gitlab账号，那就把它加到gitlab的ssh key setting里。但如果你又想用github，又不幸的是你github账号不是这个邮箱，那么sorry，你得重新把这个新的id_rsa.pub添加到account setting里。 注意，我这里的做法是一个home目录下，只保留一份 id_rsa 和 id_rsa.pub，不管有多少个gitlab，都要把当前机器上最新的公钥添加进去。网上还查到一种办法，github/gitlab 管理多个ssh key，我觉得一个 ssh key 也能用了，就懒得折腾了。 新加仓库如果你要从零开始搭一个project，并且把代码传到git上，就像下面这样，先去 github/gitlab 上建个仓库。 123456git clone git@your_git_repo.gitcd your_git_repotouch README.mdgit add README.mdgit commit -m "add README"git push -u origin master 已有仓库如果你已经有project了，如果原来是用svn管理代码的，那需要先把 .svn 这样的目录删掉。这是svn自己生成的文件，用来比对更改的，其实文件挺大的，一般至少占project目录总大小的1/3 1find . -type d -name '.svn' | xargs rm -rf 上面命令的意思是：先(递归)找到当前路径下含有.svn的文件目录，再经xargs逐个删除。现在终于可以将project迁移到git了！ 123456cd your_projectgit initgit remote add origin git@your_git_repo.gitgit add .git commitgit push -u origin master 多仓库user配置回到一开始那张图上的问题：我github上的提交信息是公司gitlab上的信息和邮箱，导致我活跃度丢了。。。 研究后发现是 git config 的问题，在公司实习的时候误用了下面两条命令 12git config --global user.name "Your Name"git config --global user.email "your_email@example.com" --global选项是会覆盖全局的，就是说你在home下的任何目录不管使用 github 还是 gitlab，只要你用 git commit 提交，都会默认先取 global user 作为 contributor，可能会导致和你 github/gitlab 账号不符！ 解决办法 先确定自己哪个 github/gitlab 账号用的最多，把用的最多的号作为 global user （别忘了前提是id_rsa.pub都得添加到各平台上） 假设我现在gitlab用的最多 123cd your_gitlab_repogit config --global user.name "Your Name"git config --global user.email "your_email@gitlab.com" 然后要去github里改回github的账号，防止被当成其他contributor 123cd your_github_repogit config --local user.name "Your Name"git config --local user.email "your_email@github.com" 注意这里用的是 `--local` 选项，不会覆盖全局，只在当前目录生效 在github的仓库的里查看 1git config --list 可以看到最上面是global user，最下面是重写的local user 123456789push.default=matchinguser.name=Global Nameuser.email=your_email@gitlab.com省略...remote.origin.url=git@your_github_repo.gitbranch.master.remote=originbranch.master.merge=refs/heads/masteruser.name=Local Nameuser.email=your_email@github.com 终于经过一番更改后，再看github，就恢复正常啦！ gitignore最后再补充一点关于gitignore的配置，我觉得这个功能比svn好用多了！ 12cd your_git_repotouch .gitignore 配置语法： 以斜杠 / 开头表示目录 以星号 * 通配多个字符 以问号 ? 通配单个字符 以方括号 [] 包含单个字符的匹配列表 以叹号 ! 表示不忽略(跟踪)匹配到的文件或目录 此外，git 对于.gitignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。 参考github/gitlab 管理多个ssh key]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端要给力 — 平凡之路]]></title>
    <url>%2Fblog%2F2015%2F12%2Ftwisted-way-to-awesome-fe.html</url>
    <content type="text"><![CDATA[一直想总结下自己摸打滚爬的前端经历，3年，从一个极讨厌前端的人，变成一个吃前端饭碗的人。没有人带过我，跌跌撞撞的缓慢前进，但我很喜欢分享，喜欢一起进步，这会是我以后一直乐意做的事情。 综述娃娃学步 w3cschool上的 html / css / javascript / 以及jquery教程，万事开头的第一步 Say hello to the world! 小跑上路 jquery 轻松玩耍DOM和event jquery-ui 增强的UI组件 Bootstrap 从此傻瓜式排版就能搞定 Bootstrap 主题模板 and 管理系统模板 快速搭建项目，简单，好看 遇上平衡木在小跑上路的过程中，做出来的东西看起来很专业，注意是“看起来”。如果不理解真正的前端技能，那只能是看起来专业，内部结构还是乱糟糟的，或者是遇到bug不知道怎么调，东一句西一句，拆了东墙补西墙。这过程就像走在平衡木上，稍不留神就会摔下去。 首先要了解css的布局原理 盒模型 定位模型 有了布局的基本理论后，尝试去理解Boostrap里的栅格系统 row col span2 背后的style js最重要的三点: 闭包、原型、作用域 JS中的闭包及使用场合 使用闭包解决循环引用问题 闭包、原型、作用域 面试整理 关于js的原型和作用域，我没专门写过文章，建议去博客园搜下。如果想要完整的理解js语言机制，可以去看《Javascript模式》这本书，或者看我整理的读书笔记 《JavaScript模式》读书笔记系列 华丽跳跃谢幕只有把平衡木上的技能磨熟练后，我们才能真正的游刃有余，保证不从平衡木上摔下来的前提下，再有余力去设计如何华丽的跳跃和谢幕。 组件封装还没了解js对类(或模块)的封装前，我们的代码可能是这样的 1234567891011121314151617181920212223var getData = function()&#123; // ......&#125;;function editFunc()&#123; // ......&#125;;$('.refresh-btn').on('click', function()&#123; var data = getData(); var $target = $($(this).attr('data-target')); $target.empty(); for(var i=0; i&lt;data.length; i++)&#123; var $child = $('&lt;tr&gt;&lt;/tr&gt;'); $child.append('&lt;td&gt;' + data[i]['name'] + '&lt;/td&gt;'); // ...... $child.append('&lt;td&gt;&lt;a class="edit-link"&gt;编辑&lt;/a&gt;&lt;/td&gt;'); $target.append($child); &#125; $target.find('.edit-link').on('click', editFunc);&#125;); 一个点击就获取数据，然后刷新表格的功能。如果一个页面中有多个类似的异步刷新的表格，且每个表格的字段又各不相同，那么最偷懒的做法就是拷贝大段代码，然后再调整&lt;td&gt;的字段。这样的代码简直了，太难维护了！ 123456var table1 = new AjaxTable(&#123; el: '#dataTable', dataUrl: '/path/to/action/'&#125;);table1.refresh(); 如果代码变成这样，那就爽多了，获取数据和刷新表格的过程都封在了AjaxTable中，各个使用之处只需要传个参数调用下refresh()即可，减少了大量重复(相似的)代码。这就是对UI组件/功能组件的封装。 以前为了准备面试时的“手撕代码”，写过一个简单的轮播组件，不用jquery（面试经常不允许使用任何库） 原生js的Slider组件 还写过下面一些文章 自己写的jquery分页插件 为Highcharts做包装 （有点类似上面示例中的AjaxTable） 一步步做组件-学校选择器(系列) （系列长文，如何把一段生硬实现的代码一步一步封装和扩展成为一个可配置的UI组件） 模块化开发如果要在页面上引入外部的js库，最初学习的时候是这样引入的 1234&lt;script type="text/javascript" src="jquery-1.7.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jquery-ui/jquery-ui-1.8.24.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jquery-ui/jquery-ui-datepicker-zh-CN.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="bootstrap-2.3.2.min.js"&gt;&lt;/script&gt; 由于浏览器中js的执行(非加载)过程是在单线程中的，而各js文件又会存在依赖关系，比如 jquery-ui 依赖 jquery，bootstrap 也依赖 jquery，所以&lt;script&gt;标签的引入得满足依赖顺序。当一个项目越做页面越多时，这么多页面中会存在一堆&lt;script&gt;标签，如果要将某个js文件升级版本，或者修改script的依赖关系时，这就会成为一个很繁琐的工作，特别是&lt;script&gt;分散在项目的各个文件中时。 RequireJS就是出来解决这个问题的（简单来说就是用js去管理js），还有SeaJS，它们分别代表着AMD和CMD两种风格，关于模块化和两者的区别可以看这篇文章。 实战案例 用RequireJS包装AjaxChart 前端模块化开发demo之攻击地图 页面继承页面继承 这块跟上面的各种具体的技术没太大关系，页面继承主要是用来组织项目文件结构（或页面结构）的一些经验规则。假设在一个系统里，每个页面都有相同的头和尾，还有nav，那根据上面封装和分离的思想，我们可能会这样写 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;body&gt; %&#123; include header.html &#125;% &lt;div class="container"&gt; &lt;div class="left"&gt; %&#123; include nav.html &#125;% &lt;/div&gt; &lt;div class="main"&gt; &lt;!-- 具体业务... --&gt; &lt;/div&gt; &lt;/div&gt; %&#123; include footer.html &#125;% &lt;script src="require.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; requirejs.config(&#123; // 全局配置... &#125;); &lt;/script&gt; &lt;script type="text/javascript"&gt; require(['jquery'], function($)&#123; // 具体业务... &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们可以把这一段作为一个base的父页面，命名为base.html，每个“具体业务”的页面都继承自它。 12345678910111213141516171819%&#123; extends 'base.html' &#125;%%&#123; block styles &#125;%&lt;style type="text/css"&gt;&lt;/style&gt;%&#123; endblock &#125;%%&#123; block content &#125;%&lt;div&gt;具体业务...&lt;/div&gt;%&#123; endblock &#125;%%&#123; block scripts &#125;%&lt;script type="text/javascript"require(['jquery'], function($)&#123; // 具体业务...&#125;);&lt;/script&gt;%&#123; endblock &#125;% 把这个页面叫做func1.html，具体业务的页面中只会包含自身业务功能需要关心(用到)的东西，不去多管base页面的闲事。可以看到子页面中有很多block之类的锚点，会将与endblock之间的内容插入到父页面中的相应位置，所以要先在base.html中“挖好坑”。 123%&#123; block styles &#125;% %&#123; endblock &#125;%%&#123; block content &#125;% %&#123; endblock &#125;%%&#123; block scripts &#125;% %&#123; endblock &#125;% 具体做法可以去看常见的模板系统，本例中参考的是Django中的模板定义。 页面组件化页面组件化 也是和具体技术没有关系，它是顺着 页面继承 的思路，把页面或文件结构做更小粒度的拆分，页面由一个个页面组件构成。 12345678910111213141516171819202122232425%&#123; include sectionA.css &#125;%%&#123; include sectionB.css &#125;%&lt;div class="row"&gt; %&#123; include sectionA.tpl &#125;%&lt;/div&gt;&lt;div class="row"&gt; %&#123; include sectionB.tpl &#125;%&lt;/div&gt;&lt;script type="text/javascript"&gt;require(['sectionA', 'sectionB'], function(A, B)&#123; var App = Base.extend(&#123; _init: function()&#123; var that = this; var mods = [A, B]; this.modules = []; mods.forEach(function(Module)&#123; that.modules.push(new Module(App)); &#125;); &#125; &#125;);&#125;);&lt;/script&gt; 上面相当于一个业务页面，它由sectionA和sectionB两个页面组件组成，sectionA.tpl和sectionB.tpl是html模板。在应用层(即业务)页面中初始化两个js模块A和B，并且把自身的App变量传递给模块（new Module(App)），可以实现子模块与应用层页面的通信，甚至是模块之间的通信。 这样把页面拆成粒度更细的结构，好处是页面模块可以复用，也便于管理，改动页面中的一小块时只需在所处的模块中，缩小改动的影响范围。 还看过一种思想是，把css文件也当做资源由requireJS动态加载，这样上面示例中的include xxx.css都不需要了，页面模块的css资源作为该模块的依赖，写在js模块的define的依赖中。 123define(['jquery', 'sectionA.css'], function($)&#123; // 业务模块...&#125;); 这样把css和js都抽象成“资源”，相当于 组件 = 模板 + 资源 一个页面整体的模板，相当于多个页面组件的拼装而成。更进一步，如果能让页面组件做到异步渲染的话（即可以由js去解析模板语法和变量，而不是交给web框架），才能真正做到页面渲染的本质： 呈现给用户的页面 = 页面模板 (包括组件的模板) + 数据 “渲染”就是将带数据变量的页面模板输出成标准的html，同步渲染是指在服务端解析模板并输出完整html到浏览器中，而异步渲染指直接在浏览器中通过javascript 根据传入的数据将模板输出成标准html。 同一模板如果既能在服务端同步渲染，又能在浏览器端异步渲染的话，我们就不需要关心“数据”是后端框架直接输出到页面的，还是ajax动态取来的。对模板来说，数据就是个“接口”，而 模板 + 数据 = 渲染。这样我们作为前端，才能把更多精力放在模板和交互上，不用管数据的传递方式。 平凡之路前端发展了十几年，现在几乎到达顶峰的速度了，近两年推出的框架层出不穷，jquery早已不是一统江湖了。每个人的精力都有限，不可能一个个都学过来，但是必须承认，前端是一个完整的体系（我之前整理的知识体系），有它独特和魅力之处。不仅是框架，还有更多的工程化问题，框架都是为了解决某类相通的问题而生。模板和数据分离也好，“状态”和“表现”分离也好，我越来越体会到 “分”是为了“合” 这条平凡之路，还会“频繁”的发展和融合下去。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化开发demo之攻击地图]]></title>
    <url>%2Fblog%2F2015%2F12%2Fattack-map-with-amd.html</url>
    <content type="text"><![CDATA[很早以前写过一篇用RequireJS包装AjaxChart，当时用Highcharts做图表，在其上封装了一层ajax，最后只是简单套用了一下requireJS。由于当时自己才接触模块化，理解层面还太浅，后来经过其他项目的磨练以及实习获得的见识，想重新结合一个示例来写点前端模块化的开发方式。 项目背景最近在做一个安全运维监控的项目，其中有一条是根据设备获取到的攻击数据，在地图上做可视化。对比了Highcharts和ECharts ECharts对国内地图的支持更多 ECharts在模块化和扩展方面做的比Highcharts更好 所以最后我选择了基于ECharts去封装。类似的网络攻击的监控地图可看国外的Norse Attack Map，也算是同类的参照。 需求整理数据要求 提供的数据只有IP到IP的攻击，包括攻击时间、攻击类型等，需要自行根据IP定位到相应的经纬度。 展现要求 地图提供世界、中国、省份，这三种维度（只针对中国） 要在地图上表现出攻击的来源与目标之间的动画 需要强调出攻击受灾地区，可一眼看出哪里是重灾区 可以循环表现攻击，也可实时刷新攻击数据 目录结构1234567891011121314151617181920- index.html 主页面- assets - css - normalize.css 浏览器初始化样式 - common.css 从bootstrap里扒了一些基础样式 - img/ - js - app - mainMap.js index页面的主执行js - lib - echarts/ 用了源码包 - zrender/ 同样源码包，具体看echarts官方说明 - geo 一些地理数据的定义 - china/ - world/ - mods - attackMap/ 对echarts map的封装 - util.js 等等其他帮助或插件模块的封装 - xxxx.js - config.js requireJS的config配置12345678910111213141516171819requirejs.config(&#123; baseUrl: 'js/lib', paths: &#123; jquery: 'http://cdn.staticfile.org/jquery/1.7.2/jquery.min', underscore: 'http://cdn.staticfile.org/underscore.js/1.7.0/underscore-min' &#125;, packages: [ &#123; name: 'echarts', location: 'echarts/src', main: 'echarts' &#125;, &#123; name: 'zrender', location: 'zrender/src', main: 'zrender' &#125; ]&#125;); map封装过程初步封装 mods/attackMap/main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175define(function(require)&#123; var U = require('underscore'); var EC = require('echarts/echarts'); var ecMap = require('echarts/chart/map'); var ecMapParams = require('echarts/util/mapData/params').params; var EVENT = require('echarts/config').EVENT; var MAP_TYPE_WORLD = 'world'; var MAP_TYPE_CHINA = 'china'; var AttackMap = function(config)&#123; this.config = U.extend(&#123; view: MAP_TYPE_WORLD &#125;, config); this.el = document.getElementById(this.config.id); // 初始化echarts this._init(); &#125;; // 不带下划线的为对外暴露的方法 AttackMap.prototype = &#123; _init: function()&#123; // _chart对象私有 this._chart = EC.init(this.el); // default view var mapOption = U.extend(&#123;&#125;, require('mods/attackMap/mapOption')); // 合并option U.extend(mapOption.series[0], this._getViewOption(this.config.view)); // render this._chart.setOption(mapOption); // 交互 this._bindEvents(); &#125;, _bindEvents: function()&#123; var that = this; this._chart.on(EVENT.CLICK, function(e, chart)&#123; // 仅对中国钻取 if(e.data.name === '中国' || e.data.name === 'China')&#123; that.setView(MAP_TYPE_CHINA); &#125; // and中国省份钻取 else if(e.data.name in ecMapParams)&#123; that.setView(e.data.name); &#125; &#125;); &#125;, // view涉及到的series里需要设置的属性 _getViewOption: function(viewType)&#123; if(viewType === MAP_TYPE_WORLD)&#123; return &#123; mapType: MAP_TYPE_WORLD, nameMap: require('geo/world/countryName') &#125; &#125; else if(viewType === MAP_TYPE_CHINA)&#123; return &#123; mapType: MAP_TYPE_CHINA &#125;; &#125; else if(viewType in ecMapParams)&#123; return &#123; mapType: viewType &#125;; &#125; return &#123;&#125;; &#125;, _setOtherOption: function(viewType)&#123; if(viewType === MAP_TYPE_WORLD)&#123; this._chart.chart.map.series[0].itemStyle.normal.label.show = false; this._chart.chart.map.series[0].markLine.effect.period = 15; &#125; else if(viewType === MAP_TYPE_CHINA)&#123; this._chart.chart.map.series[0].itemStyle.normal.label.show = false; this._chart.chart.map.series[0].markLine.effect.period = 8; &#125; else&#123; this._chart.chart.map.series[0].itemStyle.normal.label.show = true; this._chart.chart.map.series[0].markLine.effect.period = 4; &#125; &#125;, // 设置地图视图 setView: function(viewType)&#123; // 上一次的view (typeof this._lastView === 'undefined') &amp;&amp; (this._lastView = this.config.view); // 防止重复set if(viewType === this._lastView)&#123; return false; &#125; this._lastView = viewType; // 历史开过的view（string逗号分隔） (typeof this._historyViews === 'undefined') &amp;&amp; (this._historyViews = this.config.view); // 用来判断是否加载过 if(this._historyViews.indexOf(viewType) === -1)&#123; this._historyViews += (',' + viewType); // loading this._chart.showLoading(); // 假loading var that = this; setTimeout(function()&#123; that._chart.hideLoading(); &#125;, 350); &#125; // 要先reset再draw this.reset(); var viewOption = this._getViewOption(viewType); this._chart.setSeries([viewOption]); // 多级的option没法merge原来的，所以得手动设置 this._setOtherOption(viewType); &#125;, // 攻击线 setAttacks: function(data, isLoop)&#123; // 是否循环显示markline（暂未用到） isLoop = isLoop || true; // 留个data备份（暂未用到） this._mData = data; // TODO: 要对IP聚合 // 国内最小定位到市级，国外只能定位到国家 // 而markline只能通过 name-name 来标识 // 聚合后相同 name-name 的攻击累计次数视为强度 var lineData = U.map(data, function(v)&#123; return [ &#123;name: v['srcName'], geoCoord: [v['srcLocX'], v['srcLocY']]&#125;, &#123;name: v['destName'], geoCoord: [v['destLocX'], v['destLocY']]&#125; ] &#125;); var pointData = U.map(data, function(v)&#123; return &#123; name: v['destName'], geoCoord: [v['destLocX'], v['destLocY']] &#125; &#125;); // ECharts内部的核心变量 var _map = this._chart.chart.map; // 防止addMarkLine抛异常 seriesIndex 0 // _map.buildMark(0); try&#123; this._chart.addMarkLine(0, &#123;data: lineData&#125;); &#125;catch(e)&#123; // console.error(e); &#125; try&#123; this._chart.addMarkPoint(0, &#123;data: pointData&#125;); &#125;catch(e)&#123; // console.error(e); &#125; &#125;, // 通用方法 refresh: function()&#123; this._chart.refresh(); &#125;, reset: function()&#123; this._chart.restore(); &#125; &#125;; return AttackMap;&#125;); 这里我用echarts中的MarkLine作为攻击线，MarkPoint作为受害地点，AttackMap封装了对echarts的操作过程，对外只暴露setView和setAttacks两个方法，以实现地图维度的缩放以及攻击线的表现。其中echarts map的通用配置项都拎到了mods/attactMap/mapOption.js中，这里AttackMap只手工操作部分option，比如根据地图的维度修改MarkLine动画的速率。 应用层 js/app/mainMap.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778require([ 'jquery', 'mods/attackMap/main', 'mods/attackMap/mock'], function($, AttackMap, Mock)&#123; var View = &#123; // 作为一个视图模版来初始化 init: function()&#123; // 此View片段的root元素 // this.$el = $('body'); // 初始化成员 this.aMap = new AttackMap(&#123; id: 'mapChart', view: 'world' &#125;); // 绑定事件 this._bindEvents(); &#125;, _bindEvents: function()&#123; var that = this; // 视图切换 this._bindMapViewEvents(); // 其他binding $(window).on('resize', function()&#123; that.aMap.resize(); &#125;); &#125;, // 视图切换事件 _bindMapViewEvents: function()&#123; var that = this; // NOTE: 会有动态生成的元素 $('.J_changeView').live('click', function()&#123; that.aMap.setView($(this).attr('data-type')); &#125;); &#125;, // 攻击数据展现 _renderAttacks: function(data)&#123; // render map this.aMap.setAttacks(data); // render table var $tbody = $('#attacksTable').find('tbody'); // var $frags = []; $.each(data, function(i, v)&#123; var $tr = $('&lt;tr&gt;&lt;td&gt;'+v['srcIp']+'&lt;/td&gt;&lt;td&gt;'+v['srcName']+'&lt;/td&gt;&lt;td&gt;'+v['destIp']+'&lt;/td&gt;&lt;td&gt;'+v['destName']+'&lt;/td&gt;&lt;td&gt;'+v['type']+'&lt;/td&gt;&lt;td&gt;'+v['time']+'&lt;/td&gt;&lt;/tr&gt;'); $tbody.append($tr); &#125;); &#125;, // 获取攻击数据 getAttacks: function()&#123; var that = this; // ajax TODO // 本地mock数据 that.attacksData = Mock.data; that._renderAttacks(that.attacksData); &#125; &#125;; // execution View.init(); // lazy load setTimeout(function()&#123; View.getAttacks(); &#125;, 16);&#125;); 至此，在应用层页面上，可以通过点击.J_changeView按钮来切换地图的维度(世界/中国/省份)，攻击数据的展现暂时没有ajax调用，只是简单用了mock数据来做，大体效果是一样的。 最终demo 自定义事件封装在上面的demo链接中看到，不仅应用层页面的按钮可以切换地图维度，直接点击地图里的”中国”区域也能切换地图，同时又能通知到应用层页面的按钮改变状态。因此应用层页面是需要关心AttackMap的状态(事件)的，同样将鼠标放在攻击线上出现的攻击详情，也是通过监听AttackMap的事件实现的。 1、在 mods/attackMap/main.js 中定义事件类型 123456// 对外事件AttackMap.EVENTS = &#123; VIEW_CHANGED: 'viewChanged', LINE_HOVERED: 'marklineHovered', LINE_BLURED: 'marklineBlured'&#125;; 2、在AttackMap中实现事件触发器 12345678910111213141516171819202122232425AttackMap.prototype = &#123; on: function(type, fn)&#123; (typeof this._handlers === 'undefined') &amp;&amp; (this._handlers = &#123;&#125;); (typeof this._handlers[type] === 'undefined') &amp;&amp; (this._handlers[type] = []); this._handlers[type].push(fn); &#125;, fire: function(type, data, event)&#123; if(typeof this._handlers === 'undefined' || typeof this._handlers[type] === 'undefined')&#123; return false; &#125; var that = this; var eventObj = &#123; type: type, data: data &#125;; // 原生event对象 (typeof event !== 'undefined') &amp;&amp; (eventObj.event = event); U.each(this._handlers[type], function(fn)&#123; fn(eventObj, that); &#125;); &#125;&#125;; 3、在AttackMap内部适当的方法中fire自定义事件 1234567891011121314151617181920212223242526272829303132333435AttackMap.prototype = &#123; _bindEvents: function()&#123; var that = this; // 省略... this._chart.on(EVENT.HOVER, function(e, chart)&#123; // 是markline if(e.name.indexOf('&gt;') !== -1)&#123; // 阻止此时的tooltip that._chart.chart.map.component.tooltip.hideTip(); // 由外部去渲染 that.fire( AttackMap.EVENTS.LINE_HOVERED, &#123; name: e.name &#125;, e.event ); &#125; // 不是markline，告诉外部 else&#123; // 效率有点低 每次hover都会触发 that.fire(AttackMap.EVENTS.LINE_BLURED); &#125; &#125;); &#125;, setView: function(viewType)&#123; // 省略... // 对外fire事件 this.fire( AttackMap.EVENTS.VIEW_CHANGED, &#123; viewType: viewType &#125; ); &#125;&#125;; 当触发AttackMap.EVENTS.LINE_HOVERED事件时，由于应用层页面要绘制攻击详情的浮层，需要知道鼠标位置信息，所以这里fire时将原生的event对象也传了进去。（注意fire方法的实现中，传给回调函数的eventObj对象中，有事件类型type，自定义data，以及原生event对象） 4、在应用层js中监听自定义事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 别名var MAP_EVENTS = AttackMap.EVENTS;var View = &#123; // 视图切换事件 _bindMapViewEvents: function()&#123; var that = this; // AttackMap监听 this.aMap.on(MAP_EVENTS.VIEW_CHANGED, function(e)&#123; var type = e.data.viewType; // 清空当前 $current = $('.view-nav.active'); $current.removeClass('active'); // 目标 var $target = $('.view-nav[data-type="' + type + '"]'); if($target.length == 0)&#123; // 另起一个 var $copy = $current.clone(); $copy.addClass('active').attr('data-type', type).text(type); $('#dynamicNav').empty().append($copy); &#125; else&#123; $target.addClass('active'); &#125; &#125;); // 省略... &#125;, // 攻击线(地图markline)事件 _bindMapLineEvents: function()&#123; var that = this; this.aMap.on(MAP_EVENTS.LINE_HOVERED, function(e)&#123; // 前提：srcName-destName 必须能唯一区分 // 国外IP目前只能定位到国家 var temps = (e.data.name).split(' &gt; '); var source = temps[0]; var dest = temps[1]; var attacks = that.attacksData; // 遍历data for(var i=0; i&lt;attacks.length; i++)&#123; if(attacks[i]['srcName'] === source &amp;&amp; attacks[i]['destName'] === dest)&#123; that._drawMapLineDetail(attacks[i], e.event.pageX, e.event.pageY); break; &#125; &#125; &#125;); this.aMap.on(MAP_EVENTS.LINE_BLURED, function(e)&#123; that._hideMapLineDetail(); &#125;); &#125;, // 画攻击线详情 _drawMapLineDetail: function()&#123; // 细节省略... &#125;, _hideMapLineDetail: function()&#123; // 细节省略... &#125;&#125;; 再看一遍demo 点缀的动画效果时钟模块比较简单，源码在 js/lib/mods/clock.js 中，下面只列出大体结构。 12345678910111213141516171819202122232425262728293031define(['jquery'], function($)&#123; var Clock = function(config)&#123; this.$el = $('#' + this.config.id); this._init(); &#125;; Clock.prototype = &#123; _init: function()&#123; // 细节省略... this.start(); &#125;, _update: function()&#123; // 细节省略... &#125;, start: function()&#123; // 先初始化时间 this._update(); var that = this; this.timer = setInterval(function()&#123; that._update(); &#125;, 1000); &#125;, stop: function()&#123; clearInterval(this.timer); this.timer = null; &#125; &#125;; return Clock;&#125;); move动画封装原理是采用的css中transform动画，我们原本的做法会是先定义两个css class，一个添加transform的各种css规则，另一个class添加与前一项相反(或清除动画)的css规则，然后通过js操控DOM元素，在两个class之间切换。但我觉得这种做法太挫了，可以把相同效果的transform封装起来（避免写大同小异的css class），于是我封装了一个只做move移动的动画util方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283define(['jquery', 'underscore'], function($, U)&#123; return &#123; /* 移动动画 @param el &#123;HTMLElement&#125; @param x1 &#123;number&#125; @param y1 &#123;number&#125; @param x2 &#123;number&#125; @param y2 &#123;number&#125; @param config &#123;Object&#125; @param duration &#123;number&#125; @param ease &#123;string&#125; @param isShowEl &#123;boolean&#125; 动画结束后是否继续显示元素 @param isClear &#123;boolean&#125; 动画结束后是否清除动画属性 @param beforeAnim &#123;Function&#125; @param afterAnim &#123;Function&#125; */ moveAnim: function(el, x1, y1, x2, y2, config) &#123; if(!el)&#123; return; &#125; if(!el.tagName &amp;&amp; el.length)&#123; // jquery节点 el = el[0]; &#125; var style = el.style; config = U.extend(&#123; duration: 400, ease: 'ease', isShowEl: true, isClear: false &#125;, config); style.display = 'block'; style.transform = 'translate3d(' + x1 + 'px, ' + y1 + 'px, 0px)'; style.transitionDuration = '0ms'; style.webkitTransform = 'translate3d(' + x1 + 'px, ' + y1 + 'px, 0px)'; style.webkitTransitionDuration = '0ms'; // before animation config.beforeAnim &amp;&amp; config.beforeAnim(); setTimeout(function() &#123; style.transform = 'translate3d(' + x2 + 'px, ' + y2 + 'px, 0px)'; style.transitionDuration = config.duration + 'ms'; style.transitionTimingFunction = config.ease; style.webkitTransform = 'translate3d(' + x2 + 'px, ' + y2 + 'px, 0px)'; style.webkitTransitionDuration = config.duration + 'ms'; style.webkitTransitionTimingFunction = config.ease; // 下面不会有第二次setTimeout if(config.isShowEl &amp;&amp; !config.isClear)&#123; // after animation config.afterAnim &amp;&amp; config.afterAnim(); &#125; &#125;, 0); // 动画结束后不显示元素 if(!config.isShowEl)&#123; style.display = 'none'; &#125; // 清空动画属性（下次show时显示在最初的位置） if(!config.isShowEl || config.isClear)&#123; var that = this; setTimeout(function() &#123; that._clearTransform(el); // after animation config.afterAnim &amp;&amp; config.afterAnim(); &#125;, config.duration + 10); &#125; &#125;, _clearTransform: function(el)&#123; var style = el.style; style.transform = null; style.transitionDuration = null; style.transitionTimingFunction = null; style.webkitTransform = null; style.webkitTransitionDuration = null; style.webkitTransitionTimingFunction = null; &#125; &#125;&#125;); 基于move动画的滚动表格在demo中可以看到屏幕下方的攻击数据的表格一直在滚动播放，现在已经很少人还在用&lt;marquee&gt;这种东西了，好比已经淘汰的用&lt;table&gt;做页面布局。我这里基于上面的动画util方法，实现了一个滚动播放的table组件。 实现思路是，先要对table元素做预处理，将thead拷贝一份，因为表格滚动时thead是不动的(相当于sticky)。代码结构类似上面的Clock类，主动画逻辑包在setInterval中。每次动画循环到来时，取出tbody的第一个tr元素的高度h，然后将table整体向上move这段高度h，move结束后将第一个tr追加到tbody的队尾。具体实现代码见 js/lib/mods/animTable.js 还有什么欠缺的最初的展现需求都已实现了，在这过程中封装了AttackMap，并自己实现了自定义事件，完全将echarts对外透明了。同时还产出了几个非主要的js小组件，过程看似拉的很长，但都是一步步自然而然会产生的想法。这里还遗留着一个问题，如何将html模板、样式和js模块捆绑起来，即只需reuqire一下模块，模块相应的css会一并载入。 1234567891011&lt;!-- 不需要 &lt;link rel="stylesheet" href="moduleA.css"&gt; --&gt;&lt;div&gt; &lt;!-- 引入组件的html模板 --&gt; %&#123; require moduleA &#125;%&lt;/div&gt;&lt;script&gt;require(['mods/moduleA'], function(A)&#123; // something...&#125;);&lt;/script&gt; 我想达到的效果就像上面，应用层页面不需要引组件模块的css，只要inclue一份html模板，require一下对应的js模块。有知道具体做法的吗，我想进一步交流。 demo 在线demo demo源码 感想 在繁忙的项目中抽出时间做些整理和总结，是件重要但不紧急的事情。 和以前写的文章一对比，明显感觉到自己这半年多的成长。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iWeb南京2015峰会笔记]]></title>
    <url>%2Fblog%2F2015%2F11%2Fiweb-nanjing-notes.html</url>
    <content type="text"><![CDATA[触屏版前端重构化之路苏宁 - 朱海源 H5泛指触屏版？（我觉得是一种交互和跨终端的理念） 原生实现的双向绑定 Object.defineProperty 前后端痛点 前后端交叉开发，后端会触碰到前端的js文件 前端提供的静态资源被后端随意放置 双方联调严重依赖后端环境 后端开发不爱洗头发 尝试办法 js控制权移交前端，前端承接js业务逻辑 静态资源管理权完全移交前端 搭建前端预览环境 （他们只需装个tomcat） 重构之路 公用 view.js view.css –&gt; 皮肤 数据接口化 –&gt; 前后端初步分离 核心页面兼顾SEO –&gt; 关键数据源码输出 可持续维护的前端生态圈焦点网 - 沈阳 项目演化 分为Common和App 组件代码和第三方代码全部移到Common中 Common包含：组件代码、第三方代码、全站共用代码、全站共用业务代码 App只包含业务代码和应用私有共用代码 App与App之间不能存在代码依赖关系！ 好的习惯 在每个封装的一开始写一段空白的函数，作为注释 开发工具 webstorm sublime intellij F5/browser-sync, markman web前后端实践和探索：融合or分离YOHO - 周奇琪 web开发痛点 频繁的变更需求 代码质量把控 无处不在的业务逻辑 各种兼容 重复的部分 应对方法 界定前后端切面（接口标准化） 前后端职责分离（职能专业化） 组件化，服务化，模块化 依赖管理，切面治理（Java有AOP，前端也能实现类似的概念） 实践方式 服务接口定义 页面流设计（路由） 组件化开发和使用 集成服务 用了哪些轮子 spm sea.js handlebars gulp nodejs compass yo framework 分离什么 前端能力封装 标准化的组件 通用开发模式 开箱即用的流程化工具（桩服务生成） 前端切面的分离（数据，结构，样式，行为） 单元测试，端对端测试 后端服务封装 标准的数据源（基于资源，基于服务） 标准的增删改查的行为封装（RESTful） 流程化的客户端工具（服务调试，验证，服务文档生成） 已有的项目 组件化：React，Polymer，WebComponents 开发模式：MVC，MVVM，FLUX 应用框架：angular，vuejs，Ember.js 服务标准：RESTful，GraphQL，JSON API，json-schema 开箱即用工具：Gulp，Yeoman，mocha，jsmine，webpack，swagger，jslint，babel，domJS 融合什么 对前后端标准的共识（服务，组件，切面） 业务开发的融合（业务理解更透彻） 工程化的融合（开发过程，开发工具，系统规范） Android插件架构原理途牛 - 汪亮亮 问题：方法数爆棚 65535 解法：拆分classes.dex文件 插件原理 主app是一个apk 每个模块都作为一个子app，都有单独的apk 每个团队开发自己的子apk 主apk里实现按需加载，缩小自身体积 canvas花式玩法同程 - 张扬 canvas玩法 画图像 drawImage 图像处理，如高斯模糊，滤镜 canvas一样可绘制DOM结构，样式、事件、DOM操作 视频中人物和背景的叠加 融入页面背景的复杂动画（无法用css实现） video标签一定会有自己的背景区域，无法将背景透明 制作一个动画的视频 再提取带α通道的动画视频 两者叠加，运用PS中蒙版的概念，将蒙版中非白色的区域叠加成透明 类似css中的mask canvas优势 只消耗CPU绘制过程，但页面中只有一个节点，比起SVG有一堆节点，会节约内存 比起svg里的path，canvas绘制不会有毛边，放大时 可以有效利用GPU加速 现在地图类的绘制都改成canvas了 React魔方-可视化建站千米网 - 杨晓东 业务痛点 同样的功能 不同的DOM UED + 前端 开发协调问题（主要因为有些公司UED做静态页面，前端做js动态部分，有可能把DOM结构改了） 做重复功能时，习惯性 Ctrl+C Ctrl+V 跨项目重用 业务复杂页面代码臃肿 合并代码过程痛苦 上线后再处理问题 React优势 React的强项是view，强调组件化（页面中的每块都可以封装成自己的标签，如 &lt;ItemList&gt; &lt;Item&gt;） React为什么渲染快 virtual DOM和diff算法 但是组件上位后组件之间的通信成为瓶颈 数据怎么在组件之间流转，怎么处理状态 React本身无状态，所以更简单 根据传入的状态，显示相应的渲染 前后两次传入的状态相同时，不会再次渲染 shouldComponentUpdate 可自己控制 推荐工具 flux 单向绑定的思想 immutable iflux 探索将immutable.js和react.js更好粘合的一种方案 总结这次有幸参加免费的iWeb HTML5峰会，总体上和之前QCon上的前端主题类似，各公司都在做移动端以及工程化方面的探索和融合。让我震撼的是很多小公司一样有厉害的人和团队，大公司在做的新技术的尝试和应用，小公司同样也在做，比如React和Native的融合，以及React在CMS类搭建系统中的应用。但是小公司由于人员水平层次不齐，考虑到后期维护的学习成本，很多技术没法在实际的业务中推动起来。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由弹出层引发对滚动原理的讨论]]></title>
    <url>%2Fblog%2F2015%2F10%2Fpopup-scroll-tricks.html</url>
    <content type="text"><![CDATA[上一篇为了解释移动端web的事件和点击穿透问题，我做了一个弹出框做例子，见demo。现在请把关注点转移到弹出层本身上来，我使用fix定位将它定在屏幕中间，滚动屏幕时发现问题没有，底层元素还是在滚动，只是弹出层在屏幕正中间而且周围有遮罩。所以我们就“滚动”这件事详细说说，可能存在哪些滚动需求。 页面滚动原理在PC上网页滚动主要靠鼠标滚轮，其次按“上”“下”键也能滚动页面，还可以按“空格”“Page Down/Up”以及“HOME”键，或者直接点击或拖动滚动条也能滚动页面。那么我们来做个实验，看这些事件的发生顺序是怎样的。 1234567891011121314151617document.addEventListener('scroll', function()&#123; alert('document scroll');&#125;);window.addEventListener('scroll', function()&#123; alert('window scroll');&#125;);window.addEventListener('mousewheel', function()&#123; alert('window mousewheel');&#125;);window.addEventListener('keydown', function(e)&#123; if(37 &lt;= e.keyCode &amp;&amp; e.keyCode &lt;= 40 || e.keyCode == 32)&#123; alert('keydown ' + e.keyCode); &#125;&#125;); 可以得知，当通过鼠标滚轮时，mousewheel事件会先触发，然后才是scroll。而事件的listener默认是遵循冒泡的，所以绑在document上的函数会先触发，然后才是window上的。同理，当通过按特定的键去滚动页面时，keydown事件会先触发，然后也是scroll。 PC上没啥问题，那来看看手机端的表现。 123456789101112131415document.addEventListener('scroll', function()&#123; alert('document scroll');&#125;);document.addEventListener('touchstart', function()&#123; alert('document touchstart');&#125;);document.addEventListener('touchmove', function()&#123; alert('document touchmove');&#125;);document.addEventListener('touchend', function()&#123; alert('document touchend');&#125;); 按照PC上类似的逻辑，以及前一篇文章中提到的touch事件原理，我们很容易猜出alert顺序是：touchstart -&gt; touchmove -&gt; scroll -&gt; touchend 但这是事件发生的顺序，并不是alert结果的顺序。可以扫二维码看看，这个alert很诡异的。 当慢慢滑时，只会 alert touchstart，然后就没有了。而快速滑时，alert touchstart 然后 alert scroll。这是因为alert框会阻塞事件响应，当touchstart后还没来的及滑动就已经弹出alert了，整个事件线程就被中断了，所以就不会响应scroll了。而当弹出alert后继续滑动（从开始到现在手指始终不松开），然后再松开手指，我们会发现 alert touchstart 后又 alert scroll。为什么alert又没中断事件线程呢？ 我们知道PC上的alert框是会中断整个页面的，即除非你先点“确定”，否则页面上的任何操作都是无效的，即整个用户界面被“卡住”了。而在手机上，由于触摸事件的连贯性，我猜测是这样的。当手机上弹出alert时是阻塞其他事件的，但由于手指始终没松开，所以整个触摸过程还在继续。一边是alert的阻塞性，一边是前一轮的触摸过程还未结束，由于js单线程的特性，所有事件在用户界面上的响应都是要进入队列处理的，然后才会在界面上体现出来。因为触摸过程是先发生的，它仍未结束，而alert是后发生的，所以alert并不能阻塞当前还未结束的触摸过程。因此只要不松开手指，继续滑动，最后再松开手指，alert touchstart 后还会 alert scroll。 那么还有个问题，为什么不会 alert touchmove 和 alert touchend 呢？我们继续做实验，依次把 touchstart 和 touchmove 的 alert 语句注释掉，看看表现结果。 1234567891011document.addEventListener('touchstart', function()&#123; // alert('document touchstart');&#125;);document.addEventListener('touchmove', function()&#123; alert('document touchmove');&#125;);document.addEventListener('touchend', function()&#123; alert('document touchend');&#125;); 去掉 alert touchstart 后发现只弹出 alert touchmove，我猜测是因为 touchstart / touchmove / touchend 都是在同一轮触摸过程中的，由于alert的阻塞性，前面解释了它允许先发生的触摸（还未松开的手指）继续touch，但是 alert 会阻塞同一轮触摸过程的其他事件的响应函数。而之所以alert弹出后继续滑动手指（始终不松开），仍能看到页面在滚动，这是因为这是浏览器的默认行为，并且touch过程的发生时刻早于alert，所以在队列中alert没法阻塞它。 以上只是我的猜测，有谁知道具体细节的请告诉我~ 手指不松开时，这个alert框的底层滚动问题正好也迎合了本文一开始说的弹出框demo，如果有需求说弹出框出现时必须让外部不能滚动，该怎么办？ 滚动禁用overflow我们经常会写overflow: hidden这样的css去让固定尺寸的元素写死，这样就算它的子元素超出了父容器的尺寸范围，也不会“溢出来”。借这个道理，我们可以在root元素上写死，这样body里面就不会溢出屏幕了，就不会出现滚动条了。 123html, body&#123; overflow: hidden;&#125; 但随之又出现了另一个问题，如果页面原来是有滚动条的，在windows下的浏览器中滚动条是会占据一定宽度的（chrome下是17px，firefox下可能是13px），会让整个viewport的宽度减小一段，看起就像页面里的所有元素整体往左偏移一小段。而mac下浏览器的滚动条是悬浮在上面的，所以不会占据页面上的空间。 这样的话，windows就哭了。假设页面原本就是有滚动条的，当我们打开弹出框时，为了禁止滚动，root元素被加上overflow: hidden，滚动条消失，底层所有元素就向右偏移一小段。关闭弹出框时，要让页面恢复滚动，root元素改成overflow: auto，滚动条又出现了，底层所有元素又向左偏移一小段。整个体验很糟糕！ 办法就是在overflow: hidden的同时通过padding-right把滚动条的空间预留出来。那么如何知道不同浏览器中滚动条到底占多宽呢？通常类似判断当前浏览器是否支持某个css属性或者某些取值，这种跟浏览器环境相关的问题，办法就是试探。用js动态生成一个元素，把你想测试的属性或值赋在这个元素上，然后把元素append到document中去，最后再通过js去取相应的值，看它到底表现出来是啥。 参考这篇文章，可以知道 滚动条宽度 = 元素的offsetWidth - 元素border占据的2倍宽 - 元素的clientWidth 上面公式的前提是，元素具备y轴滚动条。还有种类似办法是 滚动条宽度 = 不带滚动条的元素的clientWidth - 为该元素加上y轴滚动条后的clientWidth 123456789101112131415var getScrollbarWidth = function()&#123; if(typeof getScrollbarWidth.value === 'undefined')&#123; var $test = $('&lt;div&gt;&lt;/div&gt;'); $test.css(&#123; width: '100px', height: '1px', 'overflow-y': 'scroll' &#125;); $('body').append($test); getScrollbarWidth.value = $test[0].offsetWidth - $test[0].clientWidth; $test.remove(); &#125; return getScrollbarWidth.value;&#125;; 这是根据第一种计算方式写出的方法，有了这个再配合overflow就能实现页面滚动的禁用与恢复了。详细代码见demo 1234567891011121314var disableScroll = function()&#123; // body上禁用 $('body, html').css(&#123; 'overflow': 'hidden', 'padding-right': getScrollbarWidth() + 'px' &#125;);&#125;;var enableScroll = function()&#123; $('body, html').css(&#123; 'overflow': 'auto', 'padding-right': '0' &#125;);&#125;; 我们看看表现结果：PC上很OK，简单有效；手机上完全没卵用！（我是安卓机，注意是真机上无效，而非chrome手机模拟器） 禁用事件根据上面页面滚动原理我们做的实验，很明显可以把滚动涉及到的事件干掉，这样当然不会滚动了。 1234567891011121314151617181920212223242526272829303132// 记录原来的事件函数，以便恢复var oldonwheel, oldonmousewheel, oldonkeydown, oldontouchmove;var isDisabled;var disableScroll = function()&#123; oldonwheel = window.onwheel; window.onwheel = preventDefault; oldonmousewheel = window.onmousewheel; window.onmousewheel = preventDefault; oldonkeydown = document.onkeydown; document.onkeydown = preventDefaultForScrollKeys; oldontouchmove = window.ontouchmove; window.ontouchmove = preventDefault; isDisabled = true;&#125;;var enableScroll = function()&#123; if(!isDisabled)&#123; return; &#125; window.onwheel = oldonwheel; window.onmousewheel = oldonmousewheel; document.onkeydown = oldonkeydown; window.ontouchmove = oldontouchmove; isDisabled = false;&#125;; 这里要注意的是，不同浏览器上事件到底在window还是document上，PC上会有一些浏览器兼容处理。详细代码见demo 同样看看表现结果：PC上很粗暴的解决了；手机上也OK 弹出层滚动需求至此我们看到，使用overflow能够解决PC上的滚动禁用问题，而禁用与滚动相关的事件能够彻底解决PC和手机的问题。那么有弹出层的话，就应该禁用整个页面的滚动吗，如果弹出层内部需要滚动怎么办？即我们有可能面临这样的需求：弹出框的内部是可以滚动的，而弹出层外部和底层元素是不能滚动的。 先看overflow前面说到给root元素写上overflow: hidden就可以禁用滚动，那么我们对弹出层这个容器重新写个overflow: scroll就可以了。 123#popupLayer&#123; overflow: scroll;&#125; PC上简单有效，但是同样手机上不鸟这些。见demo 事件禁用与恢复我们把document上的mousewheel事件禁用了，即给它绑上了一个事件函数，只不过事件函数里将事件发生后的浏览器默认行为阻止了。 12345678910function preventDefault(e) &#123; e = e || window.event; e.preventDefault &amp;&amp; e.preventDefault(); e.returnValue = false;&#125;var disableScroll = function()&#123; $(document).on('mousewheel', preventDefault); $(document).on('touchmove', preventDefault);&#125;; 于是思路就来了，我们知道浏览器里的事件是遵循冒泡机制的（准确来说是先从root节点由外向内“捕获”，然后到达目标元素后，事件再由内向外逐层冒泡，关于这个机制请看这篇文章的第一部分，这不是本文的重点）。所以我们就可以为弹出层的元素再绑个同样的事件，阻止事件冒泡到document上，这样就不会调用到e.preventDefault()就不会阻止浏览器默认的滚动行为了。 123456789function preventDefault(e) &#123; e = e || window.event; e.preventDefault &amp;&amp; e.preventDefault(); e.returnValue = false;&#125;// 内部可滚$('#popupLayer').on('mousewheel', stopPropagation);$('#popupLayer').on('touchmove', stopPropagation); 来看下demo，手机上请看 背景层是不能滚动的，而弹出层妥妥的可以滚动了！但是发现问题了不，弹出层内部滚动到底部再继续滚时，会将背景底层的元素一起滚下去了，这尼玛FUCK 改进的内部滚动解决问题的思路很清晰，就是判断滚动边界，当滚动到达bottom和top时，就阻止滚动就好啦。 12345678910111213141516171819202122232425function innerScroll(e)&#123; // 阻止冒泡到document // document上已经preventDefault stopPropagation(e); var delta = e.wheelDelta || e.detail || 0; var box = $(this).get(0); if($(box).height() + box.scrollTop &gt;= box.scrollHeight)&#123; if(delta &lt; 0) &#123; preventDefault(e); return false; &#125; &#125; if(box.scrollTop === 0)&#123; if(delta &gt; 0) &#123; preventDefault(e); return false; &#125; &#125; // 会阻止原生滚动 // return false;&#125;$('#popupLayer').on('mousewheel', innerScroll); 代码很简单，关于scrollTop scrollHeight等解释请看这篇文章。这里唯一要注意的是对鼠标滚动值wheelDelta的获取可能要做兼容性处理，实在有问题的话可以使用jquery-mousewheel去获取鼠标的滚动量。 上面这段代码是PC上的判断滚动边界的处理，那手机上又该怎么做的，手机上没有鼠标，如何获取到滚动量delta？ IScroll的启发我想起“局部滚动”界的大佬——IScroll，可以去看下源码，细节很复杂但是大体结构是很清晰的。 12345678910111213141516171819202122_start: function (e) &#123; this.startX = this.x; this.startY = this.y; this.absStartX = this.x; this.absStartY = this.y; this.pointX = point.pageX; this.pointY = point.pageY; this._execEvent('beforeScrollStart');&#125;,_move: function (e) &#123; var point = e.touches ? e.touches[0] : e, deltaX = point.pageX - this.pointX, deltaY = point.pageY - this.pointY; this.pointX = point.pageX; this.pointY = point.pageY;&#125;, 这是iscroll中的一小段代码，这就是获取touchmove滚动量的办法。于是我们就能写出类似上面innerScroll适用于手机上的判断滚动边界的办法了。 1234567891011121314151617181920212223242526272829303132333435363738// 移动端touch重写var startX, startY;$('#popupLayer').on('touchstart', function(e)&#123; startX = e.changedTouches[0].pageX; startY = e.changedTouches[0].pageY;&#125;);// 仿innerScroll方法$('#popupLayer').on('touchmove', function(e)&#123; e.stopPropagation(); var deltaX = e.changedTouches[0].pageX - startX; var deltaY = e.changedTouches[0].pageY - startY; // 只能纵向滚 if(Math.abs(deltaY) &lt; Math.abs(deltaX))&#123; e.preventDefault(); return false; &#125; var box = $(this).get(0); if($(box).height() + box.scrollTop &gt;= box.scrollHeight)&#123; if(deltaY &lt; 0) &#123; e.preventDefault(); return false; &#125; &#125; if(box.scrollTop === 0)&#123; if(deltaY &gt; 0) &#123; e.preventDefault(); return false; &#125; &#125; // 会阻止原生滚动 // return false;&#125;); 这里要注意的是，我加了一条判断，弹出层内部的滚动只能纵向滚，即 deltaY 要大于 deltaX。因为我发现个bug，当没有这条判断时，弹出层内部可以横向滚，滚出的都是空白，大家可以自己试下。还有这里到底使用e.changedTouches[0]还是像iscroll里的e.touches[0]获取当前滚动的手指，其实都OK，可以看下这篇文章 最后请看demo，手机请扫二维码，效果棒棒的！ 注：一年前做这个demo时，我手机 ( Meizu Android 4.4.2 ) 上效果是OK的，在 SegmentFault 论坛上不止一个人回复说上面的方案有问题，有一半机率是不行的，快速滑的时候肯定不行。 来自SF网友的方案网友 jiehwa 的提到不需要重写事件那么麻烦，通过几个 css属性 控制即可。 弹出层父元素设置属性 overflow-y: scroll 弹窗弹出时，用js控制底层元素的 position 属性置为 fixed 弹窗关闭时，用js控制底层元素的 position 属性置为 static 在 iOS 端，为了弹窗里面的滚动效果看起来顺滑，需要设置弹窗层的包裹元素属性：-webkit-overflow-scrolling: touch css方案的demo（感谢 SegmentFault 网友） 可以看到有瑕疵，当强行将底层元素置为 fixed 后，由于 fixed 定位会让元素脱离正常的DOM文档流，所以原本位于页面底部的元素就一下子顶上来了。还有当底层元素滑动一段距离后再打开弹出层，底层元素又被 fixed 定位重置了，看着也很别扭。 仔细阅读后发现我误解了，控制底层元素的 fixed 定位应该作用在 &lt;body&gt; 的一级子元素，而弹出层的包裹元素也是 &lt;body&gt; 的一级子元素，于是 改进后的 demo 如下 现在“页面底部”这几个字不会顶上来了，但是滑动一段距离后再打开弹出层时的页面底层还是会抖动，这个暂时也想不出很好的解决方案 最后感谢叶小钗，最近一直在看他关于移动端事件原理的博客，有点学会了他那种 代码实验 -&gt; 猜测解释 -&gt; 验证原理 -&gt; 改进问题 这样的学习方法。本文也花了很大力气写代码实验，疏漏之处望多多指正，谢谢耐心的看完 参考资料知乎上的一个讨论]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也来说说touch事件与点击穿透问题]]></title>
    <url>%2Fblog%2F2015%2F10%2Ftouch-event-and-defect.html</url>
    <content type="text"><![CDATA[做过移动端H5页面的同学肯定知道，移动端web的事件模型不同于PC页面的事件。看了一些关于touch事件的文章，我想再来回顾下touch事件的原理，为什么通过touch可以触发click事件，touch事件是不是万能的以及它可能存在的问题。 touch事件的来源PC网页上的大部分操作都是用鼠标的，即响应的是鼠标事件，包括mousedown、mouseup、mousemove和click事件。一次点击行为，事件触发过程为：mousedown -&gt; mouseup -&gt; click 三步。 手机上没有鼠标，所以就用触摸事件去实现类似的功能。touch事件包含touchstart、touchmove、touchend，注意手机上并没有tap事件。手指触发触摸事件的过程为：touchstart -&gt; touchmove -&gt; touchend。 手机上没有鼠标，但不代表手机不能响应mouse事件（其实是借助touch去触发mouse事件）。有人在PC和手机上对事件做了对比实验，以说明手机对touch事件相应速度快于mouse事件。 可以看到在手机上，当我们手触碰屏幕时，要过300ms左右才会触发mousedown事件，所以click事件在手机上看起来就像慢半拍一样。 touch事件中可以获取以下参数 参数 含义 touches 屏幕中每根手指信息列表 targetTouches 和touches类似，把同一节点的手指信息过滤掉 changedTouches 响应当前事件的每根手指的信息列表 tap是怎么来的用过Zepto或KISSY等移动端js库的人肯定对tap事件不陌生，我们做PC页面时绑定click，相应地手机页面就绑定tap。但原生的touch事件本身是没有tap的，js库里提供的tap事件都是模拟出来的。 我们在上面看到，手机上响应 click 事件会有300ms的延迟，那么这300ms到底是干嘛了？浏览器在 touchend 后会等待约300ms，原因是判断用户是否有双击（double tap）行为。如果没有 tap 行为，则触发 click 事件，而双击过程中就不适合触发 click 事件了。由此可以看出 click 事件触发代表一轮触摸事件的结束。 既然说tap事件是模拟出来的，我们可以看下Zepto对 singleTap 事件的处理。见源码 136-143 行，可以看出在 touchend 响应 250ms 无操作后，则触发singleTap。 点击穿透的场景有了以上的基础，我们就可以理解为什么会出现点击穿透现象了。我们经常会看到“弹窗/浮层”这种东西，我做个了个demo。 整个容器里有一个底层元素的div，和一个弹出层div，为了让弹出层有模态框的效果，我又加了一个遮罩层。 1234567891011&lt;div class="container"&gt; &lt;div id="underLayer"&gt;底层元素&lt;/div&gt; &lt;div id="popupLayer"&gt; &lt;div class="layer-title"&gt;弹出层&lt;/div&gt; &lt;div class="layer-action"&gt; &lt;button class="btn" id="closePopup"&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="bgMask"&gt;&lt;/div&gt; 然后为底层元素绑定 click 事件，而弹出层的关闭按钮绑定 tap 事件。 12345678$('#closePopup').on('tap', function(e)&#123; $('#popupLayer').hide(); $('#bgMask').hide();&#125;);$('#underLayer').on('click', function()&#123; alert('underLayer clicked');&#125;); 点击关闭按钮，touchend首先触发tap，弹出层和遮罩就被隐藏了。touchend后继续等待300ms发现没有其他行为了，则继续触发click，由于这时弹出层已经消失，所以当前click事件的target就在底层元素上，于是就alert内容。整个事件触发过程为 touchend -&gt; tap -&gt; click。 而由于click事件的滞后性（300ms），在这300ms内上层元素隐藏或消失了，下层同样位置的DOM元素触发了click事件（如果是input框则会触发focus事件），看起来就像点击的target“穿透”到下层去了。 完整demo请用chrome手机模拟器查看，或直接扫描二维码在手机上查看。 结合Zepto源码的解释zepto中的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，是通过事件冒泡实现的。在点击完成时（touchstart / touchend）的 tap 事件需要冒泡到 document 上才会触发。而在冒泡到 document 之前，手指接触和离开屏幕（touchstart / touchend）是会触发 click 事件的。 因为 click 事件有延迟（大概是300ms，为了实现safari的双击事件的设计），所以在执行完 tap 事件之后，弹出层立马就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是隐藏元素下方的元素。 如果正下方的元素有绑定 click 事件，此时便会触发，如果没有绑定 click 事件的话就当没发生。如果正下方的是 input 输入框（或是 select / radio / checkbox），点击默认 focus 而弹出输入键盘，也就出现了上面的“点透”现象。 穿透的解决办法1. 遮挡由于 click 事件的滞后性，在这段时间内原来点击的元素消失了，于是便“穿透”了。因此我们顺着这个思路就想到，可以给元素的消失做一个fade效果，类似jQuery里的fadeOut，并设置动画duration大于300ms，这样当延迟的 click 触发时，就不会“穿透”到下方的元素了。 同样的道理，不用延时动画，我们还可以动态地在触摸位置生成一个透明的元素，这样当上层元素消失而延迟的click来到时，它点击到的是那个透明的元素，也不会“穿透”到底下。在一定的timeout后再将生成的透明元素移除。具体可见demo 2. pointer-eventspointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none，其他属性值为SVG服务。 取值 含义 auto 效果和没有定义 pointer-events 属性相同，鼠标不会穿透当前层。 none 元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。 关于使用 pointer-events 后的事件冒泡，有人做了个实验，见代码 因此解决“穿透”的办法就很简单，demo如下 12345678910$('#closePopup').on('tap', function(e)&#123; $('#popupLayer').hide(); $('#bgMask').hide(); $('#underLayer').css('pointer-events', 'none'); setTimeout(function()&#123; $('#underLayer').css('pointer-events', 'auto'); &#125;, 400);&#125;); 3. fastclick使用fastclick库，其实现思路是，取消 click 事件（参看源码 164-173 行），用 touchend 模拟快速点击行为（参看源码 521-610 行）。 1FastClick.attach(document.body); 从此所有点击事件都使用click，不会出现“穿透”的问题，并且没有300ms的延迟。解决穿透的demo 有人（叶小钗）对事件机制做了详细的剖析，循循善诱，并剖析了fastclick的源码以自己模拟事件的创建。请看这篇文章，看完后一定会对移动端的事件有更深的了解 参考资料手持设备点击响应速度，鼠标事件与touch事件的那些事 点击穿透 fastclick 彻底解决tap“点透”，提升移动端点击响应速度]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识体系以及面试点]]></title>
    <url>%2Fblog%2F2015%2F09%2Ffe-review-points.html</url>
    <content type="text"><![CDATA[之前一直在忙，也没来得及管这个博客。实习从5月干到了8月底，办离职那天，交了工牌归还电脑后，还被运营拖着解答问题，又被通知线上价格问题，借着同事的电脑把bug修了，也是因为升级代码时自己的疏忽导致的。虽然在团队里自己只是一个打杂的小前端，但是与好多同事合作过，对接过好多运营同学。走的时候和团队里一一道别，听到最多的一句话就是“早点回来”。但是很遗憾，我回不来了。没有来得及完成师兄对我的期望，没有来得及和他好好道别，没有来得及和主管挑盘台球，没有来得及吃遍食堂的所有菜点。那天晚上Jarven同学送我出去，说你走了我以后吃饭又不认识路了。只好相望于江湖，等到自己成长为大前端时，可以鼓足勇气说“I’m back.” 矫情完了。。。回校后好好回顾了下前端知识点，结合实习经验体会更深，于是想整理下。 基础篇CSS布局首先是模型的理解 盒模型 定位模型 Flexbox模型 理解类似Boostrap里的栅格系统 然后来几个实际的布局练手 相对整个屏幕的水平垂直居中 中间定宽，两边铺满容器，这样的三列布局 左边定宽，右边自适应宽度，两列的等高布局 三列固定宽度的等高布局 这些都能想出1种或两三种实现的话，CSS布局不会再难了，于是可以再看下移动端web的适配。 响应式的图片，并且是延迟加载的，要预先为图片占据空间，避免文档高度乱跳 屏幕不断变大时，同一行的元素容器里应该可以看到更多的内容，而不是将文字放大 利用Flexbox做移动端的弹性布局 大体的路线图就是这样，如果再深入的话，可能就是对一些特别的属性或兼容性的理解了，比如 IE6的盒模型是类似于box-sizing: border-box zoom: 1与hasLayout BFC（Block Formatting Context） CSS到此打住了，不是太刁难的设计稿都能hold住了！ Javascript语言机制JS里最重要的3点 作用域 闭包 原型 理解了这个后，就是运用这些特性做的一些具体方案，去解决实际问题 函数作用域的绑定，Function.prototype.bind的实现 模拟“类/模块”的实现 类式继承的实现 常用设计模式的实现，比如单例模式、观察者模式 其中还涉及到一些js变量环境和单线程的知识点，详见我以前整理的文章 《JavaScript模式》读书笔记系列 一道腾讯笔试题想到的JS中的一些特性 当然光看理论不行，得拿东西练手 实现一个Slider轮播组件 实现一个带自动提示功能的输入框组件 要注意代码的封装以及API的设计，提供一些事件及扩展性的接口，尽量优雅的去实现，并且尽量使用原生javascript。这里提供一个参考：阿当大话西游之WEB组件 HTML5新特性HTML5推动了很久了，标准定稿意味着Web 2.0时代已跨入Web 3.0时代。HTML5是否就直接简称H5，这个一直存在争议，我们先来看下HTML5到底有哪些新特性。 语义化DOM结构 多媒体支持 本地存储，突破cookie大小限制 地理定位支持 web workers 服务端事件主动推送 个人感觉HTML5并不只是一些新标签、新属性、新API，它代表着一种新的理念和趋势，即web页面的丰富交互性已经可以做到和APP类似的体验了。HTML5并不是一种编程语言，而是跨终端、重视用户体验的理念，这也是Web 3.0时代所要求的。 进阶篇虽然上面写的叫“基础篇”，要做好的话已经很进阶了，已经可以做出跨终端、交互丰富、代码优雅的web页面或者是web app了。这里写进阶篇主要是指规模较大的项目里会涉及到的一些东西，以及前端工程化的思想。 前端资源模块化CSS里衍生出来SASS和LESS，相当于加强版的CSS。而js模块化衍生出来了CMD和AMD规范。我最初觉得做模块化主要是为了复用，css和js都可以一定程度地复用。后来看了@前端农民工的文章，说模块化更多的是为了“分治”，即分而治之，觉得很有道理，尤其是在规模较大的项目中。 如果要说面试点的话，这里可能会涉及到 AMD和CMD的区别 模块Loader的大体实现思路 既然有了模块化，进行了“分治”，那接下来自然就会遇到依赖管理的问题，比如 依赖去重。a依赖[b, c]，b依赖[c, d]，如何求出a的所有依赖（算法实现） 循环依赖。a依赖[b]，b依赖[c, d]，c依赖[a]，如何求出a的依赖（避免算法死循环） 这只是依赖管理里的小打小闹，再进一步的话，整个静态资源如何管理 缓存VS更新 按需加载VS资源合并（静态资源的combo机制） 这里涉及到的知识相当多，要深入的话每一点都能挖的很深，但我们需要从整体上有个大体的了解。可参考以下资料： 前端工程——基础篇 前端工程精粹：静态资源管理与模板框架 KISSY中开启combo 了解服务端在做页面级的开发时，我们肯定会接触一点web原理方面的知识 http与https session与cookie 请求与跨域 那么再上升一层，就是整个web server，我们可以了解一些 nodejs server与ngnix DNS与CDN 如何做负载均衡 如今用nodejs来做web controller是趋势，使前端人员拥有全栈的可能性，不一定要样样精通，但是了解一些基本的网络知识是必要的。 web安全企业级项目里web安全也不可忽视，最常见的就是XSS漏洞和CSRF攻击，了解一点它们被攻击的原因，以及常用的一些攻防手段。我也不是很懂，只知道一些概念。这个方向深入下去的话，可以考虑做运维和安全人员。 高级篇只是随便取个标题用于划分，上面每个point深入下去的话都可以是高级篇，这里更多想扯些抽象原则的东西。 知其所以然才能做好性能优化性能优化涵盖的做法数不尽数，但是不管什么手段，其目的我归结成三大方面： 减少请求。很多做法最后都是为了减少请求，或是合并请求。 服务端优化。优化响应速度，或者减少传输量。 浏览器渲染原理 最难的也是渲染原理，必须知道其原理，才能去优化事件，优化动画。 前后端分离是前端工程的核心上面写的前端工程化都是在说资源管理，以及和服务端的配合，然而前后端分离才是工程化中最重要的。这方面可以看下@不四的分享换个角度看前后端分离。 最后要达到的工程化效果是： 前端不是切图仔 后端也不是套页面 前后端约定好后，前端可以基于mock数据开发 什么是前端最后要回归一个本质问题，到底什么是前端？这个问题是实习前@三七终面时问的，我一下子被唬住了。 前端 = 用户端 = 手机 + 平板 + PC 三端一致且良好的体验 这是我后来参加了2015的QCon见了世面后的第一印象，当时前端专栏的主题就是跨终端。 前端是还原设计的同时，以工程师的角度去优雅地实现。 这是我实习阶段的感受，这里“优雅地”实现并非指代码要写的多么多么牛，得看具体业务场景以及需求排期，需要工程师在设计和排期以及需求优先级之间找到平衡点，以最权衡的方式去还原设计。如果是可复用的场景，最终可沉淀出一套优雅的可扩展的实现方案。 前端要牢牢把控View层，以最适合用户的方式去展现。 这是实习时团队的主管所提倡的，由于现在native和hybrid技术的普及，不应该把web前端和native前端界限划分得太清楚，web和native本都是View层把控者。前端人员应该根据具体业务场景，去选择最合适的实现方式，而不是根据自己的技能去选择展现方式。 到底什么是前端？这类抽象问题本就不该有明确答案，就像一百个人眼中有一百个哈姆雷特。每个人的背景不同，随着经验和视野的增长，自然会沉淀出最适合自己的答案。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习小想]]></title>
    <url>%2Fblog%2F2015%2F06%2Finfected-by-intership-work.html</url>
    <content type="text"><![CDATA[来实习有一个半月了，时间过的很快，每天都挺忙，一晃眼才发现自己的博客还停留在2个月前。想当初找实习时这个博客对我起了很大作用，还是想能继续把一件事推动下去，让它发挥更大的价值。 关于师兄很幸运能来到这么好的环境下实习，更幸运自己遇到了一个极好的师兄。自从上大学到现在，6年时间，好像一直在自己摸爬滚打，从来没有人带过。只有大一第一次编程作业，问当时的高一届的校友要了份代码，然后参照着完成了。后来就再没向学长学姐咨询过，只有给学妹指导作业给学弟答疑解惑的份儿，我当时想，我们那时没人带，不也都走过来了嘛。到了研究生也是如此，由于自己对科研无爱，在实验室自成一派，当时写过一句话“在前端的道路上孤独前进”，真的很孤独，但貌似我已经习惯了。 自从遇到了现在的师兄，真正的师兄，我深感要是能早两年遇到这样的师兄，也许我能成长的更多。自己以前目标杂乱，摸爬滚打的过程中很多都是无用的时间。虽然接触前端有2年时间，但和本科毕业就直接工作了1年的同学比真相差甚远。师兄教我的不仅仅是遇到问题帮我排查，更重要的是他把自己视为项目的owner而不是仅仅是个人力，会带我一起讨论怎么让东西做的更好。有一次师兄自己在研究一份文档，然后和我说了一个想法，然后我就照着文档和他的想法去做了一番，最后达到了期望，师兄深夜发邮件让别人试用，还推了我名字。这种体验真是太爽了！ 技术氛围很喜欢这里的技术氛围，做技术的人大家都很纯粹，都为了能把事情做的更好，能让更多人简化工作。刚来的时候装一个内部软件有个功能用不起来，于是就找作者求助，我当时还在忙其他的，也没有很在意那个暂时用不到的功能。但是另一个头的作者着急了，他直接打我手机问情况，我都被这种热情惊到了。程序员都是善良又负责的人，请善待他们~ 还有次我向大牛请教问题，他们都会热情的讨论，提出更加好更加适合的办法，真能感受到大家毫无功利心的只想把事情做的更漂亮。 人之惰性听到有个同事说他刚工作的时候闲着还会自己搞些新潮的好玩的东西，而现在一点都提不起劲了，每天都烦各种需求。但同样也有人也工作了挺久，依旧充满着对世界的好奇心，出了什么新技术会愿意去尝试去折腾。反正我看到的越牛的人越勤奋，越勤奋的人越有想法。每个人都有惰性，但看到周围那么多比自己聪明的人还比自己勤奋，真的会不自觉得被带起来。有一次我只是搜一条CSS的使用场景，看到一篇文章总结的挺好，于是我把它加到自己的笔记中了，后来才知道那就是组里的大牛写的。大牛不仅负责自己部门的业务，还要发起跨团队的改进，还和其他团队一起搞新技术，同时还维护着自己的博客，牛的让你心服口服。 授之予渔看过那么多代码也不一定写的好代码，读过那么多道理也不一定过的好这一生。师兄曾写到，要让新人学会承担更多的责任。多谢师兄，教我如何以一个owner的角度去发现问题解决问题。自己很幸运，遇到了好多良师益友，最重要的是我曾经的高中班主任，教会了我如何去克服自己最弱的一面。曾经我语文很差，但是高三一年克服了提高了20分。曾经我最害怕碰前端，一碰就烦就会拖进度，而现在已经决定吃前端的饭碗了。还有就是我的研究生导师，虽然我们都觉得他是工作狂，但是他真是为自己而工作的人，他让我懂得了 你可以选择做你喜欢的事，你也可以选择做你擅长的事，但是你不能什么都不做 马云说，20岁前be a good student，30岁前follow a good boss，30-40岁work for your self，40-50岁be prefessional，50岁后work for young people 梦想还是要有的，没什么不好]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QCon2015感想]]></title>
    <url>%2Fblog%2F2015%2F04%2Ftrivial-thoughts-after-qcon.html</url>
    <content type="text"><![CDATA[此时又是在火车上，待了4天有点累，QCon 2015，第一次参加这么上档次的企业级的分享会。收获思想的同时，要感谢我的研究生导师，鼓励整个实验室的人都去参加各种会议，同时也认同我想往工程方向发展的想法，并批准我出去实习一段时间。 早就在浏览器里加过各种论坛社区的书签，不过自己花的时间还不够，只是偶尔看看一些技术论坛的采访报道，或者是在订阅的邮件里粗略扫一下那些大牛都在干嘛。这回亲身经历，很是激动，大开了眼界。见到了萌萌哒@朴灵大大，握到了手~ 还看到了传说中的@玉伯，自称黑侠，但我觉得也没有很黑。还有冷酷的@鬼道，和他那张黑客帝国的头像照片很一致。 什么是前端？这个问题是我之前面试时被问到的，回答的太low了，也怪我自己也从没想过这个问题，只是从一个网站构建的流程上大体说了下前端包含哪些工作。后来才知道面试官是@三七，幸亏我面试前几天正好看过他在QCon 2014上的采访报道，知道了Native和Hybrid这两个概念，让我侥幸过关了。 这次的QCon上Hybrid这个词被提到很多，不仅在前端主题，还在移动开发和移动平台工具主题上都有。因此从大的范围上来讲，前端已经涵盖了移动端的前端，而React的出现，更加缩小了Web前端和Native前端之间的代沟。 以前我犯了一个严重的错误，我说我只做Web端，并愿意学习移动Web端，但我绝不会去碰App开发。当时我的理由是，Android和IOS是席卷而来的，把Symbian打垮了，但说不定哪天它们也会被别的系统所取代。而HTML加JS是经过了十几年的历史证明的，虽然JS刚开始被冷嘲热讽，但是经过不断发展它已变得越来越好。所以当时我觉得只会存在浏览器厂商之间的战争，而Web平台本身不会被其他东西取代，已经存在了十几年，那么至少还能存在十几年。 这绝对是我too young too naive！技术存在的本身是为了服务，技术发展的驱动力要么是更好地服务生活，要么就是让开发更简单以降低成本提高生产力。软件技术出自工业技术，肯定有其相似之处。所以JS的发展是为了提高Web端的用户体验，Android和IOS的出现颠覆了传统手机端的用户体验。而现在大网站，像微博、美团、大众点评之类，移动端的流量已经远超PC端，所以技术发展的趋势就应该是更好地服务手机用户。那做App的话，Android和IOS得分两个团队，而且这样WinPhone用户还会不高兴。所以满足所有用户的App成本很大，于是移动端Web（主要是HTML5）的出现就降低了App的开发成本，能让一个HTML5页面至少看起来像一个App。 HTML5像App终究是“像”啊，要实现一些特殊功能的话用起来还是有差别的。于是React站出来说“我能让App开发门槛更低”，HTML5是写一份代码然后交给不同终端的浏览器，而React也是写一份代码，但它能编译出IOS和Android两个版本（Android版年底放出，WP未知）。所以我觉得这些技术都是殊途同归的，最终都是为了让移动端有更好的用户体验。而Hybrid就出来对Native和Web说，你们别吵啦，都是为了同一个孩子，就结合下吧。 前端 = 用户端 = 手机 + 平板 + PC 三端一致且良好的体验 产品工程师这个完整的名词是在听“网易云音乐”的技术总监报告时听到的，而“青云”的工程师报告中也提到了他们公司的前端工程师可以独当一面，不需要产品和美术。前者的前端是一个富交互的App，而后者的前端只是一个给工程师用的管理平台，所以后者可以不需要产品狗。但他们都提到了一句话： 要把产品当做自己的孩子 所以前端工程师进行升级，更多一点产品sense，为了一点点产品体验的提升可以付出更多的努力，也许是前端码农的一个可以发展的方向。 别人眼中的干货作为学生，可能认为“干货”就是可以直接“干”的货，我更希望能有具体的做法。但是我又too naive了，作为企业，怎么可能把最核心的具体做法暴露给竞争对手，这可是一个技术型企业的核心竞争力。因此这次QCon上，别人眼中的干货其实是这样的。 干货 = 别人已经“干”出来的货 我又想起来一幅图，很形象 有些企业只会告诉你第1步，有些可能会说到第3第4步，但绝不会告诉你最后一步。别人只会告诉你他们做过哪些尝试，做成了什么，只会告诉你大体的方向和最后的对比结果。所谓授之以鱼不如授之以渔。 干货 = 自己今后可以“干”的货 大家都在造轮子“造轮子”这个感受非常强烈，同一件事情，可能大家都在做，只是具体做法不一样，以及背后的理念也不一样。 还拿React作为例子，Facebook将它开源了，并预计在今年11月release出Android版。在这次会上得知，有家叫Geek Zoo Studio的创业公司也做了类似的事情，并且赶在这次大会前一周也开源了，它叫SAMURAI。React Native旨在帮助Web程序员也能开发IOS应用，用JSX的方式，降低IOS的开发门槛。而Samurai Native旨在让IOS开发者能够用类似HTML标签的方式来开发（将类名写成HTML标签名）。而在此之前已经有PhoneGap，但它是用WebView嵌套HTML5的伪Native（或者叫Hybrid Native）。而Samurai Native内部实现了web-core，是纯原生的，所以它的创始人称之为Semi-Hybrid。并且他称也将在今年年底出Android版。 还有一些公司在做移动开发的完整流程服务，包括环境、自动构建和部署，也包括了采用类似Web的方式来开发，最后映射成手机/平板/PC三端。 尽管上面的历史发展错综复杂，但它们本质上都在为同一件事情努力，那就是让Native开发更简单。而争相造轮子的目的，是为了提高企业核心技术竞争力。 勿忘初心这是蚂蚁金服的工程师给我的感受。他们做了一款内部使用的产品，结果响应了太多需求，做成了一个庞然大物，以致于用户不知道如何使用。最后他们2.0版本的产品砍掉了1.0版本的很多功能。 认清不做什么更重要 所以做一件事情一定要定位清晰，只为一类人服务。一旦明确了做什么，最终目标就是做“死”，只做好一件事。 勿忘初心 远方的路 永不止步]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几道JS面试题-吉祥三宝]]></title>
    <url>%2Fblog%2F2015%2F04%2Fsome-interview-questions-of-javascript-2.html</url>
    <content type="text"><![CDATA[现在坐在去北京的高铁上，刚才玩了两把极品飞车，配着列车的座位和颠簸，很带感！眼睛累了，最近确实比较忙，又是拖了好久就想写的博客，在这个特殊的地方，强烈抵制自己的拖延症！ 上一篇JS面试题都是基本数据类型，同一个人面试的话不会问太多，而JS中的原型、作用域和闭包是面试官问的最多的，我称之为“吉祥三宝”。 作用域说白了就是某个函数执行时this指向谁的问题。 问题1： 12345678var obj = &#123; run: function()&#123; function test()&#123; alert(this); &#125; test(); &#125;&#125;;obj.run(); obj.run()进入函数主体时，因为调用者是obj，因此run()内部this是指向obj的。但是run()内部又定义了一个function，直接执行了test()，因此test()内部的this未显式指定，this默认指向就是window。 问题2： 1234567891011121314151617var name = 'window';var obj = &#123; name: 'obj', child: &#123; // name: 'child', getName: function () &#123; return this.name; &#125; &#125;&#125;;var getName = obj.child.getName;alert(getName());alert(obj.child.getName()); 因为直接把obj.child.getName赋给了getName变量，因此getName就是个function，直接调用getName()时其内部this指向的是默认值window，因此alert结果是window。 而调用obj.child.getName()时，指定了调用者对象，因此函数内部的this指向obj.child对象。由于child里面的name给我注释掉了，因此obj.child.getName()里访问不到this.name，就alert出undefined（obj.name是用来迷惑的）。如果将此注释去掉的话，alert结果就是child。 问题3： 12345678910111213function a(x, y)&#123; y = function()&#123; x = 2; &#125;; return function()&#123; var x = 3; y(); console.log(x); &#125;.apply(this, arguments);&#125;a(); 这题是在ruanyf老师的微博上看到的，意思是很难的一道面试题，在console里试了下才想通了结果。 执行a()未传入实际参数，所以a()刚进入时，x`y都是undefined。然后对y变量赋值成一个函数，函数内部将改变x的值，这里的x就是a函数定义时的形式参数x`。 函数定义时括号里的叫形式参数，JS中函数调用时传入的实际参数可与形式参数数目不一致。而arguments指的是实际参数，因此a()里面this指向window，而arguments就是空数组。 然后执行a()里面的匿名函数，重新定义了局部变量x = 3，然后调用匿名函数外部的y()。而上面已说y内部改变的是a函数的形式参数x的值，因此不会影响匿名函数内部的x，所以输出结果就是3。这里也可以用闭包来解释，console.log(x)看到的就是匿名函数内部的变量x，y函数内部看不到匿名函数内部的变量。 原型原型prototype是用来实现JS中的对象继承的，具体可看我以前这篇Javascript模式之五-代码复用模式。 问题1： 12345678var A = function()&#123; this.name = 'A';&#125;;A.prototype.say = function()&#123; alert(this.name);&#125;;var B = function()&#123; &#125;; Q1：写段代码让B继承A 123var F = function()&#123;&#125;;F.prototype = A.prototype;B.prototype = new F(); 我使用了圣杯模式的思想来继承，通过一个中间的空函数，使得B的原型对象实例最小，不会包含A的实例变量name。 Q2：下面输出结果是多少？ 12var objB = new B();objB.say(); 如果按照我上面那种继承方法的话，由于B的原型对象其实F的实例（F的原型指向A的原型），F的实例中并没有name属性，所以objB.say()访问不到this.name，结果就是undefined啦。 如果上面的继承代码改成B.prototype = new A()就这一句，那么B的原型对象就是A的实例，因此B的原型中就有A的实例属性name，所以objB.say()能访问到this.name。 问题2： 123456Function.prototype.f = function()&#123;&#125;;Object.prototype.o = function()&#123;&#125;;function Factory()&#123;&#125;var car = new Factory(); Q：能调用car.f()和car.o()吗？ 首先car是个new出来的对象，而JS中所有对象的原型链追溯到顶层都是Object，即所有对象都继承自Object，因此car.o()肯定没问题。 typeof car是object，而car.constructor是Factory。typeof Factory是function，而JS中所有function的constructor默认都是Function，因此Factory.f()是能调用到的。即car.constructor.f()能调用到，而car.f()是无法调用到的。 闭包面试中问闭包问的最多的就是循环引用问题，我在使用闭包解决循环引用问题这篇文章中已经列出很多例子了。比如，有一个数组var array = [1, 2, 3, 4]，请每隔1秒依次输出数组中的元素。这里就不多写了。 总结JS中的原型、作用域和闭包是非常重要的，这是语言机制，也是这个语言的魅力。有了扎实的基础，再去理解模块化就会容易些，然后再了解一些RequireJS，就能得到面试官的喜欢，至少基础关没太大问题。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几道JS面试题-基础篇]]></title>
    <url>%2Fblog%2F2015%2F04%2Fsome-interview-questions-of-javascript-1.html</url>
    <content type="text"><![CDATA[拖了好久的文章，都是快一个月前的事了，都是电话面试的，最近的腾讯笔试居然都没过，不开心。。。避免拖延症，还是想把之前整理的和想到的赶紧写下来。 判断数组我答： 不能使用typeof判断，因为 typeof arr == ‘object’ instanceof arr == Array arr.constructor == Array 后来查资料还有一种 Object.prototype.toString.call(arr) == ‘[object Array]’ 引申：既然判断数组，如果判断数字呢？ typeof num == ‘number’ isNaN(num) == false 注意：不能用NaN判断，因为NaN !== NaN undefined与null的区别 undefined表示值缺失，未定义 null表示有值了，只不过值就是null，常用于清理内存 还有更奇怪的 1234typeof null // 'object'typeof undefined // 'undefined'Number(null) // 0Number(undefined) // NaN 一段小程序有如下数据格式 1234567891011121314151617var data = [&#123; "id": 1, "province": "江苏", "city": "南京"&#125;, &#123; "id": 2, "province": "江苏", "city": "镇江"&#125;, &#123; "id": 3, "province": "江苏", "city": "南京"&#125;, &#123; "id": 4, "province": "安徽", "city": "合肥"&#125;]; 这里我把数据简化了，它其实表示的是一家家店的所在位置，当然同一个城市可能会有多家分店。现在要写段程序，从上面的数据中提取出省份和城市，如下格式输出。 1234567891011121314151617181920212223[&#123; "text": "江苏", "value": "江苏", "children": [ &#123; "text": "南京", "value": "南京" &#125;, &#123; "text": "镇江", "value": "镇江" &#125; ]&#125;, &#123; "text": "安徽", "value": "安徽", "children": [ &#123; "text": "合肥", "value": "合肥" &#125; ]&#125;] 它就是想从一个包含重复省市的数组中去提取去重后的省市级联关系（父子关系），于是我首先想到用map，JS中就是{} 1234567891011121314151617181920212223242526272829303132333435var provinceMap = &#123;&#125;;var tempProv;var tempCity;// 遍历，用map去重for(var i=0, len=data.length; i&lt;len; i++)&#123; tempProv = data[i]['province']; tempCity = data[i]['city']; if(typeof provinceMap[tempProv] === 'undefined')&#123; provinceMap[tempProv] = &#123;&#125;; &#125; provinceMap[tempProv][tempCity] = tempCity;&#125;var result = [];// map转成arrayfor(tempProv in provinceMap)&#123; var cities = []; for(tempCity in provinceMap[tempProv])&#123; cities.push(&#123; text: tempCity, value: tempCity &#125;); &#125; result.push(&#123; text: tempProv, value: tempProv, children: cities &#125;);&#125;console.log(result); 这里provinceMap中每个province又是一个map，里面我用city名做key，比起用数组还得每次去重，这算比较偷懒的写法，把工作交给了编译器。 然后被问：还有别的去重办法吗？ 提示：用字符串 还是用上面的provinceMap，不过每个province key对应的是一个字符串，像南京 镇江用特定符号分隔。如此去重只要用indexOf判断即可。 小结这篇主要考的是JS中的基本数据类型，数值、布尔、字符串、null和undefined，除这5种外，其他都是对象，数组也是对象。JS面试中最重要的几点都是：作用域、原型、闭包，请看下一篇。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(8)]]></title>
    <url>%2Fblog%2F2015%2F04%2Fstep-by-step-js-component-schoolbox-8.html</url>
    <content type="text"><![CDATA[最近面试经常拿这个学校选择器作为例子来讲自己的JS学习过程，有位工程师哥哥直接打开这里“注册”里的第二步，就是我这个功能最初应用的地方。跟他讨论实现模态时事件的unbind这种方式是不是不好时，他给了我一点启发，于是我回过头来重新思考。 问题来源假设页面上有这么三行元素 123456789101112131415&lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt;&lt;/div&gt;&lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt;&lt;/div&gt;&lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt;&lt;/div&gt; 想要对每行都“选择学校”，并将选中的值填回该行中的input元素中，最早代码是酱紫的。 1234567891011$('.choose-school').click(function(event)&#123; var $source = $(this); // 监听自定义事件 schoolBox.on('schoolChosen', function(data)&#123; $source.siblings('.school-input').val(data.schoolName); $source.siblings('.school-id').val(data.schoolId); &#125;); schoolBox.show();&#125;); 当点一个元素时没问题，但是点了两个三个元素后，就会发现每次“选择学校”后都会一起刷新。原因就在于这三个元素都把各自的回调加绑到了schoolChosen事件中，而schoolBox的schoolChosen被触发时，它会依次调用绑到它身上的handlers。 在SchoolBox内部的实现中，使用一个map来记录所有的事件回调，key是事件名称，而value是监听该事件的回调函数的数组。 12345678910111213141516SchoolBox.prototype = &#123; on: function(type, handler)&#123; if(typeof this.handlers[type] === 'undefined')&#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function(type, data)&#123; if(this.handlers[type] instanceof Array)&#123; var handlers = this.handlers[type]; for(var i=0, len=handlers.length; i&lt;len; i++)&#123; handlers[i](data); &#125; &#125; &#125;&#125;; 因此以上实现代码是有弊端的，页面上多个元素共享同一个模态对话框时，无法正确地响应事件。 在上一篇一步步做组件-学校选择器(7)中使用了一种暴力的解决办法，每次click时都对SchoolBox对象unbind掉所有的事件，然后重新监听，以保证每次打开SchoolBox时handlers map中该事件类型的回调函数只有唯一的一个。很明显这种做法不是很妥。 从监听上入手由于上面的代码在监听时只绑定事件名称，不区分监听者元素，因此很容易想到在on监听时把当前操作的元素ID连同回调函数一起传入。这样的话，SchoolBox内部的handlers的map格式要稍微改下，即{ eventType1: { sourceId1: function(){} } }这样的格式。 123456789101112SchoolBox.prototype = &#123; on: function(type, sourceId, handler)&#123; if(typeof this.handlers[type] === 'undefined')&#123; this.handlers[type] = &#123;&#125;; &#125; this.handlers[type][sourceId] = handler; &#125;, fire: function(type, data)&#123; var handler = this.handlers[type][this.curSourceId]; handler &amp;&amp; handler(data); &#125;&#125;; 这里on时由type + sourceId来确定handler，注意这里fire时根据type + this.curSourceId来取出相应的handler回调函数。而这个this.curSourceId需要在SchoolBox每次被打开的时候更新，每次被关闭的时候清空其值。 1234567891011121314151617SchoolBox.prototype.show = function(sourceId)&#123; // 记录当前打开SchoolBox的触发元素 if(sourceId)&#123; this.curSourceId = sourceId; &#125; //以下省略...&#125;;SchoolBox.prototype.hide = function()&#123; // 清空sourceId触发元素 if(this.curSourceId)&#123; this.curSourceId = null; &#125; //以下省略...&#125;; 最后应用层的监听代码就像这样 123456789101112$('.choose-school').click(function()&#123; var $source = $(this); var id = $source.attr('id'); // 监听自定义事件 schoolBox.on('schoolChosen', id, function(data)&#123; $source.siblings('.school-input').val(data.schoolName); $source.siblings('.school-id').val(data.schoolId); &#125;); schoolBox.show(id);&#125;); 虽然每次show时都要传入当前元素的ID，但是肯定比每次click都先unbind全部，再重新bind要好。 学校选择器v9 Demo 看起来是没错像上面的应用层代码，在监听时判断的话，每个监听者元素被click时，都会重新去执行schoolBox的on方法，反复地生成同一个匿名的回调函数并绑定到同一个位置（handlers[type][id]）。显然上面的代码能够改成这样。 12345678910111213141516var $source;var callback = function(data)&#123; $source.siblings('.school-input').val(data.schoolName); $source.siblings('.school-id').val(data.schoolId);&#125;;$('.choose-school').each(function()&#123; // 监听自定义事件 schoolBox.on('schoolChosen', $(this).attr('id'), callback);&#125;);$('.choose-school').click(function()&#123; $source = $(this); schoolBox.show($source.attr('id'));&#125;); 引入了一个全局的$source变量去记录当前click的元素（以使回调中能够正确操作相应的元素），虽然这样很矬，但是至少避免了每次click时都去执行schoolBox的on方法，而且在循环中使用了callback函数的引用，避免了重复生成相同的匿名函数。总的来说，虽然长得丑，但是效率上是有提高的。 反思但是对于其中这小段代码 1234$('.choose-school').each(function()&#123; // 监听自定义事件 schoolBox.on('schoolChosen', $(this).attr('id'), callback);&#125;); 我开始怀疑自己，为什么在一个循环中反复去为不同的元素ID监听同一个事件类型，更可笑的是使用同一个回调函数？于是我开始反思当初设计监听者回调函数的初衷。 最早在一步步做组件-学校选择器(2)中我是这样使用回调的。 123456var schoolBox = new SchoolBox(&#123; appendTo: '#schoolBoxWrapper', schoolClickCallback: function()&#123; // 省略... &#125;&#125;); 这样的缺点是，如果页面中有多个不同的元素都要对“学校选中”做出响应，那么这部分响应代码都得写在这个schoolClickCallback这里。如果需要响应的那些元素来自页面的不同区域，负责完全不同的功能，这样把响应代码都揉在一个地方的话，会造成一定的耦合。 所以出于这样的考虑，我想到使用观察者模式（即自定义事件），不同的元素各自监听自己需要的事件，自己维护自己如何响应。 1234$('.choose-school').each(function()&#123; // 监听自定义事件 schoolBox.on('schoolChosen', $(this).attr('id'), callback);&#125;); 而这段代码似乎与这个初衷有点走歪路了，首先它们确实是不同的元素，但也是相似的元素，而它们监听的事件类型也相同，对事件响应的方式也相似。如此“强行”为不同的元素各自监听，是不是有点生搬硬套的意思了？ 在回调时判断我从事件委托那里得到了启发，为何不为相似的元素统一监听一个事件，并且只有唯一一个回调函数。具体做法就是在fire事件时加入“由哪个元素触发”，以避免对所有元素都做出响应。 123456789101112131415161718192021SchoolBox.prototype = &#123; on: function(type, handler)&#123; if(typeof this.handlers[type] === 'undefined')&#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function(type, data)&#123; // 加入sourceId给回调参数 if(this.curSourceId)&#123; data['sourceId'] = this.curSourceId; &#125; if(this.handlers[type] instanceof Array)&#123; var handlers = this.handlers[type]; for(var i=0, len=handlers.length; i&lt;len; i++)&#123; handlers[i](data); &#125; &#125; &#125;&#125;; 这里对on不做改变，this.handlers还是原来的{ eventType1: [ function(){} ]}格式。在fire内部，在handlers回调前，把当前的this.curSourceId（当前打开SchoolBox的触发元素ID）也塞到回调参数data中。 这里同样要为SchoolBox的show和hide方法里加入curSourceId的判断，代码同从监听上入手。 然后应用层具体的回调函数中只需要加入对sourceId的判断。 123456789101112// 监听自定义事件schoolBox.on('schoolChosen', function(data)&#123; if(data.sourceId)&#123; var $source = $('#' + data.sourceId); $source.siblings('.school-input').val(data.schoolName); $source.siblings('.school-id').val(data.schoolId); &#125;&#125;);$('.choose-school').click(function(event)&#123; schoolBox.show($(this).attr('id'));&#125;); 在回调时找到“打开SchoolBox”的触发元素，然后只对相应的元素做出响应。正如事件委托比“为所有子元素都绑定事件”要好一样，这里“在回调时判断”也比“在监听时判断”效率要高。 学校选择器v10 Demo 写在最后这个系列的文章从第1篇到现在第8篇，前后跨度2个半月，而最早在项目中做这部分功能已经是半年前了。经过这段反复审视代码和写博客的过程，自己得到了不少的提高，把以前看书看别人博客所记下的一堆零碎的知识融合了起来。也正是这个项目和这个博客，在我找实习面试的时候帮我加了很多分。 我会继续坚持走下去，回头看看走过的路和踩过的坑。谢谢~~（本系列完结）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几道CSS面试题]]></title>
    <url>%2Fblog%2F2015%2F04%2Fsome-interview-questions-of-css.html</url>
    <content type="text"><![CDATA[横向布局问：可以用哪些CSS属性让一个个div一个接一个地横向排列？ 我答： display: inline-block float: left（注意父元素塌陷） table布局（N前年的过时网站是这样子的，现在不推荐使用table布局，效率低） 使用absolute定位，一个个设好偏移应该也可以（我实在想不出了） 他提示说：有没有CSS3的属性也可以？ 我：。。。 他换个问题：display有哪些取值？ inline, block, inline-block table, table-row, table-cell类 none, initial, inherit 仍然不是他想要的。。。 回头查资料： display还有felx, grid, inline-flex, inline-grid以及-webkit-box, -webkit-inline-box等CSS3的属性值。 回到最初的问题，让一个个div元素横向排列，还可以使用下面的办法。 对父元素设display: flex或-webkit-box（IE10下用-ms-flexbox） IE10+下对父元素设display: grid，子元素设grid-column和grid-row来实现grid layout 居中问：如何让一个元素在它的父元素中水平、垂直居中？（经典的居中问题） 我答： 先来水平居中 子元素display: inline-block，然后父元素text-align: center 子元素设width，然后margin-left: auto, margin-right: auto 然后垂直居中 子元素是单行文本的话，直接line-height等于父元素height 子元素是多行文本或图文并排的话，父元素display: table-cell, vertical-align: middle 回头看笔记： 还有一种也可以实现水平居中，父元素设relative定位，子元素设absolute定位，子元素left: 50%，margin-left等于负1/2的width即可。模态框的居中一般使用这种办法。 1234567891011121314151617181920.mask&#123; background-color: #666; height: 100%; left: 0; opacity: 0.3; position: absolute; top: 0; width: 100%; z-index: 99;&#125;.modal&#123; background-color: #fff; height: 300px; left: 50%; margin-left: -200px; position: fixed; top: 120px; z-index: 100; width: 400px;&#125; 边框问：除了用border，还有什么其他属性可以画边框？只要让用户看起来像个边框即可。 我答： background，画个边框的图片 box-shadow，阴影应该也能看起来像个边框吧。。。 想不出了，他进而问：box-shadow最多能画几条边框？ 我：（这是什么鬼）。。。 回头查w3school： outline border-image，CSS3中支持的属性 边框从内到外的效果如下图 黄色的一片是background（其实是background-image）；蓝色和红色相间的菱形是border-image（同时设了border宽度和transparent）；绿色的方块是outline；右下边有一条灰色的阴影是box-shadow。 因此可以看到background只能填充到元素的content + padding，向外然后是border，而outline和box-shadow都在border之外。demo在这里 float塌陷问：你上面提到了float会导致父元素塌陷的问题，有哪些办法？ 我答： 暴力法，父元素overflow: hidden，IE下要加一条*zoom: 1以触发hasLayout clearfix法 123456789101112.clearfix &#123; *zoom: 1;&#125;.clearfix:before,.clearfix:after &#123; display: table; line-height: 0; content: "";&#125;.clearfix:after &#123; clear: both;&#125; 接着问：IE下加*zoom: 1就够了吗？ 我：。。。 回头查资料： 我觉得多设个zoom够了，只不过这只针对IE6，同时zoom是IE的私有属性。看了对overflow与zoom”清除浮动”的一些认识，还有别的办法也能清除浮动。 父元素也float 父元素position: absolute 父元素display: inline-block 引用absolute绝对定位的非绝对定位用法中的一段话来解释这后三种清除浮动的原理： 浮动的本质就是“包裹与破坏”，破坏高度，浮动元素的实际占据高度为0；而absolute元素（无定位值）也是“包裹与破坏”，只是其“破坏”比float更加凶猛，不仅实际的高度没有，连实际的宽度也没有。 参考资料CSS3 Grid Layout CSS box-flex属性，然后弹性盒子模型简介 对overflow与zoom”清除浮动”的一些认识 absolute绝对定位的非绝对定位用法]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道腾讯笔试题想到的JS中的一些特性]]></title>
    <url>%2Fblog%2F2015%2F03%2Fa-question-of-intern-recruit-test-by-tencent.html</url>
    <content type="text"><![CDATA[昨天参加了腾讯2015实习生招聘的线下笔试，之前在他们提供的在线模拟笔试中已经被鄙视了，我真的不会C++，数据结构和算法方面也一点没准备。这次笔试就在我们学校里，就想着去锻炼下，无所谓结果。C++的比重还是不少，多了一些数学方面的题目，我只是想投web前端的，可是看来看去只有一道javascript的题目，也没有web方向的选做题。 题目是这样的123456789101112131415161718var a = 0;function one()&#123; for(var i=0; i&lt;10; i++)&#123; setTimeout(function()&#123; a += i; &#125;, 0); &#125;&#125;function two()&#123; setTimeout(function()&#123; alert(a); &#125;, 0);&#125;one();two(); 问：当弹出alert框时里面的值是多少？ 一看又是循环引用问题，可以看看我前面两篇写闭包的文章。 这题如果只有这一个point的话，我也不高兴再写了，因为还有一个我觉得比较重要的语言特性。 JS是单线程的说“JS是单线程”可能有点不确切，应该说javascript引擎是单线程的。 浏览器内核中至少有三个常驻线程：javascript引擎线程，界面渲染线程，浏览器事件触发线程。除此以外，也有一些执行完就终止的线程，如Http请求线程，这些异步线程都会产生不同的异步事件。 浏览器是多线程的，但JS引擎是单线程的。我们来看个图 JS引擎是单线程运行的，浏览器无论在什么时候都只且只有一个线程在运行js程序。 在JS引擎运行脚本期间，浏览器渲染线程都是处于挂起状态的，也就是说被“冻结”了。 setTimeout与setInterval如上图所示，当我们把一个function放到setTimeout中后，该function相当于被加到了图上的Timer队列中。同时JS引擎中还有一个定时触发器，当setTimeout所设的延迟时间到了后，它会去唤醒Timer队列中相应的function。但是定时触发是有前提的，就是JS引擎处于空闲的时候才会去触发。 1234567setTimeout(function()&#123; alert('hello');&#125;, 1000);for(var i=0; i&lt;100000; i++)&#123; // 开销大的计算&#125; 举个例子，先往Timer中放入了函数，指定它1秒后执行。但是随后JS引擎要执行一段超大循环的复杂计算，这个过程需要10秒才能全部计算完。如此的话，那个定时触发的函数也需要在10秒后（等JS引擎空闲下来后）才会被触发。 而setInterval设置间隔触发的时间，会在JS引擎中反复放该函数块，相当于“时间片”，JS引擎会间隔地去触发这些函数片。但是呢，这个间隔时间也是不一定的，它们被触发的前提都是需要JS引擎在空闲的时候。 123456setInterval(function()&#123; for(var i=0; i&lt;100000; i++)&#123; // 开销大的计算 &#125; alert('hello');&#125;, 1000); 这个例子跟上面类似，setInterval中设置的函数是一个时间开销很大的过程，如果设置完后JS引擎就空闲了，那么第一次触发的时候会在1秒后。但是第一次触发执行时，需要花费10秒才能执行完，那么该函数执行完后紧接着会继续被触发（因为已经超过了它当初被设置的1秒的间隔）。这样相当于该函数被连续执行并且彼此之间没有时间间隔。 小结下setTimeout与setInterval设置的时间并不一定就是实际情况下的触发时间，要根据它们被定义完后剩下的JS脚本的执行时间，以及它们被定义的内部函数的执行时间。 需要注意的是，不能在setInterval中放入时间开销巨大的过程，这样会让JS引擎一直繁忙，页面上的事件回调也就无法被触发了，因为它们都在单线程的JS引擎中。 如果实际应用中真的有时间开销很大的JS脚本，会导致浏览器UI无法响应用户的任何操作（因为JS执行时UI线程是被挂起的）。应该尽量避免这种情况，可以将JS任务拆分成多个小任务，把每个小任务都放到setTimeout中并设置一点小间隔时间。虽然这样会导致完成整个任务需要花费的时间更长，但是这样能避免JS引擎始终繁忙，给它留有一点空闲时间去响应用户的操作和事件回调，这样用户体验会更好。 最近的浏览器为长期运行的脚本提供了另外一个解决方案：Web Workers。它为浏览器提供了背景线程支持，可以将任务比较繁重的计算放在单独一个文件中，从主程序（网页）中调用该文件。详细内容超出了本文的范围，具体可以看官方文档。 setTimeout(0)并不是立即执行看了上面，setTimeout(function(){}, 0)仍然会把function加到JS引擎的Timer中。设置timeout时间为1毫秒或者0毫秒，实际上与浏览器和操作系统有关。0毫秒不意味着没有timeout，而是指尽可能快的处理。例如在IE中，最快的时钟周期是15毫秒。 综合分析题目有了上面的理论基础，这道题就迎刃而解了。 123456789101112131415161718var a = 0;function one()&#123; for(var i=0; i&lt;10; i++)&#123; setTimeout(function()&#123; a += i; &#125;, 0); &#125;&#125;function two()&#123; setTimeout(function()&#123; alert(a); &#125;, 0);&#125;one();two(); 首先one()被执行时，它里面有个for循环10次，往Timer中添加了10个function(){ a += i; }这样的函数。然后two()被执行时，它往Timer中添加了function(){ alert(a); }这个函数。现在Timer队列中有11个函数。 由于设置的timeout为0毫秒，等待了一个时钟周期后（时间可以忽略不计），就开始依次触发Timer队列中的函数。 由于one()中的for循环执行完后，变量i的终值是10，所以Timer中的function(){ a += i; }执行时看到的i值就是10。这里不清楚原因的话，可以看这篇使用闭包解决循环引用问题。 所以Timer中前10个函数执行下来后，全局变量a的值就是100。然后执行第11个函数，alert出100。 总结小小的一道程序结果题，也能涉及到很底层的语言机制。只有把语言机制理解透了，才能改进真正开发过程中的代码，而不是仅仅把题目做对。这篇中讲到的JS单线程和setTimeout机制，是我对以前看书和看别人文章的零碎笔记的二次整理。重新思考后，自己理解的印象更深了。 我平时使用印象笔记积累知识，包括自己的看书笔记和网页裁剪来的别人的文章。但是那么多不可能一下子都能记住，通过写博客重新整理和思考，以去解决实际中遇到的问题。最后谢谢大家的支持，我会努力学习和写博客！理解不对的地方，也欢迎留言一起讨论！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用闭包解决循环引用问题]]></title>
    <url>%2Fblog%2F2015%2F03%2Fapply-closure-to-forloop.html</url>
    <content type="text"><![CDATA[上一篇讲了JS中的闭包以及它的几个使用场合，其中有一个就是解决循环引用问题，这篇我将用更多的例子再来看看这个问题。 问题来源假设页面中有4个div如下 1234&lt;div&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;div&gt;444&lt;/div&gt; 现在要为每个div添加事件，以使点击它们时能弹出其innerHTML（点击第1个div弹出111，点击第4个div弹出444）。 1234567var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; var div = elems[i]; div.onclick = function()&#123; alert(div.innerHTML); &#125;;&#125; 结果并不是想的那样！当for循环结束时，其内部的div变量的最终值是第4个元素，因此当div元素被点击时，onclick函数内部看到的变量div值其实就是第4个元素，因此都弹出的是444。 再将代码改成这样 123456var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; elems[i].onclick = function()&#123; alert(elems[i].innerHTML); &#125;;&#125; 结果又与上面的错误不一样！当for循环结束时，最终i的值是4，因此当div元素被点击时，onclick内部elems[i]即elems[4]为undefined，无法弹出值。 使用闭包在上一篇中，我们使用的闭包是这样的。 123456789var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; (function(i)&#123; var div = elems[i]; div.onclick = function()&#123; alert(div.innerHTML); &#125;; &#125;)(i);&#125; 但是有没有觉得这个闭包“包”的范围太大了，可以精简一下。 123456789var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; var div = elems[i]; div.onclick = (function(div)&#123; return function()&#123; alert(div.innerHTML); &#125;; &#125;)(div);&#125; 这里onclick绑的函数是一个匿名的自执行函数，该匿名函数以当前的div作为参数，自执行后又返回了一个函数才是真正的onclick函数。虽然比起前面一段代码，这段代码的闭包范围是小了点，但只是把前面闭包内部声明的变量div，变成了这段代码里匿名函数的参数。本质上闭包对变量的存储开销并没怎么省，上面的代码还能再改进。 12345678var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; elems[i].onclick = (function(i)&#123; return function()&#123; alert(elems[i].innerHTML); &#125;; &#125;)(i);&#125; 这样的话，闭包中“记住”的变量更小。但是有没有注意到，在循环中会多次去生成同一个匿名函数（只不过自执行时传入的参数值不同），因此可以使用函数的引用进一步优化上面的代码。 12345678910var elems = document.getElementsByTagName('div');var callback = function(i)&#123; return function()&#123; alert(elems[i].innerHTML); &#125;;&#125;;for(var i=0, len=elems.length; i&lt;len; i++)&#123; elems[i].onclick = (callback)(i);&#125; 如此，callback函数仅存有一份，在for循环中为它传入不同的参数值进行执行，它返回的函数才是真正绑到onclick上的函数。 总结我再引用一句我在上一篇中的总结 闭包就像一个壳子，把它里面的东西罩住了。闭包把它里面的free variables保护住了，使它们免受外部的污染，包括全局变量的污染，或者是循环变量终值的污染。 虽然闭包有如此多的好处，但它也不是万能的，滥用闭包必然会有副作用。闭包中存在可能的效率问题，包括对象的建立和内存管理释放等，这些都不太好控制。我们只有先将闭包用在对的场合，然后尽量减少闭包“包”住的范围，避免循环中创建匿名函数，而使用函数的引用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的闭包及使用场合]]></title>
    <url>%2Fblog%2F2015%2F03%2Fclosure-in-js.html</url>
    <content type="text"><![CDATA[对于JS中的闭包closure，官方给出的定义为：A “closure” is an expression (typically a function) that can have free variables together with an environment that binds those variables (that “closes” the expression)。 对此我的理解是：闭包是一个函数或函数表达式的执行环境；这个执行环境中会包含一些变量，只有函数内部能访问到这些变量；因此这些变量相当于被“包”住了，脱离了这个闭包，就无法访问到这些变量。 词法性质的作用域JS具有函数级的作用域，这意味着定义在函数内部的变量在函数外部不能被访问。 JS的作用域又是词法性质的（lexically scoped），这意味着函数运行在定义它的作用域中，而不是在调用它的作用域中。因此，函数执行时的变量可见性范围就是它被定义时的变量可见性范围。 闭包的创建方式创建闭包最简单最通常的方式就是：创建一个自执行函数，然后在其内部再嵌一个供外调用的函数，这样这个自执行函数就形成了一个闭包。 1234567891011var someVar = 'global';var someFunc;(function()&#123; var someVar = 'inner'; someFunc = function()&#123; alert(someVar); &#125;;&#125;)();someFunc(); 可以看到最后执行结果是“inner”，因为someFunc在自执行函数的闭包中被定义，虽然someFunc在自执行函数执行完后才被调用，但是函数执行时可访问到的变量，就是该函数被定义时函数内部可访问到的变量。因此someFunc定义时看到的someVar值是inner，就是最后执行时的结果。 使用场合减少全局变量闭包的最大作用就是变量共享，以减少全局变量的使用。举个例子 123456789101112131415var some = (function()&#123; var count = 0; var doSomething = function()&#123; for(var i=0; i&lt;100; i++)&#123; count++; &#125; &#125; return &#123; getResult: function()&#123; doSomething(); return count; &#125; &#125;&#125;)(); 最后调用some.getResult()结果当然是100。对外部来说，我们只关心最后得到的结果，而无所谓它是怎么算出来的。因此在外部，只存在一个全局变量some，我们成功的将中间变量count和过程doSomething变成了闭包内的自由变量（上述定义中的free variables），而不是全局变量。内部函数getResult能访问到外部函数的变量，因此闭包能够减少全局变量的使用。 模块化模式由上面的再往下过渡，就是JS中的模块化模式了。这是面向对象的编程思想，用来管理方法和属性的可见度。在以前封装学校选择器的时候，就写过一段面向对象的例子。 12345678910111213141516171819202122232425262728293031323334var Book = (function()&#123; // 私有静态属性 var numOfBooks = 0; // 私有静态方法 function checkIsbn(isbn)&#123; &#125; // 返回真正的构造函数 return function(newIsbn, newTitle, newAuthor)&#123; // 私有属性 var isbn, title, author; // 特权方法（每个实例都会有一个方法的备份） this.getIsbn = function()&#123; return isbn; &#125;; this.setIsbn = function(newIsbn)&#123; if(!checkIsbn(newIsbn))&#123; throw new Error('Book: ISBN无效'); &#125; isbn = newIsbn; &#125;; // 执行构造 numOfBooks++; if(numOfBooks &gt; 50)&#123; throw new Error('Book: 最多创建50个实例'); &#125; this.setIsbn(newIsbn); &#125;&#125;)(); 这里就是通过创建一个自执行函数，里面再返回一个函数，以实现类的构造函数，并将私有属性封装在内部。对外部来说，Book就是一个封装好的模块。注意，这里省略了prototype部分，具体请看这里。 偏函数应用关于偏函数的具体定义，我也不是很清楚。不过很好理解，假设有个函数定义了3个参数，那么可以先把第一个参数的值绑定到该函数中，以后调用时只需要传入后两个参数值就可以了。 12345678function say(word)&#123; return function(name)&#123; alert(word + ' ' + name); &#125;&#125;var sayHello = say('Hello');sayHello('World'); 我们想做的事是想写个say(word, name)这样的函数，可以先让say(&#39;Hello&#39;)返回一个函数，然后再传入第二个参数即可。这是偏函数的最最简单的例子。JS中支持可变参数，可以为偏函数绑定多个参数的值，也叫做curry化。更复杂的例子请看司徒先生的这篇文章。 循环引用问题这是使用闭包的最经典的场合。先来看个例子。 12345678// 假设页面中有4个divvar elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; var div = elems[i]; div.onclick = function()&#123; alert(i); &#125;;&#125; 页面中有4个div元素，我们希望为它们绑上事件，点击第一个div弹出0，点击第二个div弹出1，依此类推。很可惜，上面的代码执行后，不管点击哪个div，弹出的都是4。这是为什么呢？当for循环结束时，i的值是4，因此当div元素被点击时，onclick函数内部看到的变量i值其实就是i最终的值，即4。 使用闭包可以解决这个问题 123456789var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; (function(j)&#123; var div = elems[j]; div.onclick = function()&#123; alert(j); &#125;; &#125;)(i);&#125; 在for循环里面创建了一个自执行函数，把当前的i值传进去，即匿名函数的参数j（为了区分我这里写成了j，当然令它为i也可以）。这样就形成了一个闭包，onclick执行时看到的变量j就是匿名函数的参数j。而匿名函数是自执行的，它在for循环中已经被执行过了，因此匿名函数的参数j的值就是它被定义时传入的变量i值。 如果我把代码改成这样 123456789var elems = document.getElementsByTagName('div');for(var i=0, len=elems.length; i&lt;len; i++)&#123; (function(i)&#123; var div = elems[i]; div.onclick = function()&#123; alert(i); &#125;; &#125;)(i);&#125; 依旧不会对结果产生影响，因为匿名函数在for循环中已经被执行过了，因此onclick中看到的i始终是匿名函数被定义时的参数i值，for循环的循环变量i不会对它产生影响。 总结综上所以我感觉，闭包就像一个壳子，把它里面的东西罩住了。正如本文一开头引用的官方定义，闭包把它里面的free variables罩住了保护住了，使它们免受外部的污染，包括全局变量的污染，或者是循环变量终值的污染。因此闭包内部的函数运行时看到的变量值，就是它们被定义时看到的变量的值。 由于本篇写的是闭包的使用场合，解决循环引用问题只是其中的一种，还有更多循环引用的例子，我改天再写一篇^_^ 参考文章深入理解JavaScript系列（4）：立即调用的函数表达式 javascript的currying函数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定位模型]]></title>
    <url>%2Fblog%2F2015%2F03%2Fcss-position-model.html</url>
    <content type="text"><![CDATA[定位模型上一篇CSS盒模型中提到有六种盒模型：内联盒模型、内联块状盒模型、块状盒模型、表格盒模型、绝对定位盒模型、浮动盒模型。这里的定位模型与之类似，对不同的盒模型采用不同的定位模型去定位。 静态定位模型：对内联、内联块状、块状和表格盒模型进行定位 绝对和固定定位模型：对绝对定位盒模型进行定位 浮动定位模型：对浮动盒模型进行定位 上面这几种定位模型已经涵盖了六种盒模型了，对于一种盒模型，都能找到与之对应的定位模型。还有两种混合型的定位模型，主要是针对相对定位，因为相对定位并不改变原来的文档流。相对定位的元素还在文档流中占据着原来的位置，只不过在“显示”上相对原来的位置有所偏移，但它的相邻元素并不会因为它的相对定位而调整位置。 因此对任何非absolute、fixed定位的元素，都可以设置position: relative来混加，仅仅是在“显示”上对它们加点偏移量，并不改变它们在文档流中的实际位置。因此也就有了下面两种混合的定位模型。 相对定位模型：对除绝对定位盒模型外的任何盒模型进行相对定位 相对浮动定位模型：对浮动盒模型进行相对定位 相对定位想控制浮动元素或正常排列中的元素的堆叠顺序，问题是，z-index不能应用到浮动元素和静态定位元素。这时可以用position: relative对它采取相对定位，使用z-index设置它的堆叠顺序。 相对元素的定位并没有脱离正常元素的排列位置，也没有改变它在正常排列位置时的形状。例如，如果一个内联元素横跨多行，那么当对其进行相对定位后，它会保留这个独特的布局。而对绝对定位来说，则恰恰相反，它会把内联元素转化成一个绝对盒模型，把其中内容重新排进绝对块状盒模型，这或许会改变它的布局。 可以选择性地把相对定位元素从它的原始排列位置上进行偏移，而不会改变排列中其他元素的位置。 可以把position: relative赋给任何元素，这样，绝对定位的后代元素便可相对它来定位。 相对浮动先说浮动定位 浮动元素的定位层位于块状元素之上，与正常排列顺序中的内联内容是相邻的。 浮动不会影响块状盒模型的定位，只会影响它们的内联内容。 浮动元素不会与其他浮动元素或内联内容重叠（除非浮动元素有负的外边距）。 用position: relative对浮动元素进行相对定位，在不影响其他元素（包括其他浮动元素和内联内容）定位的前提下，把浮动元素从现有位置上偏移。相对浮动还保留了元素在原始浮动排列顺序中的位置。 相对浮动也是在定位层被解析的，可以使用z-index控制它相对于其他浮动元素和定位元素的堆叠顺序。 注：只有position relative和static是与浮动兼容的 堆叠环境 静态元素按照文档顺序从下至上进行叠放。 定位元素依照文档元素排序的不同，从后往前按照z-index从小到大的顺序进行叠放。 当z-index被设置成auto或把z-index赋给非定位元素时，是不能产生堆叠环境的。 负z-index值的定位元素放在静态元素和非定位浮动元素的下面。 z-index不是全局的，它是相对于被赋上了z-index值的定位最近的祖先元素而言的。 每种堆叠环境都是原子化的，不允许其他祖先元素或兄弟元素放置于其内的子元素中。 堆叠环境按照如下定位层从后往前进行解析： 背景颜色、图片和堆叠环境元素的边框 拥有负z-index值的后代定位元素 后代非定位块状元素 后代非定位浮动元素 后代非定位内联元素 被赋予了z-index :auto和z-index: 0的后代定位元素 有正z-index值的后代定位元素 原子化问题：浏览器把静态内联内容放在静态块状元素背景之上的一层进行解析的，当静态块状元素之间互相覆盖的时候，它们的背景也相应地覆盖了，可是内联内容却没有。因为堆叠环境首先解析的是所有的块状元素背景和边框，然后是所有浮动元素，接着才是所有的内联元素和内容。这样便把块状元素的背景和边框置于浮动元素和内联元素的下层了。 解决：定位元素就是原子化的，这意味着没有外部元素能够插在它的静态子孙元素、内联内容和背景之间。堆叠环境要求把定位元素当作不可分割的原子来解析，可用相对、绝对、固定这3种定位方式令元素原子化，被设置了overflow: scroll的块状元素也同样是原子化的。 注意：IE6有一些小bug，可通过触发hasLayout来修正，可以用IE的私有属性zoom: 1触发布局，但是zoom会令你的样式表不能通过校验。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2Fblog%2F2015%2F03%2Fcss-box-model.html</url>
    <content type="text"><![CDATA[这是CSS中的基本盒模型，内盒和外盒的概念都是一样的，而在下面六种具体盒模型的设置和显示上有所不同。 1.内联盒模型 从左到右水平排列，超过父元素宽度时便换行。 width、height和overflow在内联元素上不起作用，因为它们总是与内容的宽度和高度一致。 用margin-left、margin-right来改变内联元素在水平排列中的位置，用line-height设置行高（相当于改变竖直方向的位置，因为margin-top、margin-bottom不起作用）。 border水平的边框会改变内联元素在排列中的位置，左边框会令元素靠左，右边框使下一个元素靠右。而上下边框则会显示于内边距之外，但是没有扩展行高或改变元素在竖直方向上的位置。边框不会对行高造成影响，不过边框能覆盖掉邻近行。 padding应用到内联元素的方式与border完全相同。 2.内联块状盒模型 内联块状元素是位于内联排列顺序中的，就像其他的内联盒子一样，只不过它还包括了一些块状元素的属性：外边距、边框、内边距、宽度和高度。 width和height，设置成auto把内联块状元素包裹住，设置成100%把内联块拉长。注意，被拉长的内联块状元素与块状元素是一样的。 margin有一些独特的内联块状功能。正的margin-top会增加行高，负的则会减小行高。 border和padding能扩展内联元素的外围尺寸，会令它以及后面的内容向右偏移，也会让它变大，增加它所在行的高度。 3.块状盒模型 从上到下竖直排列。Terminal块状元素在其内盒里创建了一个内联格式化环境，但是它的外盒此时一定是处于块状格式化环境下。 块状元素的宽高可与它的父元素一致，也可以小于或大于它的父元素，当它的尺寸大于父元素的时候，就会溢出来。 width默认值是auto，它使元素的宽度与父元素一致。 height默认值是auto，它使元素的高度包裹住它的所有子元素。 margin-left和margin-right会调整块状元素已设置的尺寸，会让内盒变小。 margin-top和margin-bottom，浏览器会抵消相邻块状元素的顶部和底部外边距。 用margin-left: auto和margin-right: auto控制已固定了尺寸的块状元素的水平排列。设置width和margin-right: auto会令块状元素排列在其父元素的左侧；margin-left: auto会在右侧；同时设置则会居中。 border和padding会扩展盒模型的外宽和外高。对被拉长了的块状元素来说，水平边框和内边距会改变内盒的大小。而对于固定尺寸的块状元素来说，它们会调整外盒。 4.表格盒模型 表格是一个含有很多行单元格的块状盒模型。表格也位于块状元素的排列中，而表格中的单元格则按“行”和“列”来排列。 表格有外边距，没有内边距。单元格有内边距，没有外边距。 width和height，这是表格边框外围的宽高，而不像其他盒模型是内盒的宽高。 不能把overflow应用于表格，因为表格是不能溢出的。只有表格的单元格能溢出。 border-collapse决定了邻近的边框是否合并为一个。 table-layout决定了表格是固定大小（fixed）还是依据其内容而变动（auto）。 5.绝对定位盒模型 绝对定位元素从正常的元素排列顺序中脱离了，把它置于更高的一层或更低的一层。 它是相对于最近的定位祖先（relative或absolute的祖先，都没有的话直到html根元素）来定位，或者固定于视窗的某个位置。 不像其他的盒模型，绝对定位盒模型的位置不会影响其他盒模型的位置。 z-index控制定位元素的叠放顺序。 left、right、top和bottom都设置为auto（默认值）时，则绝对定位盒模型的位置与它原先在排列顺序中的位置一致。 width默认值为auto。 当width是auto并且left和right也是auto时，盒模型就是被包裹的。 当width是auto并且left和right是0或其他什么值的时候，盒模型会被拉伸。 当width有一个值，left有一个值且right是auto时，盒模型就被固定了尺寸并从左侧偏离。 当width有一个值，right有一个值且left是auto时，盒模型也是固定大小的，并从右侧偏离。 height、top和bottom的运作方式与width、left和right类似。 margin为正时，会令绝对定位的盒模型移向它的容器中心。当它为负时，则会远离中心。 border和padding会缩小已拉伸的绝对定位盒模型的内盒。border和padding会扩展已设定尺寸的盒子的外盒，并把绝对定位盒模型包裹住，将其移向容器的中心。 6.浮动盒模型 浮动元素也脱离了正常的元素排列顺序，被置于邻近块状元素的边框和背景之上。这会缩小浮动元素的父元素，当所有子元素都浮动的时候，父元素的范围便完全消失了。 即使浮动元素脱离了原本元素的排列队伍，它会令队伍中邻近的内容朝某个方向缩进。左浮动会令邻近的内容向右缩进。 浮动元素是在原本的竖直方向上依次排列的，当浮动元素不能紧邻它的下一个浮动元素的时候，它会挪到下方。 浮动元素的位置、大小、内边距、边框和外边距都会影响邻近浮动元素和邻近内联内容的位置。浮动元素的精确位置是不能事先定义的。 width默认值是auto，会令它的宽度与其最长的行一致。 height默认值是auto，会包裹住整个浮动元素，使它的高度与其子元素的总高度相一致。 浮动元素的外边距是不会互相抵消的。 border和padding增大了浮动元素的外盒尺寸。 注意，float具有破坏性，会让元素呈现出inline-block的一些性质，即使该元素原来是inline的。 总结width和heightwidth: auto 水平包裹以下几种盒模型：内联、内联块状、浮动、表格，和绝对定位（当left和right都设置为auto时）。 水平拉伸块状，和绝对定位盒模型（当left和right都设置了一个值，例如0）。 width: 100% 会把元素的宽度设置为其父元素的宽度，但是不像auto，width: 100%拥有一些限制，浏览器不会自动调整宽度以保持元素被拉伸。 元素的水平外边距、边框或者内边距能够扩展它的宽度，甚至可超越父元素的宽度。 height: auto 竖直包裹以下几种盒模型：内联、内联块状、块状、浮动、表格和绝对定位（当top和bottom都设置为auto时）。 竖直拉伸绝对定位盒模型（仅当top和bottom都设置了一个值，例如0）。这是竖直拉伸盒模型的最好方法，因为height: 100%会有一些局限性。 height: 100% 会把元素的高度设置成与父元素一样，其他与width: 100%类似。 参考精通CSS与HTML设计模式]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写的jquery分页插件]]></title>
    <url>%2Fblog%2F2015%2F03%2Fstep-by-step-jquery-plugin-pagination-1.html</url>
    <content type="text"><![CDATA[经常做信息管理类的网站，分页可以说是最常见的功能之一了。纵然网上可以找到一堆jquery分页插件，但我还是想手把手自己写一个分页，更清楚自己需要怎样的分页功能，不想包含过于复杂的功能。说到分页，我能想到3种：直接刷新页面；Ajax刷新分页；伪分页。伪分页其实就是对页面数据的过滤，页面包含了所有的数据的元素，只不过“一页”仅显示部分数据的元素。Ajax分页则是局部刷新页面上的数据元素。我先实现最简单的分页方式，即直接刷新页面。 jquery插件写法jquery中提供了fn扩展属性，任何写到fn中的函数，都可以被jquery DOM元素直接调用。 12345$.fn.sayHello = function()&#123; return this.each(function()&#123; alert(this); &#125;);&#125;; 有了这个扩展函数，可以直接对元素这样$(&#39;#someElement&#39;).sayHello()调用，也可以同时作用在多个元素上，像$(&#39;.some-class&#39;).sayHello()这样。 注意sayHello中两个this是有区别的，函数进来的第一个this就是指调用sayHello()的元素，而且这里的this就已经是jquery的元素了，不需要再多此一举$(this)了。而this.each()表示对所有调用sayHello()的元素均进行如下操作。each(function(){})里面的this表示的是单个调用sayHello()的元素，注意这里的this是原生DOM元素，如要使用jquery的函数，则需要先$(this)一下。 完善后的sayHello代码如下。 1234567$.fn.sayHello = function()&#123; return this.each(function()&#123; $(this).bind('click', function()&#123; alert('hello ' + $(this).prop('tagName')); &#125;); &#125;);&#125;; 即这个sayHello插件会为元素绑定一个click事件，点击后会弹出该元素的标签名。效果如下。 分页插件设计令这个分页插件（扩展函数）叫做jqPagination，我们希望它使用起来非常简单，在页面中只需要定义一个&lt;div&gt;，无需定义任何子元素，只需要jqPagination()一下，就会生成一个好看的分页按钮出来。由于页数是不确定的，不可能把所有页码在界面上都显示出来（体验太差），它只显示第一页、最后一页，以及当前页的前后两页。 可以看到，它有点类似一个“滑动窗口”，窗口大小是5（当前页和前后2页），未显示的页码用“…”显示。 由于在页面中只定义一个&lt;div&gt;，那么当前的页码和总页数 要么写在&lt;div&gt;的自定义属性中 要么当作参数传给jqPagination 这就是这个分页插件的对外接口设计。&lt;div&gt;中支持data-pn和data-tpn两个属性，分别表示当前页码和总页数。 1&lt;div id="pagination1" data-pn="5" data-tpn="12"&gt;&lt;/div&gt; 同时jqPagination也支持配置参数，如下。 1234$('#pagination1').jqPagination(&#123; pn: 5, tpn: 12&#125;); 插件实现大体实现思路就是： 为&lt;div&gt;添加一些子元素，不涉及具体页码。 生成带“滑动窗口”的具体页码，并为页码添加是否active的样式。 为每个页码添加链接，即点击该页则直接刷新页面。 为“前一页”和“后一页”绑定点击事件。 Step 1 1234567891011121314151617181920212223242526272829$.fn.jqPagination = function(options)&#123; var generatePages = function($el)&#123; var $list = $('&lt;ul class="' + CLASS_PAGE_LIST + '"&gt;&lt;/ul&gt;'); // prePage $list.append('&lt;li class="' + CLASS_DISABLED + '"&gt;&lt;a href="javascript:void(0);" class="' + CLASS_PRE_PAGE + '"&gt;' + TEXT_PRE_PAGE + '&lt;/a&gt;&lt;/li&gt;'); // firstPage $list.append('&lt;li class="' + CLASS_ACTIVE + '"&gt;&lt;a href="javascript:void(0);" class="' + CLASS_PAGE + '" data-page="1"&gt;1&lt;/a&gt;&lt;/li&gt;'); // preOmit $list.append('&lt;li class="' + CLASS_DISABLED + '"&gt;&lt;a href="javascript:void(0);" class="' + CLASS_PRE_OMIT + '"&gt;' + TEXT_OMIT + '&lt;/a&gt;&lt;/li&gt;'); // nextOmit $list.append('&lt;li class="' + CLASS_DISABLED + '"&gt;&lt;a href="javascript:void(0);" class="' + CLASS_NEXT_OMIT + '"&gt;' + TEXT_OMIT + '&lt;/a&gt;&lt;/li&gt;'); // lastPage $list.append('&lt;li class=""&gt;&lt;a href="javascript:void(0);" class="' + CLASS_PAGE + '" data-page=""&gt;' + TEXT_EMPTY + '&lt;/a&gt;&lt;/li&gt;'); // nextPage $list.append('&lt;li class="' + CLASS_DISABLED + '"&gt;&lt;a href="javascript:void(0);" class="' + CLASS_NEXT_PAGE + '"&gt;' + TEXT_NEXT_PAGE + '&lt;/a&gt;&lt;/li&gt;'); // append to list $el.empty().append($list); &#125;; var init = function($el)&#123; $el.addClass(CLASS_PAGINATION); generatePages($el); &#125;; return init(this);&#125;; 这里直接为几个特殊的元素占好“坑”，分别是：上一页，第1页，滑动窗口向前的省略，滑动窗口向后的省略，最后一页（页码为空），下一页。具体的页码元素都是有data-page属性的，这里第一页和最后一页也属于具体页码。然后在Step 2中生成其他具体页码，并为这里占的“坑”设置active、disabled或hide。 Step 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var generatePages = function($el)&#123; // 以上省略... var $dummies = $list.children('li'); var dummyLen = $dummies.length; // targets reference var $firstPage = $dummies.eq(1); var $lastPage = $dummies.eq(dummyLen-2); var $prePage = $dummies.first(); // eq(0) var $nextPage = $dummies.last(); // eq(dummyLen-1) var $preOmitted = $dummies.eq(2); var $nextOmitted = $dummies.eq(dummyLen-3); // a copy for dynamic page, initial var $pageCopy = $firstPage.clone().removeAttr('class'); // page number region var pn = Number(opts.pn); var tpn = Number(opts.tpn); var lowerPn = Math.max(pn-2, 2); // 第1页已写在html中 var upperPn = Math.min(pn+2, tpn-1); // 最后1页已写在html中 // generate new specific pages（当前页的前后2页） for(var i=lowerPn; i&lt;=upperPn; i++)&#123; var $newPage = $pageCopy.clone(); $newPage.find('a').attr('data-page', i).text(i); $newPage.insertBefore($nextOmitted); // add current page flag i == pn &amp;&amp; $newPage.addClass(CLASS_ACTIVE); &#125; // check first page $firstPage.removeClass(CLASS_ACTIVE); pn == 1 &amp;&amp; $firstPage.addClass(CLASS_ACTIVE); // check last page $lastPage.find('a').attr('data-page', tpn).text(tpn); $lastPage.removeClass(CLASS_ACTIVE); pn == tpn &amp;&amp; $lastPage.addClass(CLASS_ACTIVE); // check if last page equals first page $lastPage.removeClass(CLASS_HIDE) tpn == 1 &amp;&amp; $lastPage.addClass(CLASS_HIDE); // check Previous page $prePage.attr('class', CLASS_DISABLED); pn &gt; 1 &amp;&amp; $prePage.removeClass(CLASS_DISABLED); // check Next page $nextPage.attr('class', CLASS_DISABLED); pn &lt; tpn &amp;&amp; $nextPage.removeClass(CLASS_DISABLED); // check pre omitted $preOmitted.removeClass(CLASS_HIDE); lowerPn &lt;= 2 &amp;&amp; $preOmitted.addClass(CLASS_HIDE); // check next omitted $nextOmitted.removeClass(CLASS_HIDE); upperPn == tpn-1 &amp;&amp; $nextOmitted.addClass(CLASS_HIDE);&#125;; 这里的滑动窗口的页码范围为Math.max(pn-2, 2)到Math.min(pn+2, tpn-1)，因为第1页和最后1页已经在Step 1中占好“坑”了。生成的具体页码即当前页的前后2页，添加好data-page属性，插入到“坑”的相应位置。然后就是根据pn（当前页码）和tpn（总页数）对那些“坑”进行可见性的检查，该disabled的和该hide的。 Step 3 &amp; 4 1234567891011121314151617181920212223242526272829303132333435363738var bindPageEvents = function($el)&#123; // Previous page $el.find('.' + CLASS_PRE_PAGE).click(function()&#123; if($(this).parent().hasClass(CLASS_DISABLED))&#123; return false; &#125; var $target = $el.find('li.' + CLASS_ACTIVE).prev(); // omitted patch if($target.hasClass(CLASS_DISABLED))&#123; $target = $target.prev(); if($target.hasClass(CLASS_DISABLED))&#123; $target = $target.prev(); &#125; &#125; targetClick($target); &#125;); // Next page $el.find('.' + CLASS_NEXT_PAGE).click(function()&#123; if($(this).parent().hasClass(CLASS_DISABLED))&#123; return false; &#125; var $target = $el.find('li.' + CLASS_ACTIVE).next(); // omitted patch if($target.hasClass(CLASS_DISABLED))&#123; $target = $target.next(); if($target.hasClass(CLASS_DISABLED))&#123; $target = $target.next(); &#125; &#125; targetClick($target); &#125;); // specific pages $el.find('a.' + CLASS_PAGE).each(function()&#123; $(this).attr('href', getPageHref($(this).attr('data-page'))); &#125;);&#125;; 这里就是为具体页码和“前一页”“后一页”添加点击效果。每个具体页码都是个带有href属性的&lt;a&gt;标签，以直接刷新页面，这里有个getPageHref方法稍后描述。而点击“前一页”“后一页”实则是去找到相对于当前页的具体页码元素，然后调用targetClick去模拟点击，也在稍后描述。 配置参数除了前面提到的pn和tpn两个参数外，我们还需要添加两个参数。因为是直接刷新页面以获取新的分页数据，那url中肯定要有个参数表示页码，那么这个参数的key叫什么。我们提供一个默认的名字，就叫page，即url都长成这样/some/to/?page=2，当然这个参数的名字也可以自定义。还有就是，分页刷新页面默认就是当前的url，只不过page参数的值不同，这个url也可以自定义。 123456789101112131415161718192021$.fn.jqPagination = function(options)&#123; // default option values var opts = $.extend(&#123; 'pn': this.attr('data-pn') || 1, 'tpn': this.attr('data-tpn') || 1, 'name': 'page' &#125;, options); // default value of 'pageHref' var defaultHref = window.location.pathname + '?' + opts.name + '='; if(/\?(\w+)=/.test(window.location.href))&#123; // 如果已经有参数 defaultHref = window.location.href + (eval('/' + opts.name + '=/').test(window.location.href) ? '' : '&amp;' + opts.name + '='); &#125; opts['pageHref'] = opts['pageHref'] || defaultHref; // 以下省略...&#125;; 由此，前面提到的getPageHref就是去替换url里的page参数的值。 123var getPageHref = function(pageNo)&#123; return opts.pageHref.replace(eval('/' + opts.name + '=\\d*/'), opts.name + '=' + pageNo);&#125;; 当然那个模拟点击页码的targetClick就是直接刷新window.location.href咯 12345678910var targetClick = function($li)&#123; var $link = $li.find('a.' + CLASS_PAGE); if(!$link.hasClass(CLASS_ACTIVE) &amp;&amp; !$link.hasClass(CLASS_DISABLED) &amp;&amp; !$link.hasClass(CLASS_HIDE))&#123; // 是否刷页面 /^\/|((http|https|svn|ftp|file):\/\/)/.test($link.prop('href')) ? (window.location.href = $link.prop('href')) : $link.click(); &#125;&#125;; 插件使用提供3种使用方式，最基本的就是 12345&lt;div id="pagination1" data-pn="5" data-tpn="12"&gt;&lt;/div&gt;&lt;script&gt;$('#pagination1').jqPagination();&lt;/script&gt; 要手动设置pn和tpn，以及分页参数名称，就像这样 12345$('#pagination2').jqPagination(&#123; pn: 5, tpn: 12, name: 'p'&#125;); 要自定义分页url的就像这样 123$('#pagination3').jqPagination(&#123; pageHref: 'http://www.baidu.com?from=fuxiaode.cn&amp;page='&#125;); 完整Demo]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ消息记录转码]]></title>
    <url>%2Fblog%2F2015%2F02%2Fqq-history-message-converter.html</url>
    <content type="text"><![CDATA[和妹子一起有段时间了，期间经历了她电脑重装，我手机崩溃N次，因此现在的情况是我电脑上有我们QQ上的所有聊天记录，而她微信也有我们所有的记录。问题是我看不到她的所有微信记录，她看不到我的所有QQ记录 &gt;_&lt; 我先想着QQ，试着能不能把我这边的数据导出来后再让她导入，以失败告终。我就想着能把我导出的聊天记录，转成网页的格式，方便她看。 QQ消息记录QQ自带的消息管理器中就提供了“导出”功能。 导出的文件支持以下3种类型。 其中只有*.bak类型的文件才能导入，但是只能自己导入自己的，我导出的文件给她后她是无法导入的，因为文件是加密过的，还有消息的sender/receiver也不一样，一直报错，只好弃了。 而*.txt文件简单是简单，缺少表情和图片，跟看手机小说似的 =_= *.mht文件格式 可以看到它其实是在HTML格式上加了一些其它信息，文件的头部就是这样的，以后每一条消息就是一个&lt;tr&gt;。所有消息的最后是&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;结尾。文件中的HTML部分只占一小部分，在&lt;/html&gt;结束后又追加了一大片表情和图片的编码信息。 其中都采用了base64编码，而HTML中的img src都指向这里的{xxxx}.dat 于是思路就很清晰了 先把base64编码的表情图片解码出来，并生成相应的文件 把*.mht文件中非HTML的部分去掉 把img src重新替换 解码图片我使用的是Java，查了下只需要importsun.misc.BASE64Decoder即可。在eclipse中可能无法识别这个包，只需要在Build Path中把JRE Library删了再重新添加一下就OK了。 然后base64的解码就很简单了 123456789101112131415161718192021222324private boolean decodeImage(String imgStr, String imgFile)&#123; if(imgStr == null)&#123; return false; &#125; BASE64Decoder decoder = new BASE64Decoder(); try &#123; // base64解码 byte[] b = decoder.decodeBuffer(imgStr); // 生成图片 OutputStream out = new FileOutputStream(imgFile); out.write(b); out.flush(); out.close(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; 有了这个，我们就要对*.mht文件进行第一遍扫描，对每个图片编码的地方都调用该decodeImage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void generateImages()&#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(rawFileRoot + rawFileName + "." + rawFileExt)); skipRawHead(br); String temp; while((temp = br.readLine()) != null)&#123; //读到image //Content-Type:image/gif if(temp.startsWith("Content-Type:"))&#123; String fileExt = temp.split("/")[1]; //Content-Transfer-Encoding:base64 temp = br.readLine(); //Content-Location:&#123;2E66FE72-A0EE-4982-A5E1-A7FD3F564743&#125;.dat temp = br.readLine(); String fileName = temp.substring(18, temp.length() - 5); String fileNameDat = temp.substring(17); //空行 temp = br.readLine(); //读image的base64数据 StringBuilder builder = new StringBuilder(); while((temp = br.readLine()).length() != 0)&#123; builder.append(temp); &#125; //image转码(.dat) decodeImage(builder.toString(), outImageRoot + fileNameDat); //image转码(.ext) decodeImage(builder.toString(), outImageRoot + fileName + "." + fileExt); //完成 System.out.println("Image: " + fileNameDat); &#125; &#125; br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这里我们就是去判断那些特殊的行，读出图片的文件类型和文件名，然后把base64编码成的字符串读到buffer中，最后调用decodeImage。注意这里调用了两次，一次是生成*.dat文件，方便HTML中img src替换，不需要管图片是jpg还是gif了。而第二次调用是生成原始的图片文件，包含图片扩展名，是为了收藏 ^_^ 生成HTML如果仅是把*.mht文件中非HTML的部分去掉，那么只要把读到的有效行写入新的文件即可。但是导出的*.mht文件通常要上百兆，如果聊天记录多的话，最后生成的HTML都在一个文件里，扔到浏览器中肯定会卡。因此至少把聊天记录按照“年-月”切分出来。 在原始文件中，可以看到聊天“日期”是像这样子存在的。 因此我们用.*日期: (\d{4}-\d{2}-\d{2})&lt;/td&gt;&lt;/tr&gt;.*这样一个正则就能识别出。唯独加好友后的第一条消息的日期是跟&lt;html&gt;&lt;head&gt;同一行的。 我们每次读到一个新的“年-月”时，就结束前一个输出文件，另起一个输出文件，把上面的&lt;html&gt;&lt;head&gt;信息先写到新的输出文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void generateHTML()&#123; try &#123; System.out.println("Generating output html..."); BufferedReader br = new BufferedReader(new FileReader(rawFileRoot + rawFileName + "." + rawFileExt)); BufferedWriter bw = null; skipRawHead(br); String temp; //日期正则 Pattern pattern = Pattern.compile(".*日期: (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&lt;/td&gt;&lt;/tr&gt;.*"); Matcher matcher; // 当前的yyyy-MM，对所有记录按照年月汇总 String current = null; // 每个html文件的头部（除第一次读到的日期） String htmlHead = null; while((temp = br.readLine()) != null)&#123; if(htmlHead == null)&#123; htmlHead = temp.replaceFirst("&lt;tr&gt;.*&gt;日期: (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&lt;/td&gt;&lt;/tr&gt;.*", ""); &#125; //判断日期 matcher = pattern.matcher(temp); if(matcher.matches())&#123; String date = matcher.group(1); date = date.substring(0, date.lastIndexOf("-")); if(!date.equals(current))&#123; current = date; System.out.println(current); if(bw != null)&#123; bw.write("&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;"); bw.flush(); bw.close(); &#125; //另起一文件（按年月） bw = new BufferedWriter(new FileWriter(outHTMLRoot + rawFileName + "-" + current + "." + outFileExt)); bw.write(htmlHead); bw.newLine(); bw.flush(); &#125; &#125; //替换源文件中的img src（加个目录） temp = temp.replaceAll("&lt;IMG src=\"", "&lt;IMG src=\"src/"); bw.write(temp); bw.newLine(); bw.flush(); //标准html结束 if(temp.endsWith("&lt;/html&gt;"))&#123; break; &#125; &#125; br.close(); bw.close(); System.out.println("Done."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 注意这里有个skipRawHead(br)是为了跳过*.mht头部的几行，直接从&lt;html&gt;开始读，一行一行读，一行就是一条消息。 最后生成后的结果，src文件夹中就存放着所有解码出来的表情图片以及图片的*.dat文件。 后续把聊天记录打包发给了妹子，我能想到最浪漫的事，就是在那一天的时候和你一起躲在房间里看聊天记录，回想当初如何相识相知，和一路走来的点点滴滴。 记录/记忆有喜当然也有悲，生活就是这样，看你觉得哪个更重要。 献上源代码]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>小玩意</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(7)]]></title>
    <url>%2Fblog%2F2015%2F02%2Fstep-by-step-js-component-schoolbox-7.html</url>
    <content type="text"><![CDATA[本来这个系列主题已经结束了，突然想到还有个功能要做，就是“模态”，即把学校选择器做成一个类似模态的对话框。这样就可以应付这样的使用场景：在一个学生列表的页面中，可以修改任意学生的所在学校，也可以添加其他学校的学生。 模态对话框经常看到“模态”这个词，特地百度了一下它的定义： 模态对话框（Modal Dialogue Box，又叫做模式对话框），是指在用户想要对对话框以外的应用程序进行操作时，必须首先对该对话框进行响应。如单击【确定】或【取消】按钮等将该对话框关闭。 再看看Bootstrap v2提供的模态对话框 可以看到其实没什么，就是页面背景加一块遮罩（mask），然后添加一个对话框的关闭按钮，告诉用户一定要先对该对话框进行操作。 添加模态首先从SchoolBox的对外接口出发，原来我们构造SchoolBox对象时会传入一个appendTo参数，意思是把这个对象追到到哪个元素中去。现在我们不用传appendTo了，就可以表示这是个模态框，不需要追加到哪个具体元素。 1.我们要做的就是在SchoolBox对外的show和hide方法做相应的改变。 1234567891011121314151617181920show: function()&#123; if(this.opts.popup)&#123; $('body').append('&lt;div class="school-box-mask"&gt;&lt;/div&gt;'); $(this.opts.appendTo).find('.school-box-wrapper') .removeClass('school-box-hide').addClass('school-box-popup'); &#125; else&#123; $(this.opts.appendTo).find('.school-box-wrapper').slideDown(); &#125;&#125;,hide: function()&#123; if(this.opts.popup)&#123; $('.school-box-mask').remove(); $(this.opts.appendTo).find('.school-box-wrapper') .removeClass('school-box-popup').addClass('school-box-hide'); &#125; else&#123; $(this.opts.appendTo).find('.school-box-wrapper').slideUp(); &#125;&#125; 这里注意，当用户不传入appendTo时，构造函数中会给它个默认值就是body，即上面代码中的$(this.opts.appendTo)就是$(&#39;body&#39;)。 2.在初始化时添加模态框的窗口栏和关闭按钮。 12345678910111213141516171819202122var $popupCloseCopy = $('&lt;div class="school-box-popup-close"&gt;&lt;a href="javascript:void(0)" title="关闭"&gt;X&lt;/a&gt;&lt;/div&gt;');var init = function(instance)&#123; // 生成元素 var $parent = $(instance.opts.appendTo); var $el = $('&lt;div class="school-box-wrapper"&gt;&lt;/div&gt;'); $el.append($schoolBoxCopy.clone()); $parent.append($el); // popup关闭 if(instance.opts.popup)&#123; var $popup = $popupCloseCopy.clone(); $el.prepend($popup); $popup.find('a').click(function()&#123; instance.hide(); &#125;); &#125; // 以下省略...&#125;; 3.为模态框和遮罩添加相应的样式。 1234567891011121314151617181920212223242526272829303132333435363738.school-box-mask&#123; background-color: #666; height: 100%; left: 0; opacity: 0.3; position: absolute; top: 0; width: 100%; z-index: 99;&#125;.school-box-popup&#123; margin-left: -25%; left: 50%; position: fixed; top: 120px; z-index: 100;&#125;.school-box-popup-close&#123; background-color: #444; height: 24px; opacity: 0.8; padding: 2px 6px;&#125;.school-box-popup-close a&#123; float: right; font-family: Arial; font-size: 20px; font-weight: bold; line-height: 24px; color: #ddd; text-decoration: none;&#125;.school-box-popup-close a:hover&#123; color: #fff;&#125;.school-box-hide&#123; display: none;&#125; 4.【patch】在真正的构造函数中添加appendTo的默认值，并添加this.opts.popup。在prototype的init中如果是popup，先隐藏school-box-wrapper，因为它直接append到body最后。 对象共享到这里我们已经实现了模态的SchoolBox，但是还有个问题，因为SchoolBox的构造开销不小，我们不希望在页面中每个有“学校”的地方都为之创建一个SchoolBox对象，我们希望同一个页面中能共用同一个SchoolBox对象。 因为我们之前已经使用了观察者模式，页面中的元素去监听自定义事件，然而“学校选定”这件事只触发一个事件。因此如果页面中有多个元素都监听着schoolChosen事件，那么当由一个元素打开的学校选择器操作完成后，所有监听着该事件的其他元素都会做出相应的改变。即在一个学生列表的页面中，我改变一个学生的学校，其他学生的学校也会跟着改变。 因此要实现共用一个对象，我们得在每次使用它时，清空它的监听者列表，并重新赋予它该次使用时唯一的回调函数。这样就可以实现操作一个学生的学校，只响应一个元素。 1234SchoolBox.prototype.unbind = function(type)&#123; this.handlers[type] = []; return this;&#125;; 完整应用多个需要使用学校的元素 1234567891011121314151617&lt;div id="formResult"&gt; &lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="text" class="school-input" readonly/&gt; &lt;input type="text" class="school-id" readonly&gt; &lt;a href="javascript:void(0)" class="choose-school"&gt;选择学校&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 共用一个SchoolBox对象，为页面元素绑定事件。 123456789101112$('.choose-school').click(function()&#123; var $schoolInput = $(this).siblings('.school-input'); var $schoolId = $(this).siblings('.school-id'); // 监听自定义事件 schoolBox.unbind('schoolChosen').on('schoolChosen', function(data)&#123; $schoolInput.val(data.schoolName); $schoolId.val(data.schoolId); &#125;); schoolBox.show();&#125;); 学校选择器v8 Demo]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(系列)]]></title>
    <url>%2Fblog%2F2015%2F02%2Fstep-by-step-js-component-schoolbox-collections.html</url>
    <content type="text"><![CDATA[前一段时间整理完了SchoolBox这个系列的代码和文章，这里再做个合集，方便大家找到相应的篇目。我总共整理了10个版本（后来补充了3个版本）的代码和8篇（后来新增了2篇）文章，分别如下。 版本1只是简单的界面设计，静态排版，没有js部分。 Demo：demo v1 文章：穿插在第一篇中 版本2加入了js部分，实现了省和学校的级联。 Demo：demo v2 文章：一步步做组件-学校选择器(1) 版本3把版本2的js代码写成组件的结构。 Demo：demo v3 文章：一步步做组件-学校选择器(2) 版本4添加自定义事件，即使用观察者模式。 Demo：demo v4 文章：一步步做组件-学校选择器(3) 版本5加入学校搜索框的功能，使用的是本地数据，也可以Ajax请求。 Demo：demo v5 文章：一步步做组件-学校选择器(4) 版本6为搜索结果添加按键效果，即通过“上”“下”键选中，“回车”键确定。 Demo：demo v6 文章：一步步做组件-学校选择器(5) 版本7附加功能，添加自定义学校。 Demo：demo v7 文章：一步步做组件-学校选择器(6) 版本8（后增）实现学校选择器的模态对话框，并在页面中共用同一个选择器对象。 Demo：demo v8 文章：一步步做组件-学校选择器(7) 版本9 &amp; 10（补充）页面上多个元素共享同一个模态对话框，在触发事件时加入“由哪个监听元素触发”，以避免对所有监听元素都做出响应。 监听时判断，Demo：demo v9 回调时判断，Demo：demo v10 文章：一步步做组件-学校选择器(8) 最后谢谢大家~~]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用RequireJS包装AjaxChart]]></title>
    <url>%2Fblog%2F2015%2F02%2Fwrap-ajaxchart-with-requirejs.html</url>
    <content type="text"><![CDATA[前面我写到AjaxChart，写到SchoolBox，我都在用javascript模拟“类”，提供一些接口让对象使用起来更加方便。javascript中的prototype和闭包、回调等等机制，可以完全用来实现“类”的封装。然而随着“类”规模的不断庞大，类中需要的依赖越来越复杂，如何有效的管理依赖关系也就成了一个问题。而RequireJS就是用来模拟“package”的，以管理“包”中的依赖。 问题由来在上一篇写AjaxChart，它只是在Highcharts做了层包装，所以依赖于Highcharts，而Highcharts又依赖于jQuery，因此html引入的&lt;script&gt;会像这样。 123456&lt;script type="text/javascript" src="http://cdn.staticfile.org/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.staticfile.org/highcharts/4.0.4/highcharts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="AjaxChart.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // main程序&lt;/script&gt; js的引入顺序一定要按照这个顺序，最后才是main程序。当程序越来越复杂时，它就需要更多的依赖，而依赖的对象本身之间可能又存在着依赖，这样到一定程度后依赖关系就会变得很头疼。 RequireJSRequireJS是继jQuery以来前端界发生的最大成就之一，用于客户端的模块管理，它是符合AMD规范（Asynchronous Module Definition）的。而关于为何要采用AMD规范来写代码，可以看这篇Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony。RequireJS的基本思想就是，通过define方法，将代码定义为模块，而通过require方法，实现代码的模块加载。 调整代码结构1. requirejs配置由于要依赖jQuery和Highcharts，我们先配置好。 12345678910111213requirejs.config(&#123; baseUrl: 'js/lib', paths: &#123; jquery: 'http://cdn.staticfile.org/jquery/1.7.2/jquery.min', highcharts: 'http://cdn.staticfile.org/highcharts/4.0.4/highcharts' &#125;, shim: &#123; highcharts: &#123; deps: ['jquery'], exports: 'Highcharts' &#125; &#125;&#125;); 这里jquery和highcharts均采用的是CDN上的，由于highcharts不是用define写的，所以要加一条shim来做转化。 2. 定义AjaxChart模块12345define(['jquery', 'highcharts'], function($, Highcharts)&#123; // 以上省略... return AjaxChart;&#125;); AjaxChart依赖于jquery和highcharts，最后返回AjaxChart对象。注意这里的文件名也要是AjaxChart.js。 3. 执行main程序123requirejs(['jquery', 'highcharts', 'AjaxChart'], function($, Highcharts, AjaxChart)&#123; // 省略...&#125;); 把这段程序放在main.js中，最后在页面中引入&lt;script type=&quot;text/javascript&quot; src=&quot;js/require.js&quot; data-main=&quot;js/app/main.js&quot;&gt;&lt;/script&gt;即可。 附上目录结构 1234567- demo.html- js/ - require.js - lib/ - AjaxChart.js - app/ - main.js 最后demo AjaxChart with RequireJS Demo]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Highcharts做包装]]></title>
    <url>%2Fblog%2F2015%2F02%2Fajax-chart-for-highcharts.html</url>
    <content type="text"><![CDATA[Highcharts是一个用纯JavaScript编写的一个图表库，能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用（摘自百度百科）。另外HighCharts还有很好的兼容性，能够完美支持当前大多数浏览器，现在官方的最新版本为Highcharts-4.0.4。 问题来源我在很早一篇使用PhantomJs对网页截图中就提到了Highcharts，那时用它在网页上绘制图表，然后用Phantomjs去截图，因为我想让服务端只负责生成数据，而让客户端去生成图表及图片。在那个项目中，所有的图表都是通过Ajax取来数据后，再调用Highcharts生成图表的。而常用的图表类型也无非那几种，每次都要先Ajax请求，然后构造highcharts的一堆配置参数。 1234567891011121314151617$.post( 'someAjaxUrl', &#123; param1: 'value1' &#125;, function(data)&#123; $('#container').highcharts(&#123; chart: &#123; type: 'line' &#125;, title: null, xAxis: &#123; ... &#125;, yAxis: &#123; ... &#125;, tooltip: &#123; ... &#125;, legend: &#123; ... &#125;, series: data &#125;); &#125;); 因为服务端只返回series里要求的数据格式，尽量与highcharts的配置降低耦合，所以前台每次想要生成一个图表都要写一段上面类似的代码。因此我觉得有必要对highcharts做简单的包装，让它更加简单的配合Ajax和chart type。 接口设计我们希望可以这样使用chart 12345678910111213var chart1 = new AjaxChart(&#123; container: '#chartDemo1', chartType: 'line'， ajaxUrl: 'someAjaxUrl', ajaxParams: &#123; param1: 'value1', param2: function()&#123; return 'value2'; &#125; &#125;&#125;);chart1.refresh(); 传入图表的container元素和chart type，传入ajax url和params，且这里的params既可以是个值，也可以是个function。最后通过refresh()接口生成图表。这样可以把chart1.refresh()放到某个按钮的click或change事件里，以实现根据用户的选择动态刷新图表。 全局配置针对几种常用的图表类型，折线图、饼图、柱状图、区域图，我们分别为此定义默认的Highcharts配置属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485var CHART_OPTIONS = &#123; // 全局Highcharts配置 global: &#123; title: null, xAxis: &#123; // NOTE: 这里假设每个series的数据项都一样，因此取第一个series来作为分类即可。 categories: function()&#123; var categories = []; // 用data数组生成categories if(series[0].data[0] instanceof Array)&#123; $.each(series[0].data, function(k, v)&#123; categories.push(v[0]); &#125;); &#125; return categories; &#125; &#125;, tooltip: &#123; pointFormat: '&lt;span style="color:&#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &#123;point.y&#125;' &#125;, legend: &#123; enabled: false &#125;, yAxis: &#123; title: &#123; enabled: false &#125; &#125; &#125;, // 折线图配置项 line: &#123; chart: &#123; type: 'line' &#125;, plotOptions: &#123; line: &#123; dataLabels: &#123; enabled: true &#125; &#125; &#125; &#125;, // 饼图配置项 pie: &#123; chart: &#123; type:'pie' &#125;, tooltip: &#123; pointFormat: '&lt;span style="color:&#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &#123;point.percentage:, .1f&#125;%' &#125; &#125;, // 柱形图配置项 column: &#123; chart: &#123; type:'column' &#125;, plotOptions: &#123; column: &#123; dataLabels: &#123; enabled: true &#125; &#125;, series: &#123; groupPadding: 0, pointPadding: 0 &#125; &#125; &#125;, // 区域图 area: &#123; chart: &#123; type:'area' &#125;, plotOptions: &#123; area: &#123; marker: &#123; enabled: false, symbol: 'circle', radius: 2, states: &#123; hover: &#123; enabled: true &#125; &#125; &#125; &#125; &#125; &#125;&#125;; AjaxChart构造根据上面的接口设计，我们可以写出这样的代码框架。 123456789101112var AjaxChart = function(config)&#123; this._container = config.container; this._chartType = config.chartType; this._url = config.ajaxUrl; this._params = config.ajaxParams;&#125;;AjaxChart.prototype = &#123; refresh: function()&#123; &#125;&#125;; refresh负责获取用户传入的参数，并请求Ajax，返回时再构造出Highcharts对象。这里我们需要写两个帮助方法。 1.获取用户参数 既然我们前面说“params既可以是个值，也可以是个function”，因此要写一个转化的过程，如果是function，则对function求值。 1234567AjaxChart.prototype._getAjaxParams = function()&#123; var result = &#123;&#125;; for(key in this._params)&#123; result[key] = (typeof this._params[key] == 'function') ? (this._params[key])() : this._params[key]; &#125; return result;&#125;; 2.构造图表 这里根据前面的全局配置来构造Highcharts对象，参数result是服务端返回的数据（即Highcharts配置里的series）。 1234567891011121314151617181920212223242526272829303132AjaxChart.prototype._updateChart = function(result)&#123; if('series' in result == false)&#123; return false; &#125; // 选择图类型 var chartOptions = $.extend(&#123;&#125;, CHART_OPTIONS['global'], CHART_OPTIONS[this._chartType]); // 选择容器（这里要原生DOM对象） chartOptions.chart.renderTo = $(this._container)[0]; // 载入数据项 chartOptions.series = result['series']; // 如果是多个series的，显示legend（图示） chartOptions.legend.enabled = chartOptions.series.length &gt; 1 ? true : false; // 处理xAxis categories if('categories' in result)&#123; if(chartOptions.xAxis instanceof Array)&#123; for (var i = chartOptions.xAxis.length - 1; i &gt;= 0; i--) &#123; chartOptions.xAxis[i].categories = result['categories']; &#125;; &#125; else&#123; chartOptions.xAxis.categories = result['categories']; &#125; &#125; // 生成Highcharts对象 var chart = new Highcharts.Chart(chartOptions);&#125;; 3.有了上面两个方法，refresh就好办了。 12345678910111213AjaxChart.prototype.refresh = function()&#123; var params = this._getAjaxParams(); var that = this; $.post( this._url, params, function(json)&#123; var result = $.parseJSON(json); that._updateChart(result); &#125; );&#125;; 注意这里有句var that = this;，熟悉回调的朋友肯定对此不陌生，这是为了保存当前的context，因为在Ajax的回调函数执行时，this会指向xmlhttpresponse，而不是当前的AjaxChart对象。 扩展1：支持本地数据刷新使用场景：当一个表格已经请求好了数据，并放在table元素中了。此时图表元素需要做的就是根据表格中的数据生成chart，而并不需要再次向服务器请求数据。 我们为上面的refresh方法添加一个参数。 12345678910111213141516171819202122232425262728AjaxChart.prototype.refresh = function(chartData)&#123; // ajax更新 if(typeof chartData === 'undefined' &amp;&amp; this._url)&#123; var params = this._getAjaxParams(); var that = this; $.post( this._url, params, function(json)&#123; var result; if(typeof json === 'string')&#123; result = $.parseJSON(json); &#125; if(typeof json === 'object')&#123; result = json; &#125; if(typeof result !== 'undefined')&#123; that._updateChart(result); &#125; &#125; ); &#125; // 非ajax更新 else&#123; this._updateChart(chartData); &#125;&#125;; 这里chartData就是Highcharts配置里series的格式，这样可以在本地生成符合格式的数据，然后直接refresh。chartData的格式可以参考ajaxdata.json或ajaxdata2.json。并且这里对ajax返回结果也做了一些判断，以支持JSON字符串或JSON对象。 扩展2：支持图表点击事件使用场景：在柱状图或饼图中，经常需要点击一块时，能够得到相应的联动。比如在图上点击了一块，相应的表格数据过滤了，或是另一个图表也随之更新了等等。 还得为refresh方法添加参数，干脆添加一个对象参数。 1234567891011121314151617181920212223AjaxChart.prototype.refresh = function(opts)&#123; var chartData = opts &amp;&amp; opts.chartData; var clickHandler = opts &amp;&amp; opts.clickHandler; // ajax更新 if(typeof chartData === 'undefined' &amp;&amp; this._url)&#123; var params = this._getAjaxParams(); var that = this; $.post( this._url, params, function(json)&#123; var result = $.parseJSON(json); that._updateChart(result, clickHandler); &#125; ); &#125; // 非ajax更新 else&#123; this._updateChart(chartData, clickHandler); &#125;&#125;; 同时_updateChart方法也得再添加一个参数。 123456789101112131415161718192021AjaxChart.prototype._updateChart = function(result, handler)&#123; // 以上省略... // 处理events if(typeof handler === 'function')&#123; chartOptions.plotOptions = $.extend(&#123;&#125;, chartOptions.plotOptions, &#123; series: &#123; cursor: 'pointer', events: &#123; click: function(evt)&#123; var xLabel = evt.point.name || evt.point.category; handler(xLabel, evt.point.y); &#125; &#125; &#125; &#125;); &#125; // 生成Highcharts对象 var chart = new Highcharts.Chart(chartOptions);&#125;; 这里的handler中可以获取到两个参数，一个是x坐标的分类值，一个是y坐标的值。应用层里可以这样写。 12345chart1.refresh(&#123; clickHandler: function(xLabel, y)&#123; alert(xLabel + ': ' + y); &#125;&#125;); 扩展3：支持自定义回调使用场景：跟上面的点击事件差不多，只是这里在图表更新完成后，需要通知某些元素做出相应的处理。 代码也跟上面差不多，再为refresh方法添加个参数。 1234567891011121314151617181920212223242526AjaxChart.prototype.refresh = function(opts)&#123; var chartData = opts &amp;&amp; opts.chartData; var clickHandler = opts &amp;&amp; opts.clickHandler; var afterUpdate = opts &amp;&amp; opts.afterUpdate; // ajax更新 if(typeof chartData === 'undefined' &amp;&amp; this._url)&#123; var params = this._getAjaxParams(); var that = this; $.post( this._url, params, function(json)&#123; var result = $.parseJSON(json); that._updateChart(result, clickHandler); afterUpdate &amp;&amp; afterUpdate(); &#125; ); &#125; // 非ajax更新 else&#123; this._updateChart(chartData, clickHandler); afterUpdate &amp;&amp; afterUpdate(); &#125;&#125;; 如果需要支持更多的自定义事件，最好使用观察者模式，为AjaxChart.prototype添加一个on和fire方法，并在对象中维持一个handlers对象。这里就不给出代码了，可参考链接中的内容很容易写出类似的代码。 最后demo AjaxChart Demo 参考资料Highcharts官方网站：www.highcharts.com 中文网：www.hcharts.cn]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>chart</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA泛型DAO]]></title>
    <url>%2Fblog%2F2015%2F02%2Fgeneric-dao-for-jpa.html</url>
    <content type="text"><![CDATA[JPA全称Java Persistence API。JPA通过JDK 5.0注解或XML描述对象关系表的映射关系，并将运行期的实体对象持久化到数据库中（摘自百度百科）。本篇结合自己的项目经历，使用的框架是Play Framework 1.2.7，其JPA底层采用的是Hibernate 3.6的实现，来讲述基于JPA构建一个泛型DAO（Data Access Object）。 背景知识关于JPA就不多做介绍了，如果用过Hibernate或Spring，就会对JPA一目了然。可以点击这里看看JPA概要。我之前也写过一篇介绍在eclipse中集成Hibernate的文章中也提到了DAO泛型编程。 问题来源项目中有好多实体，比如说老师、学生，还有考试，那么就有对应的DAO叫TeacherDao、StudentDao和ExamDao。虽然JPA对实体提供了方便的find查询，但是还得在TeacherDao里写个比如findTeachersBySchool，在StudentDao里写个比如findStudentsByTeacher，或者在ExamDao里写个findExamsByTeacherAndStudent等等的方法，而其方法内部通过JPA为实体附加的find查询来实现。现在的问题是在不同实体对应的DAO类里存在着一堆看起来相似的方法（只是find里的参数和方法的返回值不同），这就是典型的应该使用泛型的场景。 泛型DAO1.我们首先要建一个叫GenericDao的抽象类 12345678public abstract class GenericDao&lt;T, PK extends Serializable&gt; &#123; private Class&lt;T&gt; clazz; public GenericDao()&#123; // 反射获取T.class，实参类型 clazz = (Class&lt;T&gt;)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]; &#125;&#125; T代表实体类型，PK代表主键类型。 2.实体对应的DAO类去继承GenericDao 123public class ExamDao extends GenericDao&lt;Exam, Long&gt; &#123;&#125; 这里Exam是实体类型，Long是主键类型。 3.业务层使用DAO时创建具体DAO的实例 1ExamDao examDao = new ExamDao(); 我们系统中所有的DAO都按照这样的规范来写： a) 可以采用统一实现的方法都写在GenericDao中 b) 具体DAO中实现各不相同的方法，在GenericDao定义抽象方法，并在各自的DAO类中实现 c) 具体DAO中特有的方法就写在自己的DAO类里 统一实现的query1234567891011121314151617181920212223242526public T findById(PK id)&#123; return (T) JPA.em().find(clazz, id);&#125;public List&lt;T&gt; findAll()&#123; return (List&lt;T&gt;) JPA.em().createQuery("select e from " + clazz.getName() + " e").getResultList();&#125;public void save(T instance)&#123; JPA.em().persist(instance);&#125;public void saveList(List&lt;T&gt; instances)&#123; EntityManager manager = JPA.em(); for (T instance : instances)&#123; manager.persist(instance); &#125;&#125;public void refresh(T instance)&#123; JPA.em().refresh(instance);&#125;public void delete(PK id)&#123; JPA.em().createQuery("delete from " + clazz.getName() + " e where e.id=" + id).executeUpdate();&#125; 这是拍脑袋首先想出来的一些方法，最最简单的增删改查，肯定每个实体的DAO中都要用到。大致看看好像没有问题，但是细思极恐，因为一般系统中用的最多的是按条件且带分页的查询，甚至还带排序，简单一个findAll真是图样图森破。 1.首先我们要实现一个带分页带排序项的findAll方法。 123public List&lt;T&gt; findAll(int pageNo, String orderBy, String order)&#123; return find(getHQLString(null, null, orderBy, order), new Object[]&#123;&#125;, pageNo);&#125; 这里的find内部利用Java反射，调用了JPA为具体实体类附加的查询方法。 12345678910111213141516protected List&lt;T&gt; find(String query, Object[] params, Integer pageNo)&#123; try &#123; Method method = clazz.getMethod("find", new Class[]&#123;String.class, Object[].class&#125;); JPAQuery queryObj = (JPAQuery) method.invoke(clazz, new Object[]&#123;query, params&#125;); if(pageNo != null)&#123; return queryObj.fetch(pageNo, Constants.PAGE_SIZE); &#125; else&#123; return queryObj.fetch(); &#125; &#125; catch (Exception e) &#123; return new ArrayList&lt;T&gt;(); &#125;&#125; 这里的pageNo是Integer类型，为null时代表不分页。而query是我们手工拼成的一个HQL query，下面来看看这个方法。 1234567891011121314151617private String getHQLString(String[] columns, String[] signs, String orderBy, String order)&#123; StringBuilder builder = new StringBuilder(); if(columns != null &amp;&amp; columns.length &gt; 0)&#123; for(int i=0; i&lt;columns.length; i++)&#123; builder.append(columns[i] + " " + signs[i] + " ?"); if(i &lt; columns.length - 1)&#123; builder.append(" and "); &#125; &#125; &#125; if(orderBy != null)&#123; builder.append(" order by " + orderBy + " " + order); &#125; return builder.toString();&#125; 这里columns表示查询需要比较的字段，而signs表示比较时的符号（小于、等于、大于等等）。最后返回的HQL形如columnX = ? and columnY &lt; ? orderBy columnZ desc。最后将这个HQL传给find，配上实际的参数值（即“?”的填充值），再调用JPA提供的find来fetch出相应的结果，以完成分页查询。这个查询过程就如此，注意这里我们将“页”的大小存到了一个常量中。 2.为signs和order定义一些常量，以及帮助方法。 123456789101112131415public static final String SIGN_EQUALS = "=";public static final String SIGN_LESS_THAN = "&lt;";public static final String SIGN_GREATER_THAN = "&gt;";public static final String SIGN_LESS_EQUALS_THAN = "&lt;=";public static final String SIGN_GREATER_EQUALS_THAN ="&gt;=";public static final String ORDER_ASC = "asc";public static final String ORDER_DESC = "desc";private String[] getDefaultSigns(int length)&#123; String[] signs = new String[length]; for(int i=0; i&lt;length; i++)&#123; signs[i] = SIGN_EQUALS; &#125; return signs;&#125; 3.有了以上的基础，我们可以顺势写出好多findBy方法出来。 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;T&gt; findBy(String[] columns, Object[] values, String[] signs, int pageNo, String orderBy, String order)&#123; return find(getHQLString(columns, signs, orderBy, order), values, pageNo);&#125;public List&lt;T&gt; findBy(String[] columns, Object[] values, String[] signs, int pageNo)&#123; return find(getHQLString(columns, signs, null, null), values, pageNo);&#125;public List&lt;T&gt; findBy(String[] columns, Object[] values, int pageNo, String orderBy, String order)&#123; String[] signs = getDefaultSigns(columns.length); return find(getHQLString(columns, signs, orderBy, order), values, pageNo);&#125;public List&lt;T&gt; findBy(String[] columns, Object[] values, int pageNo)&#123; String[] signs = getDefaultSigns(columns.length); return find(getHQLString(columns, signs, null, null), values, pageNo);&#125;public List&lt;T&gt; findBy(String column, Object value, int pageNo, String orderBy, String order)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_EQUALS&#125;, orderBy, order), new Object[]&#123;value&#125;, pageNo);&#125;public List&lt;T&gt; findBy(String column, Object value, int pageNo)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_EQUALS&#125;, null, null), new Object[]&#123;value&#125;, pageNo);&#125;public List&lt;T&gt; findLessThan(String column, Object value, int pageNo, String orderBy, String order)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_LESS_THAN&#125;, orderBy, order), new Object[]&#123;value&#125;, pageNo);&#125;public List&lt;T&gt; findLessThan(String column, Object value, int pageNo)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_LESS_THAN&#125;, null, null), new Object[]&#123;value&#125;, pageNo);&#125;public List&lt;T&gt; findGreaterThan(String column, Object value, int pageNo, String orderBy, String order)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_GREATER_THAN&#125;, orderBy, order), new Object[]&#123;value&#125;, pageNo);&#125;public List&lt;T&gt; findGreaterThan(String column, Object value, int pageNo)&#123; return find(getHQLString(new String[]&#123;column&#125;, new String[]&#123;SIGN_GREATER_THAN&#125;, null, null), new Object[]&#123;value&#125;, pageNo);&#125; 4.同理，我们还可以写出findIn方法。 1234567891011121314151617181920212223242526272829private String getInHQLString(String column, int inLength, String orderBy, String order)&#123; StringBuilder builder = new StringBuilder(column); if(inLength &gt; 0)&#123; builder.append(" in ("); for(int i=0; i&lt;inLength; i++)&#123; builder.append("?"); if(i &lt; inLength - 1)&#123; builder.append(","); &#125; &#125; builder.append(")"); &#125; if(orderBy != null)&#123; builder.append(" order by " + orderBy + " " + order); &#125; return builder.toString();&#125;public List&lt;T&gt; findIn(String column, Object[] values, int pageNo, String orderBy, String order)&#123; return find(getInHQLString(column, values.length, orderBy, order), values, pageNo);&#125;public List&lt;T&gt; findIn(String column, Object[] values, int pageNo)&#123; return find(getInHQLString(column, values.length, null, null), values, pageNo);&#125; 当然我们还能写出findIn和findBy混合的方法，即部分字段用符号比较，而部分字段用in比较。还可以写一堆count方法，我们这里就不再罗列了。 总结泛型编程是减少代码冗余的利器，尤其是在DAO层面的泛型，可以将HQL或SQL语句都封装到一个类中，外部使用时只需调用方法和传参即可，降低了程序员写SQL出错的可能性。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>泛型编程</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(6)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-6.html</url>
    <content type="text"><![CDATA[前面一连5篇下来，学校选择器已经有模有样了。这篇算是狗尾续貂了，如果在选择器中搜不到想要的学校该怎么办？我们再添加一个辅助功能，就是添加自定义学校。 界面设计继续前面的设计风格，在学校选择器的底部添加如下一行。 同时在搜索结果列表的底部，当无匹配结果时，也添加如下一行。 扩展组件功能1.在私有静态变量里添加元素copy 123456789var $addSchoolCopy = $( '&lt;div class="add-school-wrapper"&gt;' + '&lt;a href="javascript:void(0)" class="add-school-link"&gt;没找到？添加学校&lt;/a&gt;' + '&lt;div class="inline-block hide add-school-div"&gt;' + '&lt;input type="text" class="add-school-input"/&gt;' + '&lt;input type="button" class="add-school-ok" value="确定"/&gt;' + '&lt;input type="button" class="add-school-cancel" value="取消"/&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'); 2.初始化新的元素 123456789var initAddSchool = function(instance)&#123; // 生成元素 var $el = $(instance.opts.appendTo).find('.school-box-wrapper'); $el.append($addSchoolCopy.clone()); $el.find('.search-school-empty').append('&lt;a href="javascript:void(0)" class="add-school-link"&gt;添加学校&lt;/a&gt;'); // 释放变量 $el = null;&#125;; 3.为新的目标元素绑定事件 12345678910111213141516171819202122232425262728293031323334353637// 目标元素var $addSchoolLink = $el.find('.add-school-link');var $addSchoolDiv = $el.find('.add-school-div');var $addSchoolInput = $el.find('.add-school-input');var $addSchoolOk = $el.find('.add-school-ok');var $addSchoolCancel = $el.find('.add-school-cancel');// 事件$addSchoolLink.click(function()&#123; $addSchoolDiv.removeClass('hide'); $addSchoolInput.focus();&#125;);$addSchoolCancel.click(function()&#123; $addSchoolDiv.addClass('hide');&#125;);$addSchoolOk.click(function()&#123; var schoolName = $.trim($addSchoolInput.val()); if(schoolName.length == 0)&#123; return false; &#125; // TODO: ajax添加 var newSchoolId = 'undefined'; // 自定义事件回调 instance.fire('schoolChosen', &#123; schoolName: schoolName, schoolId: newSchoolId &#125;); // 自动收起 instance.hide(); // 清空输入内容 $addSchoolInput.val(''); $addSchoolDiv.addClass('hide');&#125;); 注意$addSchoolOk的click执行里，应该用Ajax向后台发送请求，将用户输入的学校名添加到数据库中去，最后将新加学校的ID返回给页面。而上面的代码直接写死一个undefined的学校ID，这里仅做demo。最后添加成功后，依然要触发自定义schoolChosen事件，好让应用层页面做出响应。 4.应用层使用组件时添加一项初始化参数 12345var schoolBox = new SchoolBox(&#123; appendTo: '#schoolBoxWrapper', searchSchool: true, addSchool: true&#125;); 可以看到扩展组件功能时，对应用层页面代码的影响是很小的。只要不添加自定义事件的类型，应用层几乎不用改代码，因为它只关心选中的学校，并将它更新显示到页面上，而不需要关心这个学校到底是通过什么方式选来的。 学校选择器v7 Demo 总结学校选择器这个系列到这里结束了，我最初在项目里只做了这里版本v2的样子。后来又提新需求，搜索学校和找不到学校，然后就直接在v2上迭代，仅仅是表单里的一行选择，就搞了近1000行代码。后来又来新需求，说其他页面也需要编辑学校，因此我才不得不拆出来写成复用形式，一劳永逸。在这个重构的过程中，我将阶段性的每一步都做成一个版本，最后整理成了这6篇文章。既是对我自己的总结提高，同时也想告诉大家，做前端的不仅仅实现页面功能，更多地应该以工程师的角度去思考问题，让代码质量更高更易维护。 这里的学校选择器当然还不够完美，还有可以改进的地方。比如我看到别人的搜索结果列表中可以按住“下”键，它就会一直向下依次选中，还有对搜索结果的排序等等。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(5)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-5.html</url>
    <content type="text"><![CDATA[上一篇中我们简单实现了搜索框的功能，这节中要为它添加按键事件，“上”“下”键选择匹配的结果，“回车”键来进入下一步，以使它使用起来更加人性化。 键盘事件入口在搜索框keyup事件那里，针对特殊的按键做拦截（不触发搜索）。 12345678910111213141516171819202122232425262728293031var initSearchSchool = function(instance)&#123; // 以上省略... // 事件 $searchInput.bind('keyup', function(event)&#123; // 特殊按键（动作键） if(event.keyCode == KEY_ENTER)&#123; searchSchoolChosen($searchList); return preventDefault(event); &#125; if(event.keyCode == KEY_UP)&#123; searchListScrollPrev($searchDiv, $searchList); return preventDefault(event); &#125; if(event.keyCode == KEY_DOWN)&#123; searchListScrollNext($searchDiv, $searchList); return preventDefault(event); &#125; var keywords = $.trim($(this).val()); // 空格or拼音没输完时暂不search if(keywords.length == 0 || keywords.indexOf("'") &gt; -1)&#123; $searchDiv.hide(); return false; &#125; searchSchool(keywords, $searchDiv, $searchList, $searchEmpty); &#125;); // 以下省略...&#125;; 这里定义了几个按键keyCode的全局变量和一个阻止浏览器默认事件的方法，如下。 12345678910111213// Constantsvar KEY_ENTER = 13;var KEY_UP = 38;var KEY_DOWN = 40;// Utilsvar preventDefault = function(event)&#123; if(event &amp;&amp; event.preventDefault) event.preventDefault(); else window.event.returnValue = false; return false;&#125;; 这里用自己写的preventDefault是为了能够兼容不同的浏览器，event.preventDefault()是标准浏览器提供的，而window.event.returnValue = false是IE下的写法。 searchSchoolChosen是选择当前项，searchListScrollPrev是选中上一项，而searchListScrollNext是选中下一项，我们将在后面详细讲。 动画效果有了上面的代码结构，接下来要做的就是为特殊按键添加效果，这里涉及到动画，又是一个蛋疼的话题。 画了一张示意图，sDiv是父元素searchDiv，sList就是元素searchList，而target就是searchList中具体选中的那个子元素。根据这幅图，我们有： Δoffset = tarTop - sDivTop + scrollTop 其中父元素sDiv上设置了height并且overflow-y: scroll，我们可以把sDiv视作一个窗口，只要保证target始终在这个窗口高度范围内即可。即随着我们按“上”“下”键，我们要保证目标子元素在这个视窗边界之内。 scrollTop &lt;= Δoffset &lt;= scrollTop + sDiv.height 于是我们有了控制searchDiv滚动条动画的方法。 12345678910111213141516var searchListScroll = function($searchDiv, $searchList)&#123; var scrollTop = $searchDiv.scrollTop(); var viewMin = scrollTop; var viewMax = viewMin + $searchDiv.height(); var $target = $searchList.children('li.active'); var deltaOffset = $target.offset().top - $searchDiv.offset().top + scrollTop; // deltaOffset要在视窗范围里 if(deltaOffset &gt; viewMax)&#123; $searchDiv.animate(&#123;scrollTop: scrollTop + deltaOffset - viewMax&#125;, 'fast'); &#125; else if(deltaOffset &lt; viewMin)&#123; $searchDiv.animate(&#123;scrollTop: scrollTop - (viewMin - deltaOffset)&#125;, 'fast'); &#125;&#125;; 大体看上去没有问题，但是注意到当向“下”选中时，其实是Δoffset + target.height要在视窗范围内。因此我们作如下修正。 12345678var searchListScroll = function(isDown, $searchDiv, $searchList)&#123; // 以上省略... var deltaOffset = $target.offset().top - $searchDiv.offset().top + scrollTop; isDown &amp;&amp; (deltaOffset += $target.height()); // 以下省略...&#125;; 有了这个滚动条动画的方法，上面提到的searchListScrollPrev和searchListScrollNext也就信手拈来了。 123456789101112131415161718192021222324252627var searchListScrollPrev = function($searchDiv, $searchList)&#123; var $cur = $searchList.children('li.active'); $cur.removeClass &amp;&amp; $cur.removeClass('active'); if($cur.length == 0 || $cur.index() == 0)&#123; $searchList.children('li').last().addClass('active'); searchListScroll(true, $searchDiv, $searchList); &#125; else&#123; $searchList.children('li').eq($cur.index() - 1).addClass('active'); searchListScroll(false, $searchDiv, $searchList); &#125;&#125;;var searchListScrollNext = function($searchDiv, $searchList)&#123; var $cur = $searchList.children('li.active'); $cur.removeClass &amp;&amp; $cur.removeClass('active'); if($cur.length == 0 || $cur.index() == $searchList.children().length-1)&#123; $searchList.children('li').first().addClass('active'); searchListScroll(false, $searchDiv, $searchList); &#125; else&#123; $searchList.children('li').eq($cur.index() + 1).addClass('active'); searchListScroll(true, $searchDiv, $searchList); &#125;&#125;; 这两个方法就是用来响应“上”“下”键，控制searchList当前选中的子元素，为之添加class，并保证选中的元素在searchDiv的可见范围内。 注意这里代码$cur.removeClass &amp;&amp; $cur.removeClass(&#39;active&#39;);这样写是因为可能找不到$cur元素，那么$cur.removeClass就肯定是false了，就不会执行$cur.removeClass(&#39;active&#39;)了。 ~~还有一点要注意的是，$cur.index()值的范围并不是0 ~ length-1，实际上值为-1时表示找不到元素，而超过length-1时又会从头开始找，即$cur.index()等于length时其实是第一个子元素。所以这里的代码中当$cur.index() == $searchList.children().length-1时要即时为第一个元素添加class，以保证$cur.index()的值范围在0 ~ length-1中。 ~~ 锦上添花1.当通过“上”“下”键来选中时，我们已经为目标子元素添加了active的样式，那么这时如果鼠标再来捣乱该怎么办？我们只好再为鼠标添加hover效果，以抹去上下键的选中效果。 123456789101112var initSearchSchool = function(instance)&#123; // 以上省略... $searchList.find('li').live('mouseenter', function()&#123; $searchList.find('li.active').removeClass('active'); $(this).addClass('hover'); &#125;).live('mouseleave', function()&#123; $searchList.find('li.hover').removeClass('hover'); &#125;); // 以下省略...&#125;; 2.至于“回车”键的响应方法，我们用最简单的办法，相当于选中的子元素click一下。 1234var searchSchoolChosen = function($searchList)&#123; // 转向click event $searchList.children('li.active').click();&#125;; 3.我们发现当我们输入关键字搜索时，其实每按一次键都执行了一次搜索和更新元素。而大多数情况下，我们输入一个关键字需要进行多次按键，比如搜索“江苏”，其实按键依次输入了“jiangsu”和最后拼音选择汉字的数字键或空格键。我们应该对此做些优化，以减少搜索执行，若使用Ajax搜索的话，可以减少很多次网络开销。 12345678910111213var initSearchSchool = function(instance)&#123; // 以上省略... // when正常输入 initSearchSchool.currentTime = (new Date()).getTime(); // 持续快速输入时不触发搜索 if(initSearchSchool.currentTime - initSearchSchool.lastKeypressTime &gt; KEY_PRESS_INTERVAL)&#123; initSearchSchool.lastKeypressTime = initSearchSchool.currentTime; searchSchool(keywords, $searchDiv, $searchList, $searchEmpty); &#125; // 以下省略...&#125;; 这里在全局定义常量var KEY_PRESS_INTERVAL = 300;毫秒即可。虽然不能面面俱到，但是已经可以减少大部分按键情况的执行开销了。 学校选择器v6 Demo]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(4)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-4.html</url>
    <content type="text"><![CDATA[在上一篇中我们用观察者模式实现了自定义事件的功能，让应用层的事件回调更加松耦合。但是到此为止学校选择器仅仅做了基本的省份和学校的级联功能，现在我们要为它添加搜索的功能。 界面设计依旧模仿人人网的学校设计，它也有个动态搜索框，如图。 先依样画葫芦把元素和样式搞出来 123456789101112&lt;div class="search-school-wrapper"&gt; &lt;div class="inline-block"&gt;&lt;label&gt;搜索：&lt;/label&gt;&lt;/div&gt; &lt;div class="inline-block"&gt; &lt;input type="text" class="search-school-input"/&gt; &lt;div class="search-school-div"&gt; &lt;ul class="search-school-list"&gt;&lt;/ul&gt; &lt;div class="search-school-empty"&gt; &lt;span class="text-error"&gt;找不到该学校&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里的元素最后都要搬到js中去生成，先写在html里为了调样式。 123456789101112131415161718192021222324252627282930313233343536373839.search-school-wrapper&#123; float: right; font-size: 12px;&#125;.search-school-input&#123; padding: 2px 4px; width: 180px;&#125;.search-school-div&#123; background-color: #fff; border: 1px solid #C3C3C3; border-top: none; color: #005EAC; display: none; font-size: 12px; font-weight: normal; max-height: 200px; overflow-x: hidden; overflow-y: scroll; position: absolute; width: 188px;&#125;.search-school-list li&#123; cursor: pointer; height: 20px; line-height: 20px; padding-left: 5px;&#125;.search-school-list li.active,.search-school-list li.hover,.search-school-list li:hover&#123; background-color: #005EAC; color: white;&#125;.search-school-empty&#123; display: none; padding: 5px 0; text-align: center;&#125; 如何搜索我们当然首先想到发送一个Ajax请求，然后后台去数据库模糊查询，最后返回一个学校列表的数据。甚至做的更好一些的话，可以定义关键词匹配度，然后根据这个值来调整返回的学校列表的顺序。 在之前的章节中，我们将一个很大的SCHOOL_LIST变量存在了js中，包含了后台数据库中的所有学校。这里我们继续这个思路，采用的是直接在js本地搜索。 1var reg = eval('/' + keywords.split('').join('\\S*') + '/'); 这里keywords就是用户输入的text，我们用这样一个正则去匹配SCHOOL_LIST的学校名称，最后将一个列表刷新到页面元素上。 扩展组件功能1.在私有静态变量里添加元素copy 1var $searchSchoolCopy = $('...省略...即上面那段html'); 2.初始化新的元素 1234567891011121314151617var initSearchSchool = function(instance)&#123; // 生成元素 var $el = $(instance.opts.appendTo).find('.school-box-wrapper'); $el.find('.school-box-header').append($searchSchoolCopy.clone()); // 释放变量 $el = null;&#125;;var init = function(instance)&#123; // 以上省略... // 附加功能 if(instance.opts.searchSchool)&#123; initSearchSchool(instance); &#125;&#125;; 3.搜索学校的动态刷新 1234567891011121314151617181920212223242526272829303132var updateSearchList = function(schools, $searchDiv, $searchList, $searchEmpty)&#123; $searchEmpty.hide(); $searchDiv.show(); $searchList.empty(); for(var i=0; i&lt;schools.length; i++)&#123; $searchList.append('&lt;li class="school-item" data-school="' + schools[i]['id'] + '"&gt;' + schools[i]['name'] + '&lt;/li&gt;'); &#125; // no result hint if(schools.length == 0)&#123; $searchEmpty.show(); &#125;&#125;;var searchSchool = function(keywords, $searchDiv, $searchList, $searchEmpty)&#123; // 从provinces缓存里搜索 var reg = eval('/' + keywords.split('').join('\\S*') + '/'); var result = []; var schools = []; for(var key in provinces)&#123; schools = provinces[key]['school']; for(var i=0, len=schools.length; i&lt;len; i++)&#123; if(reg.test(schools[i]['name']))&#123; result.push(schools[i]); &#125; &#125; &#125; updateSearchList(result, $searchDiv, $searchList, $searchEmpty);&#125;; 这里采用与之前实现省份-学校级联功能类似的办法，由于这些方法写成了类的静态私有方法（因为我不想把它们暴露到类的外面，也不想让每个类的实例都存有该方法的备份），所以需要把具体实例涉及到的DOM元素作为参数传到这些方法中。 4.为搜索学校绑定事件 123456789101112131415161718192021222324var initSearchSchool = function(instance)&#123; // 生成元素 // 省略... // 目标元素 var $searchInput = $el.find('.search-school-input'); var $searchDiv = $el.find('.search-school-div'); var $searchList = $el.find('.search-school-list'); var $searchEmpty = $el.find('.search-school-empty'); // 事件 $searchInput.bind('keyup', function(event)&#123; var keywords = $.trim($(this).val()); // 空格or拼音没输完时暂不search if(keywords.length == 0 || keywords.indexOf("'") &gt; -1)&#123; $searchDiv.hide(); return false; &#125; searchSchool(keywords, $searchDiv, $searchList, $searchEmpty); &#125;); // 以下省略...&#125;; 5.搜索框中选定学校，触发自定义事件（给类的外部） 1234567891011121314151617181920212223var initSearchSchool = function(instance)&#123; // 以上省略... // 选定学校 $searchList.find('li').live('click', function()&#123; // 配置里定义的事件回调 if(instance.opts.schoolClickCallback)&#123; instance.opts.schoolClickCallback.apply(this, []); &#125; // 自定义事件回调 instance.fire('schoolChosen', &#123; schoolId: $(this).attr('data-school'), schoolName: $(this).text() &#125;); // 自动收起 instance.hide(); // 清空搜索内容 $searchInput.val(''); $searchDiv.hide(); &#125;); // 以下省略...&#125;; 6.应用层使用组件时添加一项初始化参数 1234var schoolBox = new SchoolBox(&#123; appendTo: '#schoolBoxWrapper', searchSchool: true&#125;); 这里通过搜索框选择的学校触发的也是schoolChosen事件，所以对应用层来说是透明的。即应用层不需要知道该事件来自省份-学校级联，还是来自学校搜索框。 学校选择器v5 Demo 精益求精虽然简单实现了搜索框的功能，其实只能算“过滤”，这个系列就要这样结束了吗？细心的同学会发现上面的demo搜索框出来的结果只能用鼠标点击，不支持键盘事件。而根据我们平时使用别人软件的习惯，经常是输入完关键字后按方向键选择匹配的项，然后直接按回车键进入下一步。我将在下一篇中来实现这个功能。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(3)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-3.html</url>
    <content type="text"><![CDATA[在上一篇中我们使用了封装的设计方法，实现了一个学校选择器的“类”，降低了页面中使用该功能的难度。但同时我们发现页面中需要的回调都得写在同一个地方，这使得随着页面功能的迭代，学校选择器的回调函数将变得越来越庞大。为了解决这个隐患，需要自定义事件，然后在页面中需要用到回调的地方改成监听事件。我们首先要了解下观察者模式。 观察者模式在之前的javascript设计模式中有一个观察者模式的例子，在那个例子中的记录了事件类型、回调函数以及回调context。这里我们对其简化，暂不考虑回调函数的context。 1.由于需要在对象外部监听/订阅事件，我们在SchoolBox的prototype中添加两个方法。 123456789101112131415161718SchoolBox.prototype = &#123; // 以上省略... on: function(type, handler)&#123; if(typeof this.handlers[type] === 'undefined')&#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function(type, data)&#123; if(this.handlers[type] instanceof Array)&#123; var handlers = this.handlers[type]; for(var i=0, len=handlers.length; i&lt;len; i++)&#123; handlers[i](data); &#125; &#125; &#125;&#125;; on是用于监听的，供对象外部（应用层）使用。而fire用于触发事件，在对象内部使用。handlers是用来存储事件类型和回调函数的一个map，它的key就是事件类型，而value是一个数组，数组里面就是监听该事件类型的所有回调函数。 2.这里的handlers需要在对象构造的时候初始化，在真正的构造函数里添加一行this.handlers = {};即可。 3.触发事件 123456789$schoolDiv.find('a').live('click', function(event)&#123; // 以上省略... // 自定义事件回调 instance.fire('schoolChosen', &#123; schoolId: $(this).attr('data-school'), schoolName: $(this).text() &#125;);&#125;); 4.应用层监听事件 12345schoolBox.on('schoolChosen', function(data)&#123; $schoolInput.val(data.schoolName); $schoolId.val(data.schoolId); $chooseBoxLink.show();&#125;); 学校选择器v4 Demo 还有吗？观察者模式也叫做自定义事件，现在SchoolBox内部可以触发各种事件，而在应用层页面各部分只需要选择监听它需要的事件即可，这样就解决了先前的schoolClickCallback过大的问题。 那么到这儿就结束了吗？在下一篇中我们会添加搜索框的功能。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(2)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-2.html</url>
    <content type="text"><![CDATA[在第一篇中我们已经实现了学校选择器的基本功能，但是当其他页面也需要同样的功能的时候，我们当然不希望大段的复制代码，我们希望能够降低js和页面的耦合，提供一种更简单的初始化和调用方式。 目标我们希望在页面上只需要定义一个父元素，然后直接new一个选择器出来即可。 123var schoolBox = new SchoolBox(&#123; appendTo: '#schoolBoxWrapper'&#125;); 并且SchoolBox只暴露一些必要的供外使用的API，如schoolBox.show()、schoolBox.hide()等。 封装设计模式为了实现“简单”的目标，我们需要先了解下“封装”。其实js提供了非常弱的语法能力，它是弱类型语言，没有class的概念，没有public和private，也没有函数重载。但另一方面，正是它的弱语法，它提供了更高的自由度，利用它本身的closure和prototype的机制，完全可以模拟出“类”和公有/私有属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Book = (function()&#123; // 私有静态属性 var numOfBooks = 0; // 私有静态方法 function checkIsbn(isbn)&#123; &#125; // 返回真正的构造函数 return function(newIsbn, newTitle, newAuthor)&#123; // 私有属性 var isbn, title, author; // 特权方法（每个实例都会有一个方法的备份） this.getIsbn = function()&#123; return isbn; &#125;; this.setIsbn = function(newIsbn)&#123; if(!checkIsbn(newIsbn))&#123; throw new Error('Book: ISBN无效'); &#125; isbn = newIsbn; &#125;; // 执行构造 numOfBooks++; if(numOfBooks &gt; 50)&#123; throw new Error('Book: 最多创建50个实例'); &#125; this.setIsbn(newIsbn); &#125;&#125;)();// 公有静态方法（类的静态方法）Book.convertToTitleCase = function(inputString)&#123;&#125;;// 公有非特权方法（每个实例的方法都指向同一个备份）Book.prototype = &#123; display: function()&#123; &#125;&#125;; 特权方法能够访问私有属性和方法，但是必须声明在this中。任何不需要直接访问私有属性的方法都可以在prototype中声明。prototype中的方法可以通过访问特权方法来间接访问私有属性。只有那些需要直接访问私有成员的方法才应该被设计为特权方法，但是每个对象实例都会包含所有特权方法的新副本，容易占内存。 SchoolBox重构根据上面的封装模式，我们先搭出SchoolBox的框子。 12345678910111213141516171819202122232425262728293031323334353637(function($)&#123; var SchoolBox = (function()&#123; // 元素copy // 省略... // 缓存 var provinces = SCHOOL_LIST; // 私有静态方法 // 省略... // 真正的构造函数 return function(options)&#123; // 初始化特权属性 // 初始化生成 // 省略... &#125;; &#125;)(); SchoolBox.prototype = &#123; init: function()&#123; &#125;, show: function()&#123; &#125;, hide: function()&#123; &#125; &#125;; // export window.SchoolBox = SchoolBox;&#125;)(jQuery); 1.将目标元素和元素copy定义成私有静态属性 123456789101112var $schoolBoxCopy = $( '&lt;div class="school-box"&gt;' + '&lt;div class="school-box-header"&gt;选择学校&lt;/div&gt;' + '&lt;div class="school-box-provinces"&gt;&lt;/div&gt;' + '&lt;div class="school-box-schools"&gt;&lt;/div&gt;' + '&lt;/div&gt;');var $provinceCopy = $('&lt;a href="javascript:void(0)" class="province-item"&gt;&lt;/a&gt;');var $schoolCopy = $('&lt;a href="javascript:void(0)" class="school-item"&gt;&lt;/a&gt;');// 非实例化缓存var provinces = SCHOOL_LIST; 2.将初始化province和school定义成私有静态方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var getProvinceById = function(pid)&#123; for(var i=0; i&lt;provinces.length; i++)&#123; // NOTE: 前置条件province id可以转成数字 if(Number(provinces[i]['id']) == Number(pid))&#123; return provinces[i]; &#125; &#125; return undefined;&#125;;var initProvinces = function($provinceDiv)&#123; for(var i=0; i&lt;provinces.length; i++)&#123; var province = provinces[i]; var $province = $provinceCopy.clone(); $province.attr('data-province', province['id']) .text(province['name']); $provinceDiv.append($province); &#125;&#125;;var initSchools = function($schoolDiv, provinceId)&#123; var province = getProvinceById(provinceId); if(typeof province !== 'undefined')&#123; var schools = province['school']; $schoolDiv.empty(); for(var i=0; i&lt;schools.length; i++)&#123; var school = schools[i]; var $school = $schoolCopy.clone(); $school.attr('data-school', school['id']) .text(school['name']); $schoolDiv.append($school); &#125; &#125; return false;&#125;;var onProvinceClick = function($provinceDiv, $schoolDiv, cache)&#123; cache.lastProvinceIndex = $(this).index(); var pid = $(this).attr('data-province'); if(cache.curProvince != pid)&#123; // set chosen $provinceDiv.find('a[data-province="' + cache.curProvince + '"]').removeClass('chosen'); $provinceDiv.find('a[data-province="' + pid + '"]').addClass('chosen'); // update cache.curProvince = pid; initSchools($schoolDiv, pid); &#125; // 滚动条置顶 $schoolDiv.scrollTop(0);&#125;; 注意这里与先前不一样的是，需要操作元素的方法中得把目标元素作为参数传进去，而实例化的缓存（当前选中的province）也需要作为对象指针传入。 3.初始化方法及构造函数 12345678910111213141516171819202122232425262728293031323334353637383940414243var init = function(instance)&#123; // 生成元素 var $parent = $(instance.opts.appendTo); var $el = $('&lt;div class="school-box-wrapper"&gt;&lt;/div&gt;'); $el.append($schoolBoxCopy.clone()); $parent.append($el); // 初始化学校 // NOTE: 这里不能用$el来find（否则live click将失效） var $provinceDiv = $parent.find('.school-box-provinces'); var $schoolDiv = $parent.find('.school-box-schools'); initProvinces($provinceDiv); // 事件 $provinceDiv.find('a').click(function(event)&#123; onProvinceClick.apply(this, [$provinceDiv, $schoolDiv, instance.cache]); &#125;); // 释放变量 // NOTE: $provinceDiv和$schoolDiv不能释放，在事件中还用到 $schoolBox = null; $parent = null; $el = null;&#125;;// 真正的构造函数return function(options)&#123; // 默认配置 this.opts = $.extend(&#123; appendTo: 'body' &#125;, options); // 实例化的缓存 this.cache = &#123; curProvince: -1, lastProvinceIndex: 0 //最后一次点击的index，用于初始化选中 &#125;; // 初始化生成 init(this);&#125;; 4.在prototype中添加对外API 12345678SchoolBox.prototype = &#123; show: function()&#123; $(this.opts.appendTo).find('.school-box-wrapper').slideDown(); &#125;, hide: function()&#123; $(this.opts.appendTo).find('.school-box-wrapper').slideUp(); &#125;&#125;; 5.添加学校click事件的外部回调，将这个回调放在构造函数的options中 1234567891011121314var init = function(instance)&#123; // 以上省略... $schoolDiv.find('a').live('click', function(event)&#123; // 配置里定义的事件回调 if(instance.opts.schoolClickCallback)&#123; instance.opts.schoolClickCallback.apply(this, []); &#125; // 自动收起 instance.hide(); &#125;); // 以下省略...&#125;; 6.点缀下，初始化SchoolBox时默认选中第一个province，并对外提供init方法 12345678910111213141516var SchoolBox = (function()&#123; // 以上省略... // 真正的构造函数 return function(options)&#123; // 以上省略... // 初始化生成 init(this); this.init(); &#125;;&#125;)();SchoolBox.prototype.init = function()&#123; $(this.opts.appendTo).find('.school-box-provinces').find('a').first().click();&#125;; 7.应用层调用 12345678910111213141516171819202122// 目标元素var $schoolInput = $('#schoolInput');var $schoolId = $('#schoolId');var $chooseBoxLink = $('#openSchoolBoxLink');// 实例化对象var schoolBox = new SchoolBox(&#123; appendTo: '#schoolBoxWrapper', schoolClickCallback: function()&#123; // NOTE: 这里被调用时this指向事件触发的元素 $schoolInput.val($(this).text()); $schoolId.val($(this).attr('data-school')); // 动画 $chooseBoxLink.show(); &#125;&#125;);// bind event$chooseBoxLink.click(function()&#123; schoolBox.show(); $(this).hide();&#125;); 学校选择器v3 Demo 到此为止？到这里我们已经将学校选择器的基本功能封装成了一个“类”，具体页面使用时，只需要定义它被包裹的父元素，可以直接new一个对象出来，并在构造时的配置变量里定义事件回调。虽然大体上实现了本文一开始的目标，但是仅仅实现了基本的级联功能，而且只能定义一个事件回调。如果页面有多个元素都需要根据选中的学校进行一些改变，那么这些代码都得写在schoolClickCallback中，这部分代码可能操作着来自页面不同部分的元素（甚至是其他组件），这样就会造成一些耦合。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步做组件-学校选择器(1)]]></title>
    <url>%2Fblog%2F2015%2F01%2Fstep-by-step-js-component-schoolbox-1.html</url>
    <content type="text"><![CDATA[开篇这学期来一直在忙项目，整整一个学期都在做，自己的看书计划也没能实施。不过还是有不少收获的，是对以前看过的 JS Patterns 系列的综合运用，所以光看是不够的，一定要能应用到实际的业务中，并根据具体业务相应调整。趁着现在这段时间，想把以前写过的代码重新review一遍，并抽出可复用的功能把它们改写成通用组件，既是自己总结和提升的机会，也把它们作为以后的代码积累。 最近这个项目是做在线编程教育的，既然是教育，当然会跟学校挂钩，所以注册的时候就涉及到学校选择。我就从这里入手，讲述下如何一步步做成学校选择器的js组件。 界面设计由于本人设计能力拙劣，所以偷懒直接参考了人人网里的学校选择器的画风。 我们这里只做了国内的高校，比人人网少一层，先从简，定义了下面的元素。 123456789101112&lt;div class="school-box-wrapper"&gt; &lt;div class="school-box"&gt; &lt;div class="school-box-header"&gt;选择学校&lt;/div&gt; &lt;div class="school-box-provinces"&gt; &lt;a href="javascript:void(0)" class="province-item" data-province="1"&gt;江苏&lt;/a&gt; &lt;/div&gt; &lt;div class="school-box-schools"&gt; &lt;a href="javascript:void(0)" class="school-item" data-school="10284"&gt;南京大学&lt;/a&gt; &lt;a href="javascript:void(0)" class="school-item" data-school="10286"&gt;东南大学&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们通过自定义属性data-xxx来存储ID，这里的学校ID采用的是教育部标准的学校代码，而省份ID无实际含义。参照上面的图，写出了以下样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.school-box-wrapper&#123; margin: 10px 0;&#125;.school-box&#123; background-color: white; border: 1px solid #005EAC; width: 650px;&#125;.school-box-header&#123; background: #3777BC; color: white; font-size: 14px; font-weight: bold; padding: 5px 10px;&#125;.school-box-provinces,.school-box-schools&#123; border: 1px solid #C3C3C3; margin: 5px 10px 10px 10px;&#125;.school-box-schools&#123; height: 200px; overflow-x: hidden; overflow-y: auto;&#125;.school-box-provinces a,.school-box-schools a&#123; color: #005EAC; cursor: pointer; display: inline-block; font-size: 12px; height: 18px; line-height: 18px; text-decoration: none;&#125;.school-box-provinces a&#123; margin: 2px 5px; padding: 1px;&#125;.school-box-provinces a:hover&#123; text-decoration: underline;&#125;.school-box-provinces a.chosen&#123; background-color: #005EAC; color: white;&#125;.school-box-schools a&#123; margin: 4px 12px; overflow: hidden; padding-left: 10px; width: 160px;&#125;.school-box-schools a:hover&#123; background-color: #005EAC; color: white;&#125; 大体效果如图，依样画葫芦还凑合吧。 学校选择器v1 Demo 学校数据存储上面的demo中学校是hard code到元素中的，但实际上不可能这样做。我们需要定义school的数据格式。 123456789101112[ &#123; "id": 1, "name": "北京", "school": [ &#123; "id": 10001, "name": "北京大学" &#125; ] &#125;] 于是我们将抓来的所有学校数据生成一个JSON对象放在全局中。学校列表.js 省份-学校 级联首先定义目标元素，province和school区域的父元素，以及province和school元素的copy（省得动态生成元素时写HTML了）。 12345var $provinceDiv = $('.school-box-provinces');var $schoolDiv = $('.school-box-schools');var $provinceCopy = $('&lt;a href="javascript:void(0)" class="province-item"&gt;&lt;/a&gt;');var $schoolCopy = $('&lt;a href="javascript:void(0)" class="school-item"&gt;&lt;/a&gt;'); 其次，要定义变量将当前选中的province存起来，我们再定义一个变量指向全局的SCHOOL_LIST。 12var provinces = SCHOOL_LIST;var curProvince = -1; //province id 1.开始写初始化province区域的代码。 123456789var initProvinces = function()&#123; for(var i=0; i&lt;provinces.length; i++)&#123; var province = provinces[i]; var $province = $provinceCopy.clone(); $province.attr('data-province', province['id']) .text(province['name']); $provinceDiv.append($province); &#125;&#125;; 2.初始化学校，当然要根据传入的provinceId。 1234567891011121314151617181920212223242526var getProvinceById = function(pid)&#123; for(var i=0; i&lt;provinces.length; i++)&#123; // NOTE: 前置条件province id可以转成数字 if(Number(provinces[i]['id']) == Number(pid))&#123; return provinces[i]; &#125; &#125; return undefined;&#125;;var initSchools = function(provinceId)&#123; var province = getProvinceById(provinceId); if(typeof province !== 'undefined')&#123; var schools = province['school']; $schoolDiv.empty(); for(var i=0; i&lt;schools.length; i++)&#123; var school = schools[i]; var $school = $schoolCopy.clone(); $school.attr('data-school', school['id']) .text(school['name']); $schoolDiv.append($school); &#125; &#125; return false;&#125;; 3.为province绑定click事件，这样就能级联起来。 123456789101112var onProvinceClick = function()&#123; var pid = $(this).attr('data-province'); if(curProvince != pid)&#123; // set chosen $provinceDiv.find('a[data-province="' + curProvince + '"]').removeClass('chosen'); $provinceDiv.find('a[data-province="' + pid + '"]').addClass('chosen'); // update curProvince = pid; initSchools(pid); &#125;&#125;; 4.同样为school添加click，还需要定义两个表单里的元素。 1234567var $schoolInput = $('#schoolInput');var $schoolId = $('#schoolId');var onSchoolClick = function()&#123; $schoolInput.val($(this).text()); $schoolId.val($(this).attr('data-school'));&#125;; 5.添加动画以及统一初始化方法 1234567891011121314151617181920212223var $schoolBox = $('.school-box-wrapper');var $schoolBoxLink = $('#openSchoolBoxLink');var hideSchoolBox = function()&#123; $schoolBox.slideUp(); $schoolBoxLink.show();&#125;;var showSchoolBox = function()&#123; $schoolBox.slideDown(); $schoolBoxLink.hide();&#125;;var init = function()&#123; initProvinces(); // bind events $provinceDiv.find('a').click(onProvinceClick); // 由于school元素是动态改变的，这里一定要通过live去绑定 $schoolDiv.find('a').live('click', onSchoolClick); $schoolBoxLink.click(showSchoolBox); // execute showSchoolBox();&#125;; 6.最后为了避免变量作用域的污染，我们定义一个自执行函数，去包裹以上所有js代码。 123456(function()&#123; // 以上省略... // 执行初始化 return init();&#125;)(); 7.添加下点缀，让它每次showSchoolBox时都能自定选中前一次选择的province。 1234567891011121314151617var lastProvinceIndex = 0; //最后一次点击的index，用于初始化选中var onProvinceClick = function()&#123; lastProvinceIndex = $(this).index(); // 中间省略... // 滚动条置顶 $schoolDiv.scrollTop(0);&#125;;var showSchoolBox = function()&#123; // 以上省略... // 默认选中最后一次点击的province $provinceDiv.find('a').eq(lastProvinceIndex).click();&#125;; 学校选择器v2 Demo 还有吗？到这里一个简单的demo完成了，但是js代码和当前页面的HTML元素耦合很大，如果改了HTML则js也要相应的改。那么问题来了，如果在另一个页面也需要这样的学校选择器该怎么办呢？复制大段代码吗？]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之七-浏览器模式]]></title>
    <url>%2Fblog%2F2014%2F12%2Fjs-pattern-part7-browser-pattern.html</url>
    <content type="text"><![CDATA[关注分离HTML、CSS、JS相互独立，不要使用内联处理器（onclick之类）和内联样式属性（style属性），因为这些都不属于内容层。js应该是用来加强网页功能，而不能称为网页正常工作的必需组件。 不要使用用户代理来嗅探代码路径，而应该在运行环境中检查是否有所需的属性或方法。 1234567891011121314// 反模式if(navigator.userAgent.indexOf('MSIE') !== -1)&#123; document.attachEvent('onclick', console.log);&#125;// 比较好的做法if(document.attachEvent)&#123; document.attachEvent('onclick', console.log);&#125;// 更具体的做法if(typeof document.attachEvent !== 'undefined')&#123; document.attachEvent('onclick', console.log);&#125; DOM脚本DOM访问的代价是昂贵的，它是制约js性能的主要瓶颈，这是因为DOM通常是独立于js引擎而实现的。总之，DOM的访问应该减少到最低，这意味着： 避免在循环中使用DOM访问 将DOM引用分配给局部变量，并使用这些局部变量 在可能的情况下使用selector API（IE8以后都支持） 当在HTML容器中重复使用时，缓存重复的次数 example. 1234567891011// 反模式for(var i=0; i&lt;100; i++)&#123; document.getElementById('result').innerHTML += (i + ' , ');&#125;// 更好的方式，使用了局部便利了var i, content = '';for(i=0; i&lt;100; i++)&#123; content += (i + ' , ');&#125;document.getElementById('result').innerHTML += content; 为经常访问的元素增加id属性是一个很好的做法，因为document.getElementById(myId)是最简单快捷查找节点的方法。 除了访问DOM元素以外，对元素的增删改也很频繁。更新DOM会导致浏览器重新绘制屏幕，也会经常导致reflow（也就是重新计算元素的几何位置），这样会带来巨大的开销。 1. 添加节点时，使用文档碎片（document fragment） 1234567891011121314var p, t;var frag = document.createDocumentFragment();p = document.createElement('p');t = document.createTextNode('first paragraph');p.appendChild(t);frag.appendChild(p);p = document.createElement('p');t = document.createTextNode('second paragraph');p.appendChild(t);frag.appendChild(p);document.body.appendChild(frag); // 只触发一次屏幕重绘 2. 更新节点时，使用克隆镜像 1234567var oldNode = document.getElementById('result');var clone = oldNode.cloneNode(true);// 处理克隆对象...// 更新到DOMoldNode.parentNode.replaceChild(clone, oldNode); // 只触发一次重绘 事件委托事件委托模式得益于事件冒泡，会减少为每个节点附加的事件监听器数量。如果在div元素中有10个按钮，只需要为该div元素附加一个事件监听器就可以实现为每个按钮分别附加一个监听器的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142function myHandler(e) &#123; var src, parts; // 获取事件和源元素 e = e || window.event; src = e.target || e.srcElement; // 过滤不感兴趣的事件源 if (src.nodeName.toLowerCase() !== 'button') &#123; return; &#125; // 实际工作：更新标签 parts = src.innerHTML.split(": "); parts[1] = parseInt(parts[1], 10) + 1; src.innerHTML = parts[0] + ": " + parts[1]; // 无冒泡 if (typeof e.stopPropagation === "function") &#123; e.stopPropagation(); &#125; if (typeof e.cancelBubble !== 'undefined') &#123; e.cancelBubble = true; &#125; // 阻止默认操作 if (typeof e.preventDefault === "function") &#123; e.preventDefault(); &#125; if (typeof e.returnValue !== 'undefined') &#123; e.returnValue = false; &#125;&#125;// 事件绑定var el = document.getElementById('click-wrap');if (document.addEventListener) &#123; // W3C el.addEventListener('click', myHandler, false);&#125; else if (document.attachEvent) &#123; // IE el.attachEvent('click', myHandler);&#125; else &#123; // 终极手段 el.onclick = myHandler;&#125; 事件委托的缺点在于如果碰巧没有感兴趣的事件发生，那么增加的小部分代码就显得没用了。 YUI3中有一个Y.delegate()方法，该方法可以指定一个CSS选择器来匹配封装，并使用另外一个选择器来匹配感兴趣的节点。这是十分方便的，因为当事件在关注的节点之外发生时，回调函数实际上并没有被调用。 123456789101112function myHandler(e) &#123; var src = e.target; var parts = src.get('innerHTML').split(": "); parts[1] = parseInt(parts[1], 10) + 1; src.set('innerHTML', parts[0] + ": " + parts[1]); e.halt();&#125;YUI().use("event-delegate", function (Y) &#123; Y.delegate('click', myHandler, "#click-wrap", "button");&#125;); 同样，jQuery中也有类似的接口。$(selector).delegate(childSelector,event,data,function)参见http://www.w3school.com.cn/jquery/event_delegate.asp 长期运行脚本可能会注意到有时候浏览器会提示某个脚本已经运行了很长时间，是否应该停止脚本。实际上无论要处理多么复杂的任务，都不希望应用程序发生上述事情。而且，如果该脚本的工作十分繁重，那么浏览器的UI将会无法响应用户的任何操作，应该尽量避免。 在js中没有线程，但是可以在浏览器中使用setTimeout()来模拟线程。这样做的思想是将一个大任务分解为多个小任务，并为每一个小任务设置timeout为1毫秒。虽然这样会导致完成整个任务需要耗费更长的时间，但是通过这样做，可以使得用户接口保持响应，用户体验较好。 注意，timeout时间设置为1毫秒（或者0毫秒）实际上是与浏览器和操作系统有关的。0毫秒不意味着没有timeout，而是指尽可能快的处理。例如在IE中，最快的时钟周期是15毫秒。 最近的浏览器为长期运行的脚本提供了另外一个解决方案：Web Workers。它为浏览器提供了背景线程支持，可以将任务比较繁重的计算放在单独一个文件中，从主程序（网页）中调用该文件。 远程脚本XMLHttpRequestXMLHttpRequest是一个在大多数浏览器中都支持的特殊对象。建立一个HTTP请求分为如下三个步骤： 建立一个XMLHttpRequest对象（简写为XHR） 提供一个回调函数来告知请求对象改变状态 发送请求 但是在IE 7.0之前的版本中，XHR功能性是以ActiveX对象的方式实现的，因此对于那些版本需要做一些特殊处理。 12345678910111213141516171819202122232425262728293031var xhr;var activeXids = [ 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'];if (typeof XMLHttpRequest === "function") &#123; // 原生XHR xhr = new XMLHttpRequest(); &#125; else &#123; // IE 7.0之前版本 for (var i = 0; i &lt; activeXids.length; i += 1) &#123; try &#123; xhr = new ActiveXObject(activeXids[i]); break; &#125; catch (e) &#123;&#125; &#125;&#125;xhr.onreadystatechange = function () &#123; if (xhr.readyState !== 4) &#123; return false; &#125; if (xhr.status !== 200) &#123; alert("Error, status code: " + xhr.status); return false; &#125; document.body.innerHTML += "&lt;pre&gt;" + xhr.responseText + "&lt;\/pre&gt;";&#125;;xhr.open("GET", "page.html", true);xhr.send(""); JSONPJSONP（JSON with Padding）是另外一种创建远程请求的方法。和XHR有所不同，它不受同一个域浏览器策略的限制，出于从第三方网站载入数据的安全考虑，需要小心使用。 对应于XHR请求，JSONP的请求可以是任意类型的文档： XML文档（过去常用） HTML块（现在十分常见） JSON数据（轻量级，方便） 简单文本文件或者其他文档 对于JSONP，最常见的是用函数调用封装的JSON，函数名由请求方提供。JSONP请求的URL通常格式如，http://example.org/getdata.php?callback=myHandlergetdata.php可以是任意类型的网页，callback参数指定采用哪个js函数来处理该请求的返回值。 然后像这样将URL载入到动态的&lt;script&gt;元素 123var script = document.createElement('script');script.src = url;document.body.appendChild(script); 服务器响应JSONP数据，这些数据将作为回调函数的参数。最终的结果是在网页中包含了一个新脚本，该脚本碰巧是一个函数调用。但需注意的是，JSONP中的回调函数必须是一个公有的和全局有效的函数。 框架和图像灯塔使用框架也是一种处理远程脚本的备选方案。可以使用js创建一个iframe元素，并修改其src属性的url，新的URL可以包含更新调用者（在iframe之外的父页面）的数据和函数调用。 使用远程脚本最简单的场景是在只需要向服务器发送数据，而无需服务器回应的时候。在这种情形下，可以创建一个新图像，并将其src属性设置为服务器上的脚本文件，如下所示： 1new Image().src = 'http://example.org/some/page.php'; 这种模式称为图像灯塔（image beacon），这在希望向服务器发送日志数据时非常有用。举例来说，该模式可以用于收集访问者统计信息。因为用户并不需要服务器对这些日志数据的响应，通常的做法是服务器用一个1x1像素的GIF图片来作为响应（虽然这是一种不好的模式）。使用”204 Not Content”这样的HTTP响应是更好的选择，该HTTP响应的意思是指仅向客户端发送HTTP报头文件，而不发送HTTP内容体。 脚本载入性能脚本元素会阻止下载网页内容。浏览器可以同时下载多个组件，但一旦遇到一个外部脚本文件后，浏览器会停止进一步下载，直到这个脚本文件下载、解析并执行完毕。为了最小化阻止的影响，可以将脚本元素放置于网页的最后部分，刚好在&lt;/body&gt;标签之前。 也有一些模式可以防范这个问题： 使用XHR请求载入脚本，并使用eval()将其转换为字符串。缺点是该方法受同一个域的限制，并且使用了eval()这种不好的模式。 使用defer和async属性。缺点是这种方法并不能在所有浏览器上都有效。 使用动态的&lt;script&gt;元素 动态script元素123var script = document.createElement('script');script.src = 'all_20141209.js';document.documentElement.firstChild.appendChild(script); 上面的过程不会阻塞网页文件中其他部分的下载。但该模式的缺点在于如果js脚本依赖于载入主js文件，那么采用该模式后不能有其他脚本元素。主js文件是异步载入的，因此无法保证该文件什么时候能够载入完毕，所以紧跟着主js文件的脚本可能要假定对象都还未定义。 为了解决该缺点，可以让所有内联的脚本都不要立即执行，而是将这些脚本都收集起来放在一个数组里面。然后当主脚本文件载入完毕后，就可以执行所有缓存数组中收集的函数了。 首先，创建一个数组来存储所有内联代码，这部分代码应该放在页面文件尽可能前面的位置。 123var myNamespace = &#123; inlineScripts: []&#125;; 然后，需要将所有单独的内联脚本封装到一个函数中，并将每个函数增加到inlineScripts数组中。 12345678// 过去是// &lt;script&gt;console.log('inline');&lt;/script&gt;// 修改为&lt;script&gt;myNamespace.inlineScripts.push(function()&#123; console.log('inline');&#125;);&lt;/script&gt; 最后，循环执行缓存中的所有内联脚本。 123for(var i=0, len=myNamespace.inlineScripts.length; i&lt;len; i++)&#123; myNamespace.inlineScripts[i]();&#125; script元素位置上面的例子中，documentElement是指&lt;html&gt;，而它的第一个子元素就是&lt;head&gt; 1document.documentElement.firstChild.appendChild(script); 通常也可以这样写 1document.getElementsByTagName('head')[0].appendChild(script); 可以在网页中不使用&lt;head&gt;和&lt;body&gt;，尽管document.body通常能够在没有&lt;body&gt;标签时正常运作。但是实际上有一个标签一直会在脚本运行的网页中存在，那就是&lt;script&gt;标签，如果没有它，那么里面的js代码就不会运行。基于以上事实，可以在网页中使用insertBefore()来在第一个有效的元素之前插入元素。 12var firstScript = document.getElementsByTagName('script')[0];firstScript.parentNode.insertBefore(script, firstScript); 延迟加载12345window.onload = function()&#123; var script = document.createElement('script'); script.src = 'all_lazy_20141209.js'; document.documentElement.firstChild.appendChild(script);&#125;; 这样的做法符合渐进增强的思想，一部分代码是用于初始化页面并将事件附加到UI元素上，而第二部分代码只在用户交互或者其他条件下才用得上，因此这部分内容可以在用户浏览该页面时在后台载入。对于许多应用程序来说，延迟加载的代码部分远远大于立即加载的核心部分，因为很多有趣的操作（例如拖放、XHR和动画等）只在用户触发后发生。 按需加载上面的模式在页面载入后，无条件地载入附加的js脚本，假定这些代码极有可能用得上。如果只载入那些确实需要的代码，请使用按需加载模式。可以创建一个require()函数，该函数包含需要加载的脚本的名称和当附加脚本加载后需要执行的回调函数。用法如下 123require('extra.js', function()&#123; functionDefinedInExtraJS();&#125;); require函数的实现 12345678910111213141516171819function require(file, callback) &#123; var script = document.getElementsByTagName('script')[0], newjs = document.createElement('script'); // IE newjs.onreadystatechange = function () &#123; if (newjs.readyState === 'loaded' || newjs.readyState === 'complete') &#123; callback(); &#125; &#125;; // 其他浏览器 newjs.onload = function () &#123; callback(); &#125;; newjs.src = file; script.parentNode.insertBefore(newjs, script);&#125; 在IE中订阅readystatechange事件，并寻找readyState状态为”loaded”或”complete”的状态。而在Firefox、Safari和Opera中，需要通过onload属性订阅load事件。注意：这种方法不适用于Safari 2，如果需要，请创建一个时间间隔来定期检查是否指定变量已定义（在附加文件中定义的变量）。当该变量被定义以后，就意味着新脚本已经加载并执行了。 预加载模式在延迟加载和按需加载模式中，我们延迟加载当前页面需要的脚本。此外，还可以延迟加载当前页面不需要，但是在后续页面中可能需要的脚本。这样，当用户打开接下来的网页后，所需要的脚本已经预先加载了，进而用户会感觉速度加快了。 预加载可以使用动态脚本模式来实现，但是这意味着该脚本将被解析和执行。解析仅仅会增加预加载的时间，而执行脚本可能会导致js错误，因为这些脚本应该是在第二个页面执行的，例如寻找某个特定的DOM节点。 可以加载脚本而并不解析和执行这些脚本，在IE中可以使用图像灯塔来发出请求。在所有其他浏览器中可以使用一个&lt;object&gt;来代替脚本元素，并将其data属性指向脚本的URL。 123456789101112131415var preload; if (/*@cc_on!@*/false) &#123; // 使用条件注释的IE嗅探 preload = function (file) &#123; new Image().src = file; &#125;;&#125; else &#123; preload = function (file) &#123; var obj = document.createElement('object'); // 避免显示出该对象 obj.width = 0; obj.height = 0; obj.data = file; document.body.appendChild(obj); &#125;;&#125; 注意：上面的代码使用了分支注释来嗅探IE，该方法比在navigator.userAgent中寻找字符串要安全一些，因为那些字符串很容易被用户修改。var isIE = /*@cc_on!@*/false; 会在除IE外的其他浏览器中将isIE设置为false，因为在注释语句中有一个!，因此在IE中isIE的值为true。 这种模式的缺点在于使用了用户代理嗅探，但是这是无法避免的。因为在这种情况下，使用特性检测技术无法告知关于浏览器行为的足够信息。举例来说，在这种模式下如果 typeof Image === &#39;function&#39;，那么理论上可以用该函数来代替嗅探。然而在这里该方法没有作用，因为所有浏览器都支持 new Image(); 区别仅仅在于有的浏览器为图像有独立的缓存，这也就意味着作为图像预加载的组件不会被用作缓存中的脚本，因此下一个页面会再次下载该图像。 预加载模式可以用于各种类型组件，而不限于脚本。举例来说，这在登录页面就十分有用。当用户开始输入用户名时，可以使用输入的时间来启动预加载，因为用户下一步极有可能进入登录后的界面。 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之六-设计模式]]></title>
    <url>%2Fblog%2F2014%2F11%2Fjs-pattern-part6-design-pattern.html</url>
    <content type="text"><![CDATA[单体模式单体（Singleton）模式的思想在于保证一个特定类仅有一个实例。这意味着当第二次使用同一个类创建对象的时候，应该得到与第一次所创建对象完全相同的对象。 在js中，对象之间永远不会完全相等，除非它们是同一个对象，因此即使创建一个具有完全相同成员的同类对象，它也不会与第一个对象完全相同。 123var obj1 = &#123;&#125;;var obj2 = &#123;&#125;;obj1 == obj2; //output: false 因此，可以认为每次在使用对象字面量创建对象的时候，实际上就是在创建一个单体。注意有时人们在js中所说的“单体”，就是指前面提到的“模块模式”。 1.通过静态属性实现单体 1234567891011121314function Universe()&#123; if(typeof Universe.instance === 'object')&#123; return Universe.instance; &#125; // 正常进行 this.start_time = 0; // 缓存 Universe.instance = this; // 隐式返回 // return this;&#125; 这种方法非常直接，但是缺点在于其instance属性是公开的，存在被恶意修改的隐患。 2.通过闭包实现单体 123456789101112function Universe()&#123; // 缓存实例 var instance = this; // 正常进行 this.start_time = 0; // 重写该构造函数 Universe = function()&#123; return instance; &#125;;&#125; 这种实现实际上是来自于前面提到的“自定义函数”模式的另一个例子。这种方法的缺点在于，重写构造函数会丢失所有在初始化定义和重定义时刻之间添加到它里面的属性。 1234567891011121314Universe.prototype.nothing = true;var uni = new Universe();Universe.prototype.everything = true;var uni2 = new Universe();uni.nothing; //output: trueuni2.nothing; //output: trueuni.everything; //output: undefineduni2.everything; //ouput: undefined// 结果看上去是正确的uni.constructor.name; //ouput: "Universe"// 但这是奇怪的uni.constructor === Universe; //output: flase 之所以uni.constructor不在与Universe()构造函数相同，是因为uni.constructor仍然指向了原始的构造函数，而不是重新定义的那个构造函数。 如果需要使原型和构造函数指针安装预期的那样运行，改进如下 1234567891011121314151617181920212223function Universe()&#123; // 缓存实例 var instance; // 重写构造函数 Universe = function Universe()&#123; return instance; &#125;; // 保留原型属性 Universe.prototype = this; // 实例 instance = new Universe(); // 重置构造函数指针 instance.constructor = Universe; // 所有功能 instance.start_time = 0; return instance;&#125; 另一种解决方案是将构造函数和实例包装在即时函数中，如下 123456789101112131415var Universe;(function()&#123; var instance; Universe = function Universe()&#123; if(instance)&#123; return instance; &#125; instance = this; // 所有功能 this.start_time = 0; &#125;;&#125;)(); 工厂模式工厂模式的目的是为了创建对象，它通常在类或类的静态方法中实现，具有下列目标： 1.当创建相似对象时执行重复操作 2.当编译时不知道具体类型（类）的情况下，为工厂客户提供一种创建对象的接口 1234567891011121314151617181920212223242526272829303132333435363738394041// 父构造函数function CarMaker()&#123;&#125;CarMaker.prototype.drive = function()&#123; return "Vroom, I hvae " + this.doors + ' doors';&#125;;// 静态工厂方法CarMaker.factory = function(type)&#123; var newcar; // 如果构造函数不存在，则发生错误 if(typeof CarMaker[type] !== 'function')&#123; throw &#123; name: 'Error', message: type + ' doesn\'t exist' &#125;; &#125; // 在这里，构造函数是已知存在的 // 我们使得原型继承父类，但仅继承一次 if(typeof CarMaker[type].prototype.drive !== 'function')&#123; CarMaker[type].prototype = new CarMaker(); &#125; // 创建一个新的实例 newcar = new CarMaker[type](); // 可选择性的调用一些方法后返回…… return newcar;&#125;// 定义特定的汽车制造商CarMaker.Compact = function()&#123; this.doors = 4;&#125;;CarMaker.Convertible = function()&#123; this.doors = 2;&#125;;CarMaker.SUV = function()&#123; this.doors = 24;&#125;; factory方法通过字符串指定类型来创建对象。继承部分仅是可以放进工厂方法的一个公用重复代码片段的范例，而不是对每种类型的构造函数的重复。 值得注意的是，js内置的Object()就是一个自然工厂，它根据输入类型而创建不同的对象。 1234var s = new Object('1');var n = new Object(1);s.constructor === String; //output: truen.constructor === Number; //output: true 装饰者模式装饰者模式的一个比较方便的特征在于其预期行为的可定制和可配置特性。可以从仅具有一些基本功能的普通对象开始，然后从可用装饰资源池中选择需要用于增强普通对象的那些功能，并且按照顺序进行装饰，尤其是当装饰顺序很重要的时候。 1.使用继承实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Sale(price)&#123; this.price = price || 100;&#125;Sale.prototype.getPrice = function()&#123; return this.price;&#125;;// 以字符串的方式找到对象块拼接Sale.prototype.decorate = function(decorator)&#123; var F = function()&#123;&#125;; F.prototype = this; var newObj = new F(); newObj.super = F.prototype; var overrides = this.constructor.decorators[decorator]; for(var i in overrides)&#123; if(overrides.hasOwnProperty(i))&#123; newObj[i] = overrides[i]; &#125; &#125; return newObj;&#125;// 装饰者对象都将以构造函数的属性这种方式来实现Sale.decorators = &#123;&#125;;Sale.decorators.fedtax = &#123; getPrice: function()&#123; var price = this.super.getPrice(); price += price * 5 / 100; return price; &#125;&#125;;Sale.decorators.cdn = &#123; getPrice: function()&#123; return 'CDN$ ' + this.super.getPrice().toFixed(2); &#125;&#125;;// 用法var sale= new Sale(100);sale = sale.decorate('fedtax');sale = sale.decorate('cdn');sale.getPrice(); //output: CDN$ 105.00 2.使用列表实现 利用js语言的动态性质，根本不需要使用继承。此外，并不是使每个装饰方法调用链中前面的方法，我们可以简单地将前面方法的结果作为参数传递到下一个方法。 12345678910111213141516171819202122232425262728293031323334353637function Sale(price)&#123; this.price = (price &gt; 0) || 100; this.decorators_list = [];&#125;Sale.decorators = &#123;&#125;;Sale.decorators.fedtax = &#123; getPrice: function(price)&#123; return price + price * 5 / 100; &#125;&#125;;Sale.decorators.cdn = &#123; getPrice: function(price)&#123; return 'CDN$ ' + price.toFixed(2); &#125;&#125;;Sale.prototype.decorate = function(decorator)&#123; this.decorators_list.push(decorator);&#125;;Sale.prototype.getPrice = function()&#123; var price = this.price; var name; for(var i=0, len=this.decorators_list.length; i&lt;len; i++)&#123; name = this.decorators_list[i]; price = Sale.decorators[name].getPrice(price); &#125; return price;&#125;;// 用法var sale = new Sale(100);sale.decorate('fedtax');sale.decorate('cdn');sale.getPrice(); //output: CDN$ 105.00 在使用继承的实现方法中，decorate()具有一定的复杂性，而getPrice()非常简单。而在这里的实现中正好相反，decorate()进用于追加列表，而getPrice()却完成所有工作。这种实现方式更为简单，并且还可以很容易的支持反装饰或撤销装饰。 如果想拥有更多可以被装饰的方法，那么每个额外的装饰方法都需要重复遍历装饰者列表这一部分的代码。然而，这很容易抽象成一个辅助方法，通过它来接受方法并使其成为“可装饰”的方法。【接受方法？】在这样的实现中，sale中的decorators_list属性变成了一个对象，且该对象中的每个属性都是以装饰对象数组中的方法和值命名。【？】 【我的实现】 123456789101112131415Sale.prototype.getDecoratedValue = function(methodName)&#123; var value, name; var params = Array.prototype.slice.call(arguments, 1); for(var i=0, len=this.decorators_list.length; i&lt;len; i++)&#123; name = this.decorators_list[i]; value = Sale.decorators[name][methodName].apply(this, params); params = [value]; &#125; return value;&#125;;Sale.prototype.getPrice = function()&#123; return this.getDecoratedValue('getPrice', this.price);&#125;; 策略模式策略模式支持在运行时选择算法。代码的客户端可以使用同一个接口来工作，但是它却根据客户正在试图执行任务的上下文，从多个算法中选择用于处理特定任务的算法。使用策略模式的一个例子是解决表单验证的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var validator = &#123; // 所有可用的检查 types: &#123;&#125;, // 在当前验证会话中的错误消息 messages: [], // 当前验证配置 // key: 名称 value: 验证类型 config: &#123;&#125;, // 接口方法 // data为key-value对 validate: function(data)&#123; var msg, type, checker, result_ok; // 重置所有消息 this.messages = []; for(var i in data)&#123; if(data.hasOwnProperty(i))&#123; type = this.config[i]; checker = this.types[type]; if(!type)&#123; continue; // 不需要验证 &#125; if(!checker)&#123; throw &#123; name: 'ValidationError', message: 'No handler to validate type ' + type &#125;; &#125; result_ok = checker.validate(data[i]); if(!result_ok)&#123; msg = 'Invalid value for *' + i + '*, ' + checker.instructions; this.messages.push(msg); &#125; &#125; &#125; return this.hasErrors(); &#125;, // 帮助方法 hasErrors: function()&#123; return this.messages.length &gt; 0; &#125;&#125;;// 非空值的检查validator.types.isNonEmpty = &#123; validate: function(value)&#123; return value !== ''; &#125;, instructions: 'the value cannot be empty'&#125;;// 检查是否是一个数字validator.types.isNumber = &#123; validate: function(value)&#123; return !isNaN(value); &#125;, instructions: 'the value can only be a valid number'&#125;;// *****// 用法// *****var data = &#123; name: 'fucky', age: 'unknown'&#125;;validator.config = &#123; name: 'isNonEmpty', age: 'isNumber'&#125;;validator.validate(data);if(validator.hasErrors())&#123; console.log(validator.messages.join('\n'));&#125; 如上所示，validator对象是通用的，增强validator对象的方法是添加更多的类型检查。以后针对每个新的用例，所需做的就是配置该验证器并运行validate()方法。 外观模式外观（facade）模式是一种简单的模式，它为对象提供了一个可供选择的接口。这是一种很好的设计实践，可保持方法的简洁性并且不会使它们处理过多的工作。有时候，两个或更多的方法可能普遍的被一起调用，在这样的情况下，创建另一个方法以包装重复的方法调用是非常有意义的。 例如，当处理浏览器事件时，stopPropagation()和preventDefault()两个方法经常被一起调用。外观模式非常适合于浏览器脚本处理，据此可讲浏览器之间的差异隐藏在外观之后。 123456789101112131415161718var myevent = &#123; stop: function(e)&#123; // IE if(typeof e.returnValue === 'boolean')&#123; e.returnValue = false; &#125; if(typeof e.cancelBubble === 'boolean')&#123; e.cancelBubble = true; &#125; // 其他 if(typeof e.preventDefault === 'function')&#123; e.preventDefault(); &#125; if(typeof e.stopPropagation === 'function')&#123; e.preventDefault(); &#125; &#125;&#125;; 代理模式在代理设计模式中，一个对象充当另一个对象的接口。它与外观模式的区别在于，在外观模式中你所拥有的是合并了多个方法调用的便利方法。代理则介于对象的客户端和对象本身之间，并且对该对象的访问进行保护。 这种模式可能看起来像是额外的开销，但是出于性能因素的考虑它却非常有用。代理充当了某个对象（也称为“本体对象”）的守护对象，并且试图使本体对象做尽可能少的工作。 使用这种模式的一个例子是延迟初始化（lazy initialization）。假设初始化本体对象开销非常大，而恰好又在客户端初始化该本体对象以后，应用程序实际上却从来没有使用过它。在这种情况下，首先由客户端发出一个初始化请求，然后代理以“一切正常”作为响应，但实际上并没有将该消息传递到本体对象，直到客户端明显需要本体对象完成一些工作的时候。只有到那个时候，代理才将两个消息一起传递。 另一个例子是将访问聚集为组，比如尽可能合并更多的http请求就很重要，节省网络开销。这一点有点像数据库里的 batch insert。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var proxy = &#123; ids: [], delay: 50, timeout: null, callback: null, context: null, makeRequest: function(id, callback, context)&#123; // 加入到队列中 this.ids.push(id); this.callback = callback; this.context = context; // 设置超时时间 if(!this.timeout)&#123; this.timeout = setTimeout(function()&#123; proxy.flush(); &#125;, this.delay); &#125; &#125;, flush: function()&#123; // http是处理请求的本体对象，仅有这一个方法 http.makeRequest(this.ids, 'proxy.handler'); // 清除超时设置和队列 this.timeout = null; this.ids = []; &#125;, // JSONP的callback handler: function(data)&#123; // 单个结果 if(parseInt(data.query.count, 10) === 1)&#123; proxy.callback.call(proxy.context, data.query.results.Video); return; &#125; // 多个结果 for(var i=0, len=data.query.results.Video.length; i&lt;len; i++)&#123; proxy.callback.call(proxy.context, data.query.results.Video[i]); &#125; &#125;&#125;; 本例中，代理可以通过将以前的请求结果缓存到新的cache属性中，从而更进一步的保护对本体对象http的访问，节省网络往返消息。 中介者模式在中介者模式中，独立的对象（称为colleague）之间并不直接通信，而是通过mediator对象。当其中一个colleague对象改变状态后，它将会通知该mediator，而mediator将会把该变化传达到任意其他应该知道此变化的colleague对象。 示例：按键游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 玩家function Player(name) &#123; this.points = 0; this.name = name;&#125;Player.prototype.play = function () &#123; this.points += 1; mediator.played();&#125;;// 计分板var scoreboard = &#123; // 待更新的HTML元素 element: document.getElementById('results'), // 更新得分显示 update: function (score) &#123; var i, msg = ''; for (i in score) &#123; if (score.hasOwnProperty(i)) &#123; msg += '&lt;p&gt;&lt;strong&gt;' + i + '&lt;\/strong&gt;: '; msg += score[i]; msg += '&lt;\/p&gt;'; &#125; &#125; this.element.innerHTML = msg; &#125;&#125;;// 中介者对象var mediator = &#123; // 所有玩家（player对象） players: &#123;&#125;, // 初始化游戏 setup: function () &#123; var players = this.players; players.home = new Player('Home'); players.guest = new Player('Guest'); &#125;, // 如果有人玩，则更新得分值 played: function () &#123; var players = this.players, score = &#123; Home: players.home.points, Guest: players.guest.points &#125;; scoreboard.update(score); &#125;, // 处理用户交互 keypress: function (e) &#123; e = e || window.event; // IE if (e.which === 49) &#123; // key "1" mediator.players.home.play(); return; &#125; if (e.which === 48) &#123; // key "0" mediator.players.guest.play(); return; &#125; &#125;&#125;;// 运行游戏mediator.setup();window.onkeypress = mediator.keypress;// 游戏在30秒内结束setTimeout(function () &#123; window.onkeypress = null; alert('Game over!');&#125;, 30000); 观察者模式观察者模式广泛应用于客户端js编程中，所有的浏览器事件（鼠标悬停，按键等事件）都是该模式的例子。它的另一个名字也称为自定义事件（custom events），该模式的另一个别名是订阅/发布（subscriber/publisher）模式。 在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动，并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者，并且可能经常以事件对象的形式传递消息。 示例：按键游戏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// 发布者对象var publisher = &#123; // 订阅者 // key为订阅的消息类型（默认为'any'） // value为回调函数的列表 subscribers: &#123; any: [] &#125;, // 即subscribe方法 // context支持回调方法使用this以引用自己的对象 on: function (type, fn, context) &#123; type = type || 'any'; fn = typeof fn === "function" ? fn : context[fn]; if (typeof this.subscribers[type] === "undefined") &#123; this.subscribers[type] = []; &#125; this.subscribers[type].push(&#123;fn: fn, context: context || this&#125;); &#125;, // 即unsubscribe方法 remove: function (type, fn, context) &#123; this.visitSubscribers('unsubscribe', type, fn, context); &#125;, // 即publish方法 // publication为传递给回调函数的参数 fire: function (type, publication) &#123; this.visitSubscribers('publish', type, publication); &#125;, // help遍历方法 visitSubscribers: function (action, type, arg, context) &#123; var pubtype = type || 'any', subscribers = this.subscribers[pubtype], i, max = subscribers ? subscribers.length : 0; for (i = 0; i &lt; max; i += 1) &#123; if (action === 'publish') &#123; // 支持回调方法使用this指向自身对象 // arg为传递给回调函数的参数，多参数请用对象包起来 subscribers[i].fn.call(subscribers[i].context, arg); &#125; else &#123; // 取消订阅 if (subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) &#123; subscribers.splice(i, 1); &#125; &#125; &#125; &#125;&#125;;// 使一个对象成为一个发布者function makePublisher(o) &#123; var i; for (i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === "function") &#123; o[i] = publisher[i]; &#125; &#125; // 非函数成员不能复用指针，需创建新对象 o.subscribers = &#123;any: []&#125;;&#125;// 玩家function Player(name, key) &#123; this.points = 0; this.name = name; this.key = key; // 触发事件 this.fire('newplayer', this);&#125;Player.prototype.play = function () &#123; this.points += 1; // 触发事件 this.fire('play', this);&#125;;// 游戏控制var game = &#123; // 记录玩家 // key为按键，value为玩家对象 keys: &#123;&#125;, addPlayer: function (player) &#123; var key = player.key.toString().charCodeAt(0); this.keys[key] = player; &#125;, // 处理用户交互 handleKeypress: function (e) &#123; e = e || window.event; // IE if (game.keys[e.which]) &#123; game.keys[e.which].play(); &#125; &#125;, // 如果有人玩，则更新得分值 handlePlay: function (player) &#123; var i, players = this.keys, score = &#123;&#125;; for (i in players) &#123; if (players.hasOwnProperty(i)) &#123; score[players[i].name] = players[i].points; &#125; &#125; // 触发事件 this.fire('scorechange', score); &#125;&#125;;// 计分板var scoreboard = &#123; // 待更新的HTML元素 element: document.getElementById('results'), // 更新得分显示 update: function (score) &#123; var i, msg = ''; for (i in score) &#123; if (score.hasOwnProperty(i)) &#123; msg += '&lt;p&gt;&lt;strong&gt;' + i + '&lt;\/strong&gt;: '; msg += score[i]; msg += '&lt;\/p&gt;'; &#125; &#125; this.element.innerHTML = msg; &#125;&#125;;// 发布/订阅绑定makePublisher(Player.prototype); // 注意Player要绑在prototype上，避免多份拷贝makePublisher(game);Player.prototype.on("newplayer", "addPlayer", game);Player.prototype.on("play", "handlePlay", game);game.on("scorechange", scoreboard.update, scoreboard);window.onkeypress = game.handleKeypress;// 运行游戏var playername, key;while (1) &#123; playername = prompt("Add player (name)"); if (!playername) &#123; break; &#125; while (1) &#123; key = prompt("Key for " + playername + "?"); if (key) &#123; break; &#125; &#125; new Player(playername, key); &#125; 中介者VS观察者在中介者模式的实现中，mediator对象必须知道所有其他对象，以便在正确的时间调用正确的方法并且与整个游戏相协调。而在观察者模式中，game对象显得更缺乏智能，它主要依赖于对象观察某些事件并采取行动。比如，scoreboard监听scorechange事件。这导致了更为松散的耦合（越少的对象知道越少），其代价是在记录谁监听什么事件时显得更困难一点。 在本例的游戏中，所有订阅行为都出现在代码片段的同一位置，但是随着应用程序的增长，on()调用可能到处都是（例如在每个对象的初始化代码中）。这会使得该程序难以调试，因为现在无法仅在单个位置查看代码并理解到底发生了什么事情。在观察者模式中，可以摆脱那种从开始一直跟随到最后的那种过程式顺序代码执行的程序。 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[煮粥记]]></title>
    <url>%2Fblog%2F2014%2F07%2Fmy-congee-cooking.html</url>
    <content type="text"><![CDATA[本人也算出自半个“厨艺世家”，我爷爷在那时的大包干食堂做了30年的厨师，到退休时领导还不肯放人，再聘请他再干5年。我爸则是在家烧了20年的饭，部分继承了爷爷的手艺，部分还改良了。要是去外面开个小饭店，绝对是被人称赞好吃的。 论厨艺嘛我是战五渣，吃自助的战斗力倒是百分百。自从宿舍有了电磁炉，也学会了点自己动手丰衣足食，咳咳…… 最近煮了好多粥，尝试了银耳汤的各种做法。起码比我以前煮挂面好多了 红糖大枣糯米粥材料 圆糯米 红枣 红糖 工序 沸腾后要改小火，而且时不时要用勺子搅拌，以免粘锅 炖到糯米发稠，然后再加红糖 插曲 由于第一次煮粥没经验，米放太多了，图中满满一锅有木有，而且就两个人吃=_= 刚开始还忘了搅拌，烧糊了，还好机智的红糖君自带了生姜末（因为他叫生姜红糖，不是月月红糖！） 生姜冲淡了焦味，只要不说，不会觉得这是烧糊的粥。。。 银耳莲子木瓜汤材料 银耳 木瓜 莲子、枸杞少许 大块的黄冰糖 准备 将银耳浸于冷水中，泡两个小时，然后去掉黄色的根部 同样将莲子浸于水中，剥开将其绿色的芯去除 木瓜去皮切块 工序 将银耳和莲子一起丢入锅中，倒入两倍高度的水 待水沸腾后改小火慢炖 15-20分钟后放木瓜 待汤水开始粘稠时放入适量的大块黄冰糖 再慢炖10分钟 撒入少许枸杞 继续焖10分钟 注意 炖银耳汤是个慢活，虽然银耳不会烧糊，但是会起泡沫容易噗。因为我又是满满一锅（=_=）所以小火慢炖的时候在锅上架两根筷子，把锅盖隔开。前后差不多炖了近一个小时，我喜欢吃粘稠的，只能这样…… 银耳莲子红枣汤材料大体同上，将木瓜换成红枣。 工序 将银耳、莲子和红枣一起丢入锅中，倒入两倍高度的水 待水沸腾后改小火慢炖 待汤水开始粘稠时放入适量的大块黄冰糖 再慢炖直到你想吃的稠度 注意 红枣要剥开缝后再丢入，这样能更入味~ 银耳和红枣绝对是天生一对！ 银耳莲子红枣南瓜羹材料大体同上，多放个南瓜。南瓜也要一开始就丢入锅中。 放了南瓜君过后貌似就不容易粘稠了=_= 糯米白粥某早下大雨，懒得出门吃早饭，就用糯米煮了点白粥吃。 要注意小火慢炖，并且时不时搅拌，免得粘锅烧糊了。 白粥汤略带一点稠，很好喝。配上榨菜，嗯嗯 总结不要低估了糯米的实力，看上去一点点煮出来吃了说不定就饱了。 试了三种混料的银耳汤，银耳+木瓜，银耳+红枣，银耳+南瓜，亲测还是银耳+红枣最好吃，红枣和黄冰糖的甜味是一个方向的。而加了木瓜容易串味，南瓜的话还可以。 炎炎夏日吃银耳红枣汤是不是略补……下次试下绿豆汤，我要做最好吃的绿豆汤。加薄荷加红绿丝的那种绿豆汤，只在小时候喝过，我要还原记忆中的味道！]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人机交互作业检查的一点感想——暨前端阶段总结]]></title>
    <url>%2Fblog%2F2014%2F07%2Ftrivial-thoughts-after-hci-homework-checking.html</url>
    <content type="text"><![CDATA[今天帮同学当了“人机交互”课助教的苦力，我以前一直很鄙视这种“文档驱动”的课的，课上光讲各种XX原则，再看些天花乱坠的视频，最后还是以设计文档为主力。学院主打软工类的课程，还被戏谑“文档学院” =_= Knowing is not enough, we must apply. Willing is not enough, we must do. 这两句话好像是Bruce Lee说的。在我们09级之后，学院这方面略有改善。今年人机交互的作业是基于自己以往做过的项目，对交互方面做改进。八成的小组都做的是Web项目，于是他们又撞我枪口了，想忽悠我no way 我想了下他们的一些特征，归了归类，以人为镜，也是对自己的反思。 关于忽悠我一直佩服实验室一博士的交际能力，忽悠时一点都不虚，能把没有的说已经有了。要忽悠首先你要心理素质好，还要靠经验，尽量往客户方面靠。就像买鞋，不是你多大脚买多大鞋，而是他多大鞋你就多大脚。还有忽悠成功的重要因素这方面你知道的要比客户知道的多的多。 回到人机交互作业，大部分人做的都是web页面上的改进，我专做前端也有一段时间了。我跟他们说不是的地方，居然还有人要狡辩想忽悠我，真是too young了。 关于框架和插件超过一半的小组都用了Bootstrap大法，卧槽真是热！做前端用用框架和插件很正常，但至少要保证插件之间的兼容，至少改改画风，不能看起来像两个格格不入的系统风格。有人跟我狡辩说“什么什么插件用了后什么什么地方会出问题”，我说“不是插件的问题，是你不会”。这也反映了他们对插件的过于依赖，而且在一知半解的情况下的过于依赖。 我后来跟一位同学交流了下，我说刚上来时用框架用插件确实能减少很多工作量，但是你要知道每样东西的适合之处和不适合之处，你要知道它好在哪里。之后你就要学学它们背后的理念，学会扩展它们，甚至可以依样画葫芦做一个类似的插件。 什么是交互的改进也许是学院从大一到大三都强调的是后端编程，根深蒂固的Java习惯，好多学生不知道交互上要改进什么。有人就以为是功能上的改进，又加功能，或者是把功能的后台处理更好些。也有人以为就是改改外观。要么就是他们偷懒，不然这门课真成“政治课”了。于是我就有了奇葩的评分标准：看表单验证，看消息的弹框，看分页，看站内搜索，看用户输入是否简单，还有最重要的是看整体布局和色调是否像一个完整的系统。 还有一点感触是，作业毕竟是作业，怎么简单怎么来，直接一个alert，直接一个&lt;input type=&quot;date&quot;&gt;…… 想想我大三的时候也是这样的&gt;_&lt; 当然也有厉害的人，做的看起来真像一个可以发布的产品了。 前端的误区前端 ≠ 写网页的 前端 ≠ CSS框架 + jQuery + 杂七杂八插件 + w3school手册 前端既是最容易的，又是最不容易的。 这句话不是哪抄的，是我自己的真实感受。前端门槛低，三件套（HTML+CSS+JS）在w3school上三天就能速成，而且还有Bootstrap、Metro UI等框架组件的存在，再配合jQuery，从零开始半个月就能搞个逼格十足的网站出来。再加上前端固有的“开源”特性，不会的地方可以依样画葫芦。所以前端是最容易的。 但如果只停留在“二十一天精通XXX”的程度，永远也入不了门。框架一直在变，永远被它牵着鼻子走，没有自己的理解是不行的。看过有位博主说“前端不仅仅是实现页面，前端工程师的职责是运用合理的方法让开发变得高效，让用户体验最佳”。这里说的就是软件工程、体系结构、设计模式，以及人机交互里的东西，而这些课正是我大软院的主线。我们应该把那些一套套的模型和原则渗透到实际的项目操作中去，而不是把那些课当成“政治课”去背。 我与前端想到我自己到大三才刚碰web项目（之前都是大软院标配的Java客户端），也是从最最基础的开始看，边看边做。大三暑假在外面小作坊实习的时候，老板都是按功能分工的，修改一个功能从数据库改表开始，然后一直做到界面。每回都是把底下的逻辑理清楚了，最后纠结在界面上，一个按钮一个编辑区域一个Ajax都要折腾好久。当时就知道w3school手册，有问题就百度，别人好好的，到我这里都出问题，对知识都一知半解，老板还一个劲儿的催。 说到底当时的各种不顺都是因为没有静下心系统地学过web。对技术上的浮躁和浅尝辄止的心，又让我想换别的玩了。后来与前端的结缘是本科毕设时，分工就按前后端分，因为后端选择的语言我不会，所以我就挑了前端 =_= 那时知道了Bootstrap神奇的存在，熟练了jQuery大法的常见操作，麻麻再也不用担心我做web了…… 但亲爱的那并不是爱情 渐渐明白只会用用插件，终究是个没有灵魂的躯壳。后来认真的看了看CSS中的一些定义，试图像机器一样去理解一些常见的CSS规则。再静下心看了些原生javascript的知识，理解其语言机制，可以更好的用好jQuery这把刀。 最后推荐几本书精通CSS与HTML设计模式 JavaScript艺术与科学 JavaScript模式 JavaScript设计模式 最近在学习JavaScript框架设计 真的好难&gt;_&lt; 还有好多路要走，阶段性记录下，以激励自己继续前行。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PhantomJs对网页截图]]></title>
    <url>%2Fblog%2F2014%2F06%2Fuse-phantomjs-to-capture-webpage.html</url>
    <content type="text"><![CDATA[问题来源我们在做一个电商数据分析的项目，web前端的数据展示使用的是Highcharts库。目前我们的项目正在做移动版，以微信消息或微博的形式给用户推送summary信息，然后再以手机浏览器的形式展示详细信息。这里就存在个问题，首先，Highcharts是依赖jQuery的，这两个库对于移动端来说有点大了，移动web端目前流行使用更轻量级的zepto来代替jQuery。其次，Highcharts的图表类型在手机浏览器上并不能很好的支持，会出现有些图表无法正确显示，比如bar-stacked图。 退而求其次移动版就是为了用户能够随时随地看咨询，操作方便和传输速度是第一位的。而且对于图表这类东西，由于触屏的限制（它没有hover的概念），本身就不好像PC浏览器那样做图表上的交互。因此移动端的图表可以暂不考虑交互，优先给用户图表的静态图片即可。 最低成本方案由于PC端web已经采用Highcharts绘制了数据图表，因此自然会想到两种办法。 使用Highcharts自带的exporting module，将chart转成图片形式。 直接在浏览器里对相应的图表区域截图。 不管用哪种方法，我们首先要把系统中所有的图表的地方汇聚起来，做一个REST API，将功能的action、参数以及图表类型传入url中，统一生成Highchart。 如果使用第1种办法，那得引入Highcharts里的exporting.js，然后找到export函数的入口，想办法以执行脚本的方式导出图片。但这里有两个问题，第一，如果通过写程序的方式（python中是urlopen）去访问该REST API，如何执行js脚本呢。第二，就算能执行js脚本，Highcharts自带的exporting服务器肯定会把频繁的请求拒了，因此还得自己写exporting的后台，虽然官方给出了exporting server的示例代码。 出于这些考虑，我决定朝第2中方法努力。 phantomjsphantomjs是一个基于webkit的无界面浏览器，你可以通过javascript的语法去控制它。它与传统的爬虫不同，爬虫是直接对Http Response进行处理，只能获取所有的原始数据（包括DOM document和script），至于script执行后会对document产生怎样的改变，它不知道，只能自己写业务逻辑去处理。而phantomjs就是一个浏览器，它包含完整的渲染引擎和js执行器，它可以站在浏览器层面（而不是Http Response）去看待问题。因此phantomjs被主要用于网页截图，网络检测（Monitoring），以及界面测试（Testing）等。 一个最简单的demo 123456var page = require('webpage').create();var url = 'http://www.baidu.com/';page.open(url, function() &#123; page.render('baidu.png'); phantom.exit()&#125;); 截图效果 casperjscasperjs是对phantomjs的一个封装，提供了浏览器的多步访问，填写表单，点击事件，以及截图的自定义等。最重要的就是它的多步访问，提供了更好的异步操作，可避免callback的多层嵌套。 多步访问截图demo 123456789101112131415161718192021222324252627282930313233343536373839var casper = require('casper').create();var url = 'http://www.baidu.com/';casper.start(url, function() &#123; // 填写表单（搜索关键字） // 最后一个参数true表示submit this.fill('form#form1', &#123; wd: 'phantomjs' &#125;, true);&#125;);casper.then(function() &#123; this.viewport(1366, 768); // 注意：这里要等待结果刷新，百度搜索结果是异步刷出来的 this.waitFor(function check()&#123; return this.evaluate(function()&#123; return document.querySelectorAll('#content_left').length &gt; 0; &#125;); &#125;, function then()&#123; this.captureSelector('phantomjs.png', 'body'); &#125;);&#125;);casper.then(function() &#123; // 填写表单（搜索关键字） // 注意此时form id不同于之前 this.fill('form#form', &#123; wd: 'casperjs' &#125;, true);&#125;);casper.then(function() &#123; this.viewport(1366, 768); this.waitFor(function check()&#123; return this.evaluate(function()&#123; return document.querySelectorAll('#content_left').length &gt; 0; &#125;); &#125;, function then()&#123; this.captureSelector('casperjs.png', 'body'); &#125;);&#125;);casper.run(); 截图效果 回归正题我们有了REST API，通过casperjs去遍历访问url给以各种参数，并对页面中的Highchart截图。在实际的操作中需要注意的是 循环中的闭包（closure） 如果图表是异步加载，需要等待完再截图 部分示例代码如下 123456789101112131415161718192021222324// 省略……// categories是功能的分类数组// pages是对每个category下生成的合法url数组，即pages是url的二维数组casper.then(function()&#123; for(var i=0; i&lt;pages.length; i++)&#123; (function(that, category, urls)&#123; that.each(urls, function(self, link)&#123; var params = (link.split('?')[1]).split('&amp;'); // TODO: get params self.thenOpen(link, function()&#123; self.waitFor(function check()&#123; return self.evaluate(function()&#123; // TODO: 异步加载的判断 return true; &#125;); &#125;, function then()&#123; self.captureSelector(/from/to' + category + '/' + param + '.png', '#chart'); &#125;); &#125;); &#125;); &#125;)(this, categories[i], pages[i]); &#125;&#125;); 截图效果 总结我们使用了最低成本的方法实现了在移动端展示数据图表，都是基于PC端使用的Highcharts。省去了在移动端浏览器导入图表js库出现的兼容和性能问题，也省去了自己编写后台代码去生成图片。 利用phantomjs + casperjs的截图方法，经实验，生成的900 × 600像素的图片平均大小在20K左右，这个大小在移动端是可以接受的。如果一个页面中图片较多，我们还能写js对图片延迟加载（img的src属性延迟赋值）。唯一美中不足的是phantomjs对字体的效果不太好。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中集成Hibernate]]></title>
    <url>%2Fblog%2F2014%2F05%2Fintegrate-hibernate-into-eclipse.html</url>
    <content type="text"><![CDATA[前一阵子帮别人有偿做本科毕设的XX管理系统，对方要求一定要Java，不然他没学过不利于答辩。想我们大软院从大一开始就在做XX管理系统了，大二大三只是学的内容不一样，但大作业的载体都是该死的XX管理系统。从原生Java Swing做的靠文件读写数据的XX管理系统，到下学期加入数据库读写的，再过一学期用jsp做网页版的XX管理系统，然后再用J2EE框架，或者换php再实现一个XX管理系统。最后熬到坑爹的研究生，第一学期云计算课程先用传统方式实现一个XX管理系统，然后再把数据迁移到云平台上做实验。好吧，我错了，不知不觉又习惯喷了 其实我想说的是要不是看在同学的份上，真不想做这个事情，还要求Java，真不想碰Swing的东西了，也不想烦人的Struts。有人要网页版，我就用更简单易学的Play Framework（我都用较早的1.2.7版本）。而还有人要窗口程序，不得以去查了查简单的办法。 准备我用的是较早的eclipse 3.6.2 helios。对于Swing窗口程序的搭建，我使用了WindowBuilder插件，因为以前用过的VisualEditor貌似现在不维护了。 由于XX管理系统都涉及到增删改查操作，这种sql写起来就是纯粹苦力活。以前在MyEclipse中用过Struts + Hibernate（MyEclipse中均自带这些插件），但是苦于MyEclipse太大了，启动太慢，所以我想办法把Hibernate装到eclipse中。 Hibernate插件安装 打开eclipse -&gt; Help -&gt; Install New Software 添加 http://download.jboss.org/jbosstools/updates/stable/helios/ 选择All JBoss Tools下的Hibernate Tools即可（因为Hibernate被JBoss收了，只需装这一个就行） 漫长的等待 注意，有可能安装出错，我试了两三次才好（叹气） 最后这个关于unsigned的Warning无视之，直接OK后就安装成功了^_^ Hibernate ConfigHibernateTool安装完成后，可在eclipse中添加Hibernate perspective。 步骤1 将Hibernate核心jar包添加到project中，可到这里下载。 步骤2 在project的src根下添加名为hibernate.cfg.xml的文件，内容如下 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.connection.driver_class"&gt;org.gjt.mm.mysql.Driver&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123123&lt;/property&gt; &lt;!-- 指定数据库对应的schema（我用的是mysql） --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost/factory_manage&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt; &lt;!-- 下面这句很重要 --&gt; &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 下面为表的mapping项（已省略） --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 步骤3 打开Hibernate perspective，在该区域中右击添加configuration 这里的Type我选择了Annotations的方式 OK后就能在刚才的区域中看到数据库中的表了 步骤4 点击菜单栏中的这个图标，打开”Hibernate Code Generation Configurations”，我们新建一个Configuration。 注意要把“Reverse engineer from JDBC Connection”选项打开，这是Hibernate的反向工程。从数据库的表映射成实体类和配置文件，当然也可以从配置文件映射成数据库的表。 这里的Exporters我就勾选了前两项，一个是table对应的实体类，另一个则是mapping配置。而其他的如.cfg.xml和DAO code我准备都手工操作。因为这个code generation每次生成时会把以前的覆盖掉。 步骤5 运行Hibernate code generation，就会生成数据库factory_manage下所有表的映射。 步骤6 mapping文件（.hbm.xml）大可用生成的，只需要注意的是一对多和多对一映射时是否要lazy fetch（默认为true）。 最后记得将mapping文件的路径添加到hibernate.cfg.xml中！ Hibernate Session Factory创建一个hibernate的package，新建HibernateSessionFactory.java，内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package hibernate;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.cfg.Configuration;/** * Configures and provides access to Hibernate sessions, tied to the * current thread of execution. Follows the Thread Local Session * pattern, see &#123;@link http://hibernate.org/42.html &#125;. */public class HibernateSessionFactory &#123; /** * Location of hibernate.cfg.xml file. * Location should be on the classpath as Hibernate uses * #resourceAsStream style lookup for its configuration file. * The default classpath location of the hibernate config file is * in the default package. Use #setConfigFile() to update * the location of the configuration file for the current session. */ private static String CONFIG_FILE_LOCATION = "/hibernate.cfg.xml"; private static final ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;(); private static Configuration configuration = new Configuration(); private static org.hibernate.SessionFactory sessionFactory; private static String configFile = CONFIG_FILE_LOCATION; static &#123; try &#123; configuration.configure(configFile); sessionFactory = configuration.buildSessionFactory(); &#125; catch (Exception e) &#123; System.err .println("%%%% Error Creating SessionFactory %%%%"); e.printStackTrace(); &#125; &#125; private HibernateSessionFactory() &#123; &#125; /** * Returns the ThreadLocal Session instance. Lazy initialize * the &lt;code&gt;SessionFactory&lt;/code&gt; if needed. * * @return Session * @throws HibernateException */ public static Session getSession() throws HibernateException &#123; Session session = (Session) threadLocal.get(); if (session == null || !session.isOpen()) &#123; if (sessionFactory == null) &#123; rebuildSessionFactory(); &#125; session = (sessionFactory != null) ? sessionFactory.openSession() : null; threadLocal.set(session); &#125; return session; &#125; /** * Rebuild hibernate session factory * */ public static void rebuildSessionFactory() &#123; try &#123; configuration.configure(configFile); sessionFactory = configuration.buildSessionFactory(); &#125; catch (Exception e) &#123; System.err .println("%%%% Error Creating SessionFactory %%%%"); e.printStackTrace(); &#125; &#125; /** * Close the single hibernate session instance. * * @throws HibernateException */ public static void closeSession() throws HibernateException &#123; Session session = (Session) threadLocal.get(); threadLocal.set(null); if (session != null) &#123; session.close(); &#125; &#125; /** * return session factory * */ public static org.hibernate.SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; /** * return session factory * * session factory will be rebuilded in the next call */ public static void setConfigFile(String configFile) &#123; HibernateSessionFactory.configFile = configFile; sessionFactory = null; &#125; /** * return hibernate configuration * */ public static Configuration getConfiguration() &#123; return configuration; &#125;&#125; 注：这段代码是我以前在MyEclipse中用Hibernate时自动生成的，这里我不知道怎么生成，所以就直接复制了过来。 同样，再新建一个HibernateSessionFactoryUtil.java，内容如下。 123456789101112131415161718192021222324252627282930package hibernate.util;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateSessionFactoryUtil &#123; private static final SessionFactory sessionFactory; static &#123; try &#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; catch (Throwable e) &#123; /* * 需要捕获Throwable对象， * 否则捕获不到Error及其子类，以及NoClassDefFoundError类型的错误 */ throw new ExceptionInInitializerError(e); &#125; &#125; private HibernateSessionFactoryUtil()&#123;&#125; public static SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; &#125; DAO泛型编程创建dao.interfaces的package，新建GenericDao.java，内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package dao.interfaces;import java.io.Serializable;import java.util.ArrayList;public interface GenericDao&lt;T, PK extends Serializable&gt; &#123; /** * 根据主键取对象 * @param id 主键 * @return T 找不到时返回null */ public T findById(PK id); /** * 取出表中所有对象 * @return ArrayList */ public ArrayList&lt;T&gt; findAll(); /** * 存一个完整对象，并返回主键 * @param entity 完整对象 * @return PK 主键 */ public PK save(T entity); /** * 更新一个对象，主键找不到时改为存一个对象 * @param entity 完整对象 * @return boolean */ public boolean update(T entity); /** * 删除一个完整对象 * @param entity 完整对象 * @return boolean */ public boolean delete(T entity); /** * 根据主键删除一个对象 * @param id 主键 * @return boolean */ public boolean delete(PK id); &#125; 相应地，创建dao.hibernate的package，新建GenericDaoHibernate.java，内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package dao.hibernate;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.util.ArrayList;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import dao.interfaces.GenericDao;import hibernate.util.HibernateSessionFactoryUtil;public abstract class GenericDaoHibernate&lt;T, PK extends Serializable&gt; implements GenericDao&lt;T, PK&gt; &#123; private Class&lt;T&gt; clazz; public GenericDaoHibernate() &#123; //反射获取T.class，实参类型 clazz = (Class&lt;T&gt;)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]; &#125; @Override public T findById(PK id) &#123; T entity = null; try &#123; Session session = HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession(); Transaction tx = session.beginTransaction(); try &#123; entity = (T) session.get(clazz, id); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return entity; &#125; @Override public ArrayList&lt;T&gt; findAll() &#123; ArrayList&lt;T&gt; result = new ArrayList&lt;T&gt;(); try &#123; Session session = HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession(); Transaction tx = session.beginTransaction(); try &#123; Query query = session.createQuery("from " + clazz.getName()); result = new ArrayList&lt;T&gt;(query.list()); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override public PK save(T entity) &#123; //boolean result = false; PK result = null; try &#123; Session session = HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession(); Transaction tx = session.beginTransaction(); try &#123; //result = true; result = (PK) session.save(entity); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override public boolean update(T entity) &#123; boolean result = false; try &#123; Session session = HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession(); Transaction tx = session.beginTransaction(); try &#123; session.saveOrUpdate(entity); result = true; tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override public boolean delete(T entity) &#123; boolean result = false; try &#123; Session session = HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession(); Transaction tx = session.beginTransaction(); try &#123; session.delete(entity); result = true; tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override /** * 此法不好，暂时这样 */ public boolean delete(PK id) &#123; boolean result = false; try &#123; T entity = findById(id); if(entity!=null &amp;&amp; delete(entity)==true) result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; &#125; 有了GenericDao的基础，对于其他具体实体类，我们只需要定义一个它的接口类去继承GenericDao，像这样 public interface UserDao extends GenericDao&lt;User, Integer&gt; 在这里定义它的特有方法 对于接口的实现类，像这样 public class UserDaoHibernate extends GenericDaoHibernate&lt;User, Integer&gt; implements UserDao 因此有了泛型DAO，就不必为每个实体都写一套大同小异的最基础的增删改查操作了。 总结在eclipse中集成HibernateTools后，可以先在数据库中建好table，然后通过Hibernate的Reverse Engineering映射成对应的实体类和配置文件。通过建立泛型DAO接口和实现类，不必为具体每个实体类编写诸如getById的方法。Mapping和DAO泛型编程，大大减少了基于增删改查的XX管理系统的开发工作量。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大姨夫烦躁之后]]></title>
    <url>%2Fblog%2F2014%2F03%2Flife-is-like-a-boat.html</url>
    <content type="text"><![CDATA[男人每个月也总有那么几天浑身不舒服，我们把这几天称为“大姨夫来了”，老郭说陪大姨夫喝酒喝多了…… 上周去了4次驾校，每天6点多起，谁叫我报了个这么严的驾校，我说4次我都是去为了科目一的，会不会被嘲讽啊。。。。 这一周过的又压力好大，接了几个超出我正常能力之外的事。先是老板每周的研讨班，只不过这周组织了次4个院系的大讨论，好产生思维冲击。我都不好意思说我做的项目是电商数据分析，因为我商业方面的也不懂，分析方面的更不懂。老板要我们组出两个PPT，钱大神负责开放数据平台的报告，由于冯总太忙，项目面向商业的报告就让我来做。我这人最怕在人多的地方发言或报告了，只要有生人，我就会紧张。花了一天半时间才憋出了一份高端大气的商务风PPT，正文才9页，估计我的效率又要被鄙视了。。。本来又想推给冯总去报告了，想想我都花了那么多心思去做PPT了，不讲我不是亏了么。 怕，你就会输一辈子。 这是电影《激战》的宣传语，我很喜欢。刚开始讲的时候真的紧张了，电脑蓝屏=_= 还把项目说成了网站项目（就因为我是做网站的么= =），被问到技术方面的问题都让队友帮我回答。。。 不上台溜溜，你永远不会知道自己有多强（有多弱） 最早是在一条健身微博上看到这样的话，说你一直躲在健身房练而不去参加比赛的话，你永远不会知道自己和别人的差距。健身方面我还真操蛋的是这样。。。技术方面远不如钱大神，商业方面不如冯总。我就是个做网站的，最多站在用户角度去思考些。 又一波大姨夫一同学来找我，想让我帮他和他女朋友搞定毕设，说给报酬，还说除了我没人帮得了他了。我们初中高中都一起的，想想他当年操蛋的去复读结果还是个三本，不然也不会这个时候再来找我。幸亏不是一届，而且三本应该会比较松，受到金钱诱惑，我帮他做起了毕设的生意。另加两个他关系好的同学，总共4份，我居然操蛋的答应了。我又得重拾大二大三时做的Java Swing，Socket，Hibernate等东西了，已经两三年不碰那些东西了。而且他们有时间要求的，其实还是有点压力的。 柳暗花明下面是今早去驾校考科目一后看到的，才发现原来没看到的景色，可以心理安慰没白早起了。 这可能是梅花吧，我也不太懂，只有这么两颗。 一个人安静的从那条路走出来，看着这样的景，听着Eason的歌，脑中放空任它胡思乱想，居然在驾校也能产生这样的放松境界。这是我最喜欢的放松状态 关于追求上大学前的追求是考个好大学，真的考上好大学后，却变得没啥追求了。想想自己本科阶段基本都在照本宣科，也不会业余时间自己去琢磨某种技术，最多照着example自己敲一遍代码，从来不会去做些自己觉得好玩的东西。好处是轻松的保研了，操蛋的是到了研究生阶段才有了觉悟，才决定了以后干javascript，才开始搞博客。 技术上我没啥追求，做个普通的合格的程序员即可，我觉得自己真的不喜欢写代码，连设计博客首页的布局代码都不想写。我以前就说，相比写代码，我更喜欢写文字（包括文档）。 生活上的追求也很简单，有份稳稳的幸福。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之五-代码复用模式]]></title>
    <url>%2Fblog%2F2014%2F03%2Fjs-pattern-part5-code-reuse-pattern.html</url>
    <content type="text"><![CDATA[类式继承示例 123456789function Parent(name)&#123; this.name = name || 'Adam';&#125;Parent.prototype.say = function()&#123; return this.name;&#125;function Child(name)&#123;&#125;inherit(Child, Parent); 阶段1 - 默认模式123function inherit(C, P)&#123; C.prototype = new P();&#125; 缺点：无法继承父对象自身的属性（如上例中的name）。 阶段2 - 借用构造函数123function Child(name)&#123; Parent.apply(this, arguments);&#125; 缺点：只能继承在父构造函数中添加到this的属性。同时并不能继承那些已添加到原型中的成员。优点：不会存在子对象意外覆盖父对象属性的风险。 阶段3 - 借用和设置原型1234function Child(name)&#123; Parent.apply(this, arguments);&#125;Child.prototype = new Parent(); 缺点：父构造函数被调用了两次；自身的属性会被继承两次。 阶段4 - 共享原型123function inherit(C, P)&#123; C.prototype = P.prototype;&#125; 本模式的经验法则在于：可复用成员应该转移到原型中而不是放置在this中。因此，出于继承的目的，任何值得继承的东西都应该放置在原型中实现。 阶段5 - 临时构造函数12345function inherit(C, P)&#123; var F = function()&#123;&#125;; F.prototype = P.prototype; C.prototype = new F();&#125; 这种模式与阶段1略有不同，这是由于这里的子对象仅继承了原型的属性。这种情况通常来说是很好的，实际上也是更加可取的，因为原型也正是放置可复用功能的位置。在这种模式下，父构造函数添加到this中的任何成员都不会被继承。 阶段6 - 圣杯1234567function inherit(C, P)&#123; var F = function()&#123;&#125;; F.prototype = P.prototype; C.prototype = new F(); C.parent = P.prototype; C.prototype.constructor = C;&#125; 这种模式也被称为使用代理函数或代理构造函数的模式，而不是使用临时构造函数的模式，这是因为临时构造函数实际上是一个用于获得父对象原型的代理。 对该圣杯模式的一个常见优化是避免在每次需要继承时都创建临时（代理）构造函数。仅创建一次临时构造函数，并且修改它的原型，这已经是非常充分的。 123456789var inherit = (function()&#123; var F = function()&#123;&#125;; return function(C, P)&#123; F.prototype = P.prototype; C.prototype = new F(); C.parent = P.prototype; C.prototype.constructor = C; &#125;&#125;()); 阶段7 - Klass特点： 有一套有关如何命名类方法的公约，这也被认为是类的构造函数，比如initialize、_init以及一些其他类似的构造函数名，并且在创建对象时这些方法将会被自动调用。 存在从其他类所继承的类 在子类中可以访问父类或超类 使用示例 12345678910111213141516171819202122var Man = Klass(null, &#123; __construct: function(what)&#123; console.log('constructor of Man'); this.name = what; &#125;, getName: function()&#123; return this.name; &#125;&#125;);var Batman = Klass(Man, &#123; __construct: function(what)&#123; console.log('constructor of Batman'); &#125;, getName: function()&#123; var name = Batman.parent.getName.call(this); return 'I am ' + name; &#125;&#125;);var bruce= new Batman('Bruce Wayne'); //控制台第一行输出'constructor of Man'，然后输出'constructor of Batman'bruce.getName(); //output: I am Bruce Wayne 每次在调用子类的构造函数时，父类的构造函数也将会被自动调用。 12bruce instanceof Man; //truebruce instanceof Batman; //true 具体实现 1234567891011121314151617181920212223242526272829var Klass = function(Parent, props)&#123; //1. 新构造函数 var Child = function()&#123; if(Child.parent &amp;&amp; Child.parent.hasOwnProperty('__construct'))&#123; Child.parent.__construct.apply(this, arguments); &#125; if(Child.prototype.hasOwnProperty('__construct'))&#123; Child.prototype.__construct.apply(this, arguments); &#125; &#125;; //2. 继承 Parent = Parent || Object; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.parent = Parent.prototype; Child.prototype.constructor = Child; //3. 添加实现方法 for(var i in props)&#123; if(props.hasOwnProperty(i))&#123; Child.prototype[i] = props[i]; &#125; &#125; //返回该class return Child;&#125;; 说明：创建了Child()构造函数，该函数将是最后返回的，并且该函数也用作类。在这个函数中，如果存在__construct方法，那么将会调用该方法。另外，在此之前，通过使用静态parent属性，其父类的__construct方法如果存在的话也会被自动调用。可能在有些情况下，当没有定义parent属性时，比如直接从Object类中继承时，这与从Man类的定义中继承是相似的情况。 原型继承原型继承是一种“现代”无类继承模式，不涉及类，这个的对象都是继承自其他对象。以这种方式考虑：有一个想要复用的对象，并且想创建的第二个对象需要从第一个对象中获取其功能。 使用示例 12345var parent = &#123; name: 'papa'&#125;;var child = object(parent);alert(child.name); //output: papa 具体实现 12345function object(o)&#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 讨论 在原型继承模式中，并不需要使用字面量来创建父对象（尽管这是一种比较常见的方式）。也可以使用构造函数来创建父对象，但请注意，如果这样做的话，自身（this）属性和原型属性都将被继承。 在本模式的另外一个变化中，可以选择仅继承现有构造函数的原型对象。请记住，对象继承自对象，而不论父对象是如何创建的。 1var kid = object(Person.prototype); 在ES5中，原型继承模式已经正式成为该语言的一部分。这种模式是通过方法Object.create()来实现的。也就是说，不需要推出与object()相类似的函数，它已经内嵌在该语言中。 1var child = Object.create(parent); Object.create()接受一个额外的参数，即一个对象。这个额外对象的属性将会被添加到新对象中，以此作为新对象自身的属性，然后Object.create()返回该新对象。这提供了很大的方便，使你可以仅采用一个方法调用即可实现继承并在此基础上构建子对象。 123var child = Object.create(parent, &#123; age: &#123; value: 22 &#125; //ECMA5描述符号&#125;); 通过复制属性实现继承浅复制 123456789function extend(parent, child)&#123; child = child || &#123;&#125;; for(var i in parent)&#123; if(parent.hasOwnProperty(i))&#123; child[i] = parent[i]; &#125; &#125; return child;&#125; 深复制 123456789101112131415161718function extendDeep(parent, child)&#123; var toString = Object.prototype.toString; var astr = '[object Array]'; child = child || &#123;&#125;; for(var i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i] === 'object')&#123; child[i] = (toString.call(parent[i]) === astr) ? [] : &#123;&#125;; extendDeep(parent[i], child[i]); &#125; else&#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125; 这种属性复制模式比较简单且得到了广泛运用。例如，Firebug（使用Javascript编写的Firefox扩展插件）中具有一个名为extend()的方法，该方法就可以实现浅复制，而jquery库中的extend()则可创建深度复制的副本。值得注意的是，在本模式中根本没有涉及任何原型，本模式仅与对象以及它们自身的属性相关。 混入可以针对这种通过属性复制实现继承的思想做进一步的扩展，就有了mix-in（混入）模式。mix-in模式并不是复制一个完整的对象，而是从多个对象中复制出任意的成员并将这些成员组合成一个新对象。 mix-in实现比较简单，只需遍历每个参数，并且复制出传递给该函数的每个对象中的每个属性。可以向它传递任意数量的对象，其结果将获得一个具有所有源对象属性的新对象。 1234567891011function mixin()&#123; var child = &#123;&#125;; for(var arg=0; arg&lt;arguments.length; arg++)&#123; for(var prop in arguments[arg])&#123; if(arguments[arg].hasOwnProperty(prop))&#123; child[prop] = arguments[arg][prop]; &#125; &#125; &#125; return child;&#125; 借用和绑定12345function bind(o, m)&#123; return function()&#123; return m.apply(o, [].slice.call(arguments)); &#125;;&#125; ES5中将bind()方法添加到Function.prototype，使得bind()就像apply()和call()一样简单易用。 1234567891011if(typeof Function.prototype.bind === 'undefined')&#123; Function.prototype.bind = function(thisArg)&#123; var fn = this; var slice = Array.prototype.slice; var args = slice.call(arguments, 1); return function()&#123; return fn.apply(thisArg, args.concat(slice.call(arguments))); &#125;; &#125;;&#125; 这个实现可能看起来有点熟悉，它使用了部分应用并拼接了参数列表，即那些传递给bind()的参数（除了第一个以外），以及那些传递给由bind()所返回的新函数的参数，其中该新函数将在以后被调用。 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之四-对象创建模式]]></title>
    <url>%2Fblog%2F2014%2F03%2Fjs-pattern-part4-object-creation-pattern.html</url>
    <content type="text"><![CDATA[命名空间模式1234567891011121314151617181920212223var MYAPP = MYAPP || &#123;&#125;;MYAPP.namespace = function(ns_string)&#123; var parts = ns_string.split('.'); var parent = MYAPP; //剥离最前面的冗余全局变量 if(parts[0] === 'MYAPP')&#123; parts = parts.slice(1); &#125; for(var i=0; i&lt;parts.length; i++)&#123; //如果它不存在，就创建一个属性 if(typeof parent[parts[i]] === 'undefined')&#123; parent[parts[i]] = &#123;&#125;; &#125; parent = parent[parts[i]]; &#125; return parent;&#125;;//使用var module2 = MYAPP.namespace('MYAPP.modules.module2');module2 === MYAPP.modules.module2; //true 模块模式123456789101112131415161718192021222324MYAPP.namespace('MYAPP.utilities.array');MYAPP.utilities.array = (function()&#123; //依赖 var uobj = MYAPP.utilities.object; var ulang = MYAPP.utilities.lang; //私有属性 var array_string = '[object Array]'; var ops = Object.prototype.toString; //私有方法 //... //可选的一次性初始化过程 //... //公有API return &#123; isArray: function(a)&#123; return ops.call(a) === array_string; &#125;, //更多方法和属性... &#125;;&#125;()); 模块模式的变体揭示模块模式：所有的方法都需要保持私有性，并且只能暴露那些最后决定设立API的那些方法。创建构造函数的模块：包装了模块的即时函数最终将会返回一个函数，而不是返回一个对象。将全局变量导入到模块中：将全局变量以参数的形式传递到包装了模块的即时函数中。 沙箱模式沙箱模式提供了一个可用于模块运行的环境，且不会对其他模块和个人沙箱造成任何影响。在命名空间模式中，有一个全局对象。在沙箱模式中，则是一个全局构造函数，让我们称之为Sandbox()。可以使用该构造函数创建对象并且还可以传递回调函数，它变成了代码的隔离沙箱运行环境。 使用示例 12345678910Sandbox(['dom', 'event'], function(box)&#123; //使用DOM和事件来运行... Sandbox('ajax', function(box)&#123; //另一个沙箱 //使用Ajax来处理... &#125;); //这里没有Ajax模块&#125;); 使用本沙箱模式时，可以通过将代码包装到回调函数中从而保护全局命名空间。可以根据所需要的模块类型创建不同的沙箱实例，并且这些实例互相独立运行。 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Sandbox()&#123; //将参数转换成一个数组 var args = Array.prototype.slice.call(arguments); //最后一个参数是回调函数 var callback = args.pop(); //模块可以作为一个数组传递，或作为单独的参数传递 var modules = (args[0] &amp;&amp; typeof args[0] === 'string') ? args : args[0]; //确保该函数作为够咱函数被调用 //参见"Javascript模式之二"中的"强制使用new模式" if(!(this instanceof Sandbox))&#123; return new Sandbox(modules, callback); &#125; //需要向this添加的属性 //example this.a = 1; this.b = 2; //现在向该核心this对象添加模块 //不指定模块名称或制定'*'，都表示使用所有模块 if(!modules || modules === '*')&#123; modules = []; for(i in Sandbox.modules)&#123; if(Sandbox.modules.hasOwnProperty(i))&#123; modules.push(i); &#125; &#125; &#125; //初始化所需的模块 for(var i=0; i&lt;modules.length; i++)&#123; Sandbox.modules[modules[i]](this); &#125; //回调 //注：改变的是this即回调函数的参数box所拥有的属性和方法 callback(this);&#125;//需要的任何原型属性Sandbox.prototype = &#123; name: 'My Application', version: '1.0', getName: function()&#123; return this.name; &#125;&#125;;//添加模块Sandbox.modules = &#123;&#125;;Sandbox.modules.dom = function(box)&#123; box.getElement = function()&#123;&#125;; box.getStyle = function()&#123;&#125;; box.foo = 'bar';&#125;;Sandbox.modules.event = function(box)&#123; //如果需要，就访问Sandbox原型，如下语句 //box.constructor.prototype.m = 'mmm'; box.attachEvent = function()&#123;&#125;; box.dettachEvent = function()&#123;&#125;;&#125;;Sandbox.modules.ajax = function(box)&#123; box.makeRequest = function()&#123;&#125;; box.getResponse = function()&#123;&#125;;&#125;; 在这个示例实现中，我们并不关心从其他文件中加载所需的功能，但这绝对也是一个可选的实现功能。比如YUI3库中就支持这种功能。当我们知道所需的模块时，便可以据此进行初始化，这表示可以调用实现每个模块的函数。该构造函数的最后一个参数是一个回调函数。该回调函数将会在使用新创建的实例时最后被调用。这个回调函数实际上是用户的沙箱，它可以获得一个填充了所需功能的box对象。 我觉得沙箱模式的缺点是Sandbox.modules暴露在外，应该使用更好的AMD(Asynchronous Module Definition)模式 链模式链模式的优点在于它可以帮助你考虑分割函数，以创建更加简短、具有特定功能的函数，而不是创建尝试实现太多功能的函数。从长远看来，这提高了代码的可维护性。链模式的缺点在于以这种方式编写的代码更加难以调试。或许知道在某个特定的代码行中发生错误，但是在此行中实际执行了太多的步骤。当链中多个方法的其中一个静默失效时，无法知道是哪一个方法发生失效。在任何情况下，识别出这种模式都很有好处。当编写的方法并没有明显和有意义的返回值时，可以总是返回this。 method()方法思想（并不是很推荐） example. 12345678910111213var Person = function(name)&#123; this.name = name;&#125;. method('getName', function()&#123; return this.name; &#125;). method('setName', function(name)&#123; this.name = name; return this; &#125;);var a = new Person('Adam');a.setName('Eve').getName(); method()方法实现 123456if(typeof Function.prototype.method !== 'function')&#123; Function.prototype.method = function(name, implementation)&#123; this.prototype[name] = implementation; return this. &#125;&#125; 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之三-函数]]></title>
    <url>%2Fblog%2F2014%2F02%2Fjs-pattern-part3-function.html</url>
    <content type="text"><![CDATA[背景Javascript中函数有两个重要特征。第一，函数是第一类对象（first-class object），可以作为带有属性和方法的值以及参数进行传递。第二，函数提供了局部作用域。Javascript中仅存在函数作用域，花括号{}并不提供局部作用域，因此如果在if条件语句或在for以及while循环中，使用var关键字定义一个变量，这并不意味着该变量对于if或for来说是局部变量。它仅对于包装函数来说是局部变量，并且如果没有包装函数，它将称为一个全局变量。此外，函数中声明的局部变量可被提升到局部作用域的顶部。 函数创建方式1、命名函数表达式。 1var add = function add(a, b)&#123;...&#125;; 注：不要将命名函数表达式分配给一个具有不同名称的变量，因为可能在某些浏览器下不支持。如var foo = function bar(){}; 2、函数表达式。与上面的相同，但缺少一个名字，通常也称为匿名函数。 1var add = function(a, b)&#123;...&#125;; 唯一的区别在于该函数对象的name属性将会成为一个空字符串或undefined。name属性是Javascript语言的一个扩展（它并不是ECMA标准的一部分），可用于debug时错误定位，也可用于在自身内部递归调用同一个函数。 3、函数声明。 1function foo()&#123;...&#125; 就语法而言，命名函数表达式与函数声明看起来很相似，尤其是如果不将函数表达式的结果分配给变量。在尾随的分号中，这两者之间存在语法差异。函数声明中并不需要分号结尾，但在函数表达式中需要分号，并且应该总是使用分号（在压缩js文件时会出问题）。 函数的提升对于所有变量，无论在函数体的何处进行声明，都会在后台被提升到函数顶部。而这对于函数同样适用，其原因在于函数只是分配给变量的对象。当使用函数声明时，函数定义也被提升，而不仅仅是函数声明被提升。 example. 123456789101112131415161718function hoistMe()&#123; console.log(typeof foo); //output: function console.log(typeof bar); //output: undefined foo(); //output: local foo bar(); //output: TypeError: bar is not a function //函数声明，变量'foo'及其实现都被提升 function foo()&#123; alert('local foo'); &#125; //函数表达式，仅变量'bar'被提升，函数实现并未被提升 var bar = function()&#123; alert('local bar'); &#125;;&#125;hoistMe(); API模式-回调模式example.普通写法 12345678910111213141516171819var findNodes = function()&#123; var i = 100000; var nodes = []; var found; while(i--)&#123; //复杂逻辑... nodes.push(found); &#125; return nodes;&#125;;var hide = function(nodes)&#123; for(var i=0, max=nodes.length; i&lt;max; i++)&#123; nodes[i].style.display = 'none'; &#125;&#125;;//执行函数hide(findNodes()); 实现低效，因为hide()必须再次遍历由findNodes()所返回的数组节点。如果在findNodes()中实现hide逻辑，由于检索和修改逻辑耦合，那么它不再是一个通用函数。对这种问题的解决办法是采用回调模式。 example.回调模式 123456789101112131415161718192021222324var findNodes = function(callback)&#123; var i = 100000; var nodes = []; var found; //检查回调函数是否为可调用的 if(typeof callback !== 'function')&#123; callback = false; &#125; while(i--)&#123; //复杂逻辑... if(callback)&#123; callback(found); &#125; nodes.push(found); &#125; return nodes;&#125;;//执行函数findNodes(function(node)&#123; node.style.display = 'none';&#125;); 注：回调函数可以是一个已有的函数，也可以是一个匿名函数，可以在调用主函数时创建它。 虽然在许多情况下这种方法都是简单而且有效的，但经常存在一些场景，其回调并不是一次性的匿名函数或全局函数，而是对象的方法。如果该回调方法使用this来引用它所属的对象，就会导致问题。解决办法是传递回调函数，并且另外还传递该回调函数所属的对象。 example. 12345678910var findNodes = function(callback, callback_obj)&#123; //... if(typeof callback === 'string')&#123; callback = callback_obj[callback]; &#125; if(typeof callback === 'function')&#123; callback.call(callback_obj, found); &#125; //...&#125;; API模式-配置对象将函数参数包装成一个对象，如addPerson(param)配置对象的优点在于：不需要记住众多的参数以及其顺序；可以安全忽略可选参数；易于阅读和维护；易于添加和删除参数。配置对象的不利之处在于：需要记住参数名称；属性名称无法被压缩。 API模式-返回函数123456789var setup = function()&#123; var count = 0; return function()&#123; return (count += 1); &#125;;&#125;;var next = setup();next(); //returns: 1next(); //returns: 2 由于setup()包装了返回函数，它创建了一个闭包，可以使用这个闭包存储一些私有数据，而这些数据仅可被该返回函数访问，但外部代码却无法访问。 API模式-Curry化例子，有function add(a, b){...} 函数应用：add.apply(null, [1, 2]); 部分应用：(add.apply(null, [1]))(2); 注：部分应用中，add.apply(null, [1])仅应用了第一个参数，当执行部分应用时，并不会获得具体结果，而是会获得另一个函数，随后再以其他参数调用该返回函数。这种运行方式实际上与add(1)(2)有些相似，这是由于add(1)返回了一个可在后来用(2)来调用的函数。 example. 12345678910function add(x, y)&#123; if(typeof y === 'undefined')&#123; //部分应用 return function(y)&#123; return x + y; &#125;; &#125; //完全应用 return x + y;&#125; 使函数理解并处理部分应用的过程就称为Curry过程。 example.通用Curry化函数 123456789function schonfinkelize(fn)&#123; var slice = Array.prototype.slice; var stored_args = slice.call(arguments, 1); return function()&#123; var new_args = slice.call(arguments); var args = stored_args.concat(new_args); return fn.apply(null, args); &#125;;&#125; 注：Javascript中arguments并不是一个真实的数组，从Array.prototype中借用slice()方法可以帮助我们将arguments变成一个数组，并且使用该数组工作更加方便。 123456789//普通函数function add(x, y)&#123; return x + y;&#125;//将一个函数Curry化以获得一个新的函数var newadd = schonfinkelize(add, 1);newadd(2); //returns: 3//等价于 schonfinkelize(add, 1)(2); 转换函数schonfinkelize()并不局限于单个参数或者单步Curry化。当发现正在调用同一个函数，并且传递的参数绝大多数都是相同的，那么该函数可能是用于Curry化的一个很好的候选参数。可以通过将一个函数集合部分应用到函数中，从而动态创建一个新函数。这个新函数将会保存重复的参数（因此不必每次都传递这些参数），并且还会使用预填充原始函数所期望的完整参数列表。 初始化模式-即时函数即时函数模式是一种可以支持在定义函数后立即执行该函数的语法。(function(){...}()); 或 (function(){...})();这种模式非常有用，因为它为初始化代码提供了一个作用域沙箱，不会污染全局变量。 一般情况下，全局对象是以参数方式传递给即时函数的，这样将使得代码在浏览器环境之外时具有更好的互操作性。 123(function(global)&#123; //通过'global'访问全局变量&#125;(this)); 一般来说，不应该传递过多的参数到即时函数中。 正如任何其他函数一样，即时函数可以返回值，并且这些返回值也可以分配给变量。即时函数模式得到了广泛的使用，它可以帮助包装许多想要执行的工作，且不会在后台留下任何全局变量。该模式还支持将个别功能包装在自包含模块中。 初始化模式-即时对象初始化example. 12345678(&#123; width: 600, height: 400, getXXX: function()&#123;...&#125;, init: function()&#123; //更多初始化任务... &#125;&#125;).init(); 注：如果想在init()完毕之后保存对该对象的一个引用，可以通过在init()尾部添加return this;语句来实现该功能。 就语法而言，这种模式就像在使用对象字面量创建一个普通的对象。将字面量包装到括号中（分组操作符），它指示Javascript引擎将大括号作为对象字面量，而不是作为一个代码块。在结束该括号之后，可以立即调用init()方法。({...}).init(); 或 ({...}.init());这种模式的优点与即时函数模式的优点是相同的，可以在执行一次性的初始化任务时保护全局命名空间。 初始化模式-初始化时分支初始化时分支，也称为加载时分支，是一种优化模式。当知道某个条件在整个程序生命周期内都不会发生改变的时候，仅对该条件测试一次是很有意义的。浏览器嗅探（或功能检测）就是一个典型的例子。 性能模式-备忘模式函数是对象，因此它们具有属性。事实上，它们确实还有属性和方法。例如，对于每一个函数，无论使用什么样的语法来创建它，它都会自动获得一个length属性，其中包含了该函数期望的参数数量。可以在任何时候将自定义属性添加到你的函数中。自定义属性的其中一个用例是缓存函数返回值，也被称为备忘。 example. 123456789var myFunc = function(param)&#123; if(!myFunc.cache[param])&#123; var result = &#123;&#125;; //开销很大的操作... myFunc.cache[param] = result; &#125; return myFunc.cache[param];&#125;;myFunc.cache = &#123;&#125;; 上述代码假定该函数只需要一个参数param，并且它是一个基本数据类型。如果有更多更复杂的参数，对此的通用解决方案是将它们序列化。例如，可以将参数对象序列化为一个JSON字符串，并使用该字符串作为cache对象的键。 1var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)); 注意：在序列化过程中，对象的“标识”将会丢失。如果有两个不同的对象并且恰好都具有相同的属性，则它们序列化后的结果相同。 性能模式-自定义函数example. 12345678var scareMe = function()&#123; alert('Boo!'); scareMe = function()&#123; alert('Double boo!')； &#125;;&#125;;scareMe(); //output: Boo!scareMe(); //output: Double boo! 当你的函数有一些初始化准备工作要做，并且仅需要执行一次，那么这种模式就非常有用。因为并没有任何理由去执行本可以避免的重复工作，即函数的一些部分可能并不再需要。在这种情况下，自定义函数可以更新自身的实现。这种模式的另一个名称是“惰性函数定义”（lazy function definition），因为该函数直到第一次使用时才被正确地定义，并且具有后向惰性，执行了更少的工作。该模式的其中一个缺点在于，当它重定义自身时，已经添加到原始函数的任何属性都会丢失。此外，如果该函数使用了不同的名称，比如分配给不同的变量或者以对象的方法来使用，那么重定义部分将永远不会发生，并且将会执行原始函数体。 example.接上 1234567891011121314151617181920212223//1、添加一个新的属性scareMe.property = 'properly';//2、赋值给另一个不同名称的变量var prank = scareMe;//3、作为一个方法使用var spooky = &#123; boo: scareMe&#125;;//calling with a new nameprank(); //output: Boo!prank(); //output: Boo!console.log(prank.property); //output: properly//作为一个方法来调用spooky.boo(); //output: Boo!spooky.boo(); //output: Boo!console.log(spooky.boo.property); //output: properly//使用自定义函数scareMe(); //output: Double boo!scareMe(); //output: Double boo!console.log(scareMe.property); //output: undefined 正如看到的，当将该函数分配给一个新的变量时，函数的自定义并没有发生。每次当调用prank()时，它都通知’Boo!’消息，同时它还覆盖了全局scareMe()函数，但是prank()自身保持了可见旧函数，其中还包括属性。当该函数以spooky对象的boo()方法使用时，也发生了同样的情况。所有这些调用不断地重写全局scareMe()指针，以至于当它最终被调用时，它才第一次具有更新函数主体并通知’Double boo!’消息的权利。此外，它也不能访问scareMe.property属性。 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之二-字面量和构造函数]]></title>
    <url>%2Fblog%2F2014%2F02%2Fjs-pattern-part2-literal-and-constructor.html</url>
    <content type="text"><![CDATA[对象创建方式对象字面量：这是一种优美的对象创建方式，它以包装在大括号中的逗号分割的键-值（key-value）对的方式创建对象。构造函数：主要包括内置构造函数（几乎总是有一个更好且更短的字面量表示法）和自定义构造函数。 example. 12345//使用字面量var car = &#123;goes: 'far'&#125;;//使用内置构造函数（反模式）var car = new Object();car.goes = 'far'; 优先选择字面量模式创建对象的另一个原因在于它强调了该对象仅是一个可变哈希映射，而不是从对象中提取的属性或方法。与使用Object构造函数相对，使用字面量的另一个原因在于它并没有作用域解析。因为可能以同样的名字创建了一个局部构造函数，解释器需要从调用Object()的位置开始一直向上查询作用域链，直到发现全局Object构造函数。 Object()构造函数仅接受一个参数，并且还依赖传递的值，该Object()可能会委派另一个内置构造函数来创建对象，并且返回了一个并非期望的不同对象。当传递给Object()构造函数的值是动态的，并且直到运行时才能确定其类型时，Object()构造函数的这种行为可能会导致意料不到的结果。因此，不要使用new Object()构造函数，相反应该使用更为简单、可靠的对象字面量模式。 自定义构造函数123456var Person = function(name)&#123; this.name = name; this.say = function()&#123; return 'I am ' + this.name; &#125;;&#125;; 当以new操作符调用构造函数时，函数内部将会发生以下情况： 创建一个空对象并且this变量引用了该对象，同时还继承了该函数的原型。 属性和方法被加入到this引用的对象中。 新创建的对象由this所引用，并且最后隐式地返回this（如果没有显式地返回其它对象）。 以上情况看起来就像是在后台发生了如下事情： 12345678910var Person = function(name)&#123; //使用对象字面量创建一个新对象 //var this = &#123;&#125;; //向this添加属性和方法 this.name = name; this.say = function()&#123; return 'I am ' + this.name; &#125;; //return this;&#125;; 在本例中，将say()方法添加到this中，其造成的结果是在任何时候调用new Person()时都会在内存中创建一个新的函数。这种方法显然是低效的，因为多个实例之间的say()方法实际上并没有改变。更好的选择应该是将方法添加到Person类的原型中。可重用的成员，比如可重用的方法，都应该放置到对象的原型中。 本例中，var this = {};并不是真相的全部，因为“空”对象实际上并不空，它已经从Person的原型中继承了许多成员。因此，它更像是下面的语句： 1var this = Object.create(Person.prototype); 注意，构造函数将隐式地返回this，甚至于在函数中没有显式地加入return语句。但是，可以根据需要返回任意其他对象。 强制使用new的模式在调用构造函数时如果忘记使用new操作符，将导致构造函数中的this指向了全局对象（在浏览器中，this将会指向window）。 example. 1234567function Waffle()&#123; this.tastes = 'yummy';&#125;//反模式：忘记使用new操作符var mm = Waffle();console.log(typeof mm); //output: undefinedconsole.log(window.tastes); //output: yummy 上面的这种意外行为在ECMAScript 5中得到了解决，并且在strict模式中，this不会指向全局对象。 方案1：使用that 12345function Waffle()&#123; var that = &#123;&#125;; that.tastes = 'yummy'; return that;&#125; 这种模式的问题在于它会丢失到原型的链接，因此任何添加到Waffle()原型的成员，对于对象来说都是不可用的。 方案2：自调用构造函数 可以在构造函数中检查this是否为构造函数的一个实例，如果为否，构造函数可以再次调用自身，并且在这次调用中正确地使用new操作符。 example. 1234567891011121314function Waffle()&#123; if(!(this instanceof Waffle))&#123; return new Waffle(); &#125; this.tastes = 'yummy';&#125;Waffle.prototype.wantAnother = true;var first = new Waffle();var second = Waffle();console.log(first.tastes); //output: yummyconsole.log(second.tastes); //output: yummyconsole.log(first.wantAnother); //output: trueconsole.log(second.wantAnother); //output: true 另一种用于检测实例对象的通用方法是将其与arguments.callee进行比较，而不是在代码中硬编码构造函数名称。 123if(!(this instanceof arguments.callee))&#123; return new arguments.callee();&#125; 注：在ES5的strict模式中并不支持arguments.callee属性。 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模式之一-基本技巧]]></title>
    <url>%2Fblog%2F2014%2F02%2Fjs-pattern-part1-basic-tricks.html</url>
    <content type="text"><![CDATA[基本概念-面向对象Javascript是一门面向对象的语言。只有五种基本类型不是对象：数值类型、字符串类型、布尔类型、空类型和未定义类型。其中前三个类型有对应的以基本类型封装形式体现的对象表示。 在JavaScript中，一旦定义好了变量，同时也就已经正在处理对象了。首先，该变量会自动成为内置对象的一个属性，成为激活对象（如果该变量是一个全局变量，那么该变量会成为全局对象的一个属性）。第二，该变量实际上也是伪类，因为它拥有其自身的属性（称为attributes），该属性决定了该变量是否可以被修改、被删除和在一个for-in循环中进行枚举。这些属性在ECMAScript3中没有直接对外提供，但在第5版本的ECMAScript中，提供了一个特殊的描述符方法来操纵这些属性。 函数实际上也是对象，函数有属性和方法。一个对象仅仅是一个容器，该容器包含了命名的属性、键值对的列表。这里面的属性可以是函数（函数对象），这种情形下我们称其为方法。一个“空对象”实际上并不是完全空白的，它包含有一些内置属性，但是没有其自身的属性。 关于创建的对象的另外一件事情是可以在任意时间修改该对象（尽管ECMAScript5引入了API来防止突变）。可以对一个对象执行添加、删除和更新它的成员变量。 最后需要记住的是对象主要有两种：原生的（Native），在ECMAScript标准中有详细描述。主机的（Host），在主机环境中定义的（例如浏览器环境）。原生的对象可以进一步分为内置对象（例如数组、日期对象等）和用户自定义对象（例如var o={};）等。主机对象包含windows对象和所有的DOM对象。 JavaScript中没有类。Javascript只处理对象。JavaScript没有继承，通常使用原型来实现继承。原型是一个对象，并且创建的每一个函数都会自动获取一个prototype属性，该属性指向一个新的空对象。该默认的原型对象几乎等同于采用对象字面量或Object()创建的对象，区别在于它的constructor属性指向了所创建的函数，而不是指向内置的Object()函数。 example. 1234567var func = function()&#123;&#125;;console.log(func.constructor); //output: function Function() &#123; [native code] &#125;console.log(func.prototype); //output: Object &#123;&#125;console.log(func.prototype.constructor); //output: function ()&#123;&#125;var obj = &#123;&#125;;console.log(obj.constructor); //output: function Object() &#123; [native code] &#125; 全局变量的问题全局变量的问题在于它们在整个Javascript应用或Web页面内共享，它们生存于同一个全局命名空间内，总有可能发生命名冲突。要尽可能少地使用全局变量，如使用命名空间模式或自执行立即生效函数（the self-executing immediate functions），但最重要的方法还是使用var声明变量。 Javascript总是在不知不觉中就出人意料地创建了全局变量，其原因在于Javascript的两个特性。第一个特性是Javascript可直接使用变量，甚至无需声明。第二个特性是Javascript有个暗示全局变量（implied globals）的概念，即任何变量，如果未经声明，就为全局对象所有（也就像正确声明过的全局变量一样可以访问）。 注：在ECMAScript5 strict模式中，为没有声明的变量赋值会抛出错误。 另一种创建隐式全局变量的反模式是带有var声明的链式赋值。 example. 1234function foo()&#123; var a = b = 0; //...&#125; 在这代码片段中，a是局部变量，b是全局变量，这也许并不是你想要的。这源于从右至左的操作符优先级。首先，优先级较高的是表达式b=0，此时b未经声明。表达式的返回值为0，它被赋给var声明的局部变量a，如以下代码表示： 1var a = (b = 0); 变量释放时的副作用隐式全局变量与明确定义的全局变量有细微的不同，不同之处在于能否使用delete操作符撤销变量。使用var创建的全局变量（这类变量在函数外部创建）不能删除。不使用var创建的隐式全局变量（尽管它是在函数内部创建）可以删除。这表明隐式全局变量严格来讲不是真正的变量，而是全局对象的属性。属性可以通过delete操作符删除，但变量不可以。 提升-凌散变量的问题Javascript允许在函数的任意地方声明多个变量，无论在哪里声明，效果都等同于在函数顶部进行声明。这就是所谓的“提升”。只要变量是在同一个范围（同一函数）里，就视为已经声明，哪怕是在变量声明前就使用。 example. 1234567myname = 'global';function func()&#123; alert(myname); //output: undefined var myname = 'local'; alert(myname); //output: local&#125;func(); 等同于 12345678myname = 'global';function func()&#123; var myname; //等同于 var myname = undefined; alert(myname); //output: undefined myname = 'local'; alert(myname); //output: local&#125;func(); 注：仅仅是变量声明提升了，赋值仍在原来的位置。 for循环for循环性能提升建议： 缓存遍历对象的长度，尤其是DOM元素。每次访问任何容器的长度时，也就是在查询活动的DOM。 逐步减至0，这样通常更快，因为同0比较更有效率。 example. 123for(var i=elements.length-1; i&gt;=0; i--)&#123;...&#125;//或for(var i=elements.length; i--; )&#123;...&#125; for-in循环用来遍历非数组对象，也被称为枚举。当遍历对象属性时，使用hasOwnProperty()来过滤原型链的属性。 example. 12345for(var i in obj)&#123; if(obj.hasOwnProperty(i))&#123;...&#125; //或 if(Object.prototype.hasOwnProperty(obj, i))&#123;...&#125;&#125; 避免使用eval()“eval()是一个魔鬼”。该函数可以将任意字符串当做一个Javascript代码来执行。当需要讨论的代码是预先就编写好了（不是在动态运行时决定），是没有理由使用eval()的。使用eval()存在安全隐患，因为这样做有可能执行被篡改过的代码（例如来自网络的代码）。这是在处理来自一个Ajax请求的JSON响应时常见的反模式，最好是使用浏览器内置的方法来解析JSON数据，以确保安全性和有效性。对于原生不支持JSON.parse()的浏览器来说，可以使用来自JSON.org网站的类库。 还有一点，通过setInterval()、setTimeout()和function()等构造函数来传递参数，在大部分情形下，会导致类似eval()的隐患。 example. 123456789//反模式 setTimeout('myFunc()', 1000);setTimeout('myFunc(1, 2, 3)', 1000);//推荐的模式 setTimeout(myFunc, 1000);setTimeout(function()&#123; myFunc(1, 2, 3);&#125;, 1000); 如果一定要使用eval()，那么可以考虑使用new Function()来替代eval()。这样做的一个潜在好处是由于在new Function()中的代码将在局部函数空间中运行，因此代码中任何采用var定义的变量不会自动成为全局变量。另一个避免自动成为全局变量的方法是将eval()调用封装到一个即时函数中。 example. 12345678910var jsstring = 'var one = 1; console.log(one);';eval(jsstring); //output: 1jsstring = 'var two = 2; console.log(two);';(function()&#123; eval(jsstring);&#125;()); //output: 2console.log(typeof one); //output: numberconsole.log(typeof two); //output: undefined 另一个new Function()和eval()的区别在于eval()会影响到作用域链，而Function()更多地类似于一个沙盒。无论在哪里执行Function，它都仅仅能看到全局作用域，因此对局部变量的影响较小。在接下来的例子中，eval()可以访问和修改它外部作用域的变量，然而Function不行（请注意使用Function和使用new Function是一样的）。 example. 12345678910(function()&#123; var local = 1; eval('local = 3; console.log(local);'); //output: 3 console.log(local); //output: 3&#125;());(function()&#123; var local = 1; Function('console.log(typeof local);')(); //output: undefined&#125;()); 参考JavaScript模式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
